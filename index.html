<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lập và theo dõi Kế hoạch BDSC xe vận tải</title>
    <style>
        /* CSS giữ nguyên như file gốc */
        .links-dropdown {
            display: block; position: absolute; background-color: #fff; min-width: 300px; max-width: 500px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 20; border-radius: 4px; border: 1px solid #ddd; padding: 5px;
        }
        .links-dropdown a {
            color: #0056b3; padding: 8px 12px; text-decoration: none; display: block; font-size: 14px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .links-dropdown a:hover { background-color: #f1f1f1; text-decoration: underline; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0; background-color: #f4f4f9; line-height: 1.6;
        }
        #container {
            max-width: 1400px; margin: auto; background-color: white;
            padding: 25px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: block;
        }
        #login-container {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            animation: fadeIn 0.3s;
        }
        #login-box {
            max-width: 400px;
            margin: 10% auto;
            padding: 30px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            text-align: center;
            position: relative;
            animation: slideIn 0.3s;
        }
        #login-box h2 { margin-top: 0; color: #333; }
        #login-box input {
            width: 100%; padding: 12px; margin-bottom: 15px; border: 1px solid #ccc;
            border-radius: 4px; box-sizing: border-box; font-size: 16px;
        }
        #login-box button { width: 100%; padding: 12px; font-size: 16px; }
        #login-container h2 { margin-top: 0; color: #333; }
        #login-container input {
            width: 100%; padding: 12px; margin-bottom: 15px; border: 1px solid #ccc;
            border-radius: 4px; box-sizing: border-box; font-size: 16px;
        }
        #login-container button { width: 100%; padding: 12px; font-size: 16px; }
        #login-error { color: #dc3545; margin-top: 15px; font-weight: bold; }

        h1, h2 { color: #333; }
        h3 { color: #555; font-weight: normal; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .button-group {
            display: flex; justify-content: space-between; align-items: center;
            margin-top: 10px; flex-wrap: wrap;
        }
        .button-group > div { display: flex; gap: 10px; flex-wrap: wrap; }
        button {
            border: none; padding: 10px 18px; border-radius: 5px;
            cursor: pointer; font-size: 16px; transition: background-color: 0.3s, transform: 0.1s;
        }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        button:active { transform: scale(0.98); }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-primary:hover { background-color: #0056b3; }
        .btn-danger { background-color: #dc3545; color: white; }
        .btn-danger:hover { background-color: #c82333; }
        .btn-secondary { background-color: #6c757d; color: white; }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-success:hover { background-color: #218838; }
        .btn-info { background-color: #17a2b8; color: white; }
        .btn-info:hover { background-color: #138496; }
        .btn-warning { background-color: #ffc107; color: #212529; }
        .btn-warning:hover { background-color: #e0a800; }
        .btn-action { padding: 5px 10px; font-size: 14px; margin-right: 5px;}

        input[type="file"] { border: 1px solid #ccc; padding: 8px; border-radius: 4px; }
        #taskList { margin-top: 20px; border-collapse: collapse; width: 100%; table-layout: fixed; }
        #taskList th, #taskList td {
            border: 1px solid #ddd; padding: 10px; text-align: left;
            vertical-align: middle; word-wrap: break-word;
            font-size: 80%;
        }
        #taskList th:first-child, #taskList td:first-child,
        #taskList th:nth-child(2), #taskList td:nth-child(2) {
             padding-left: 4px;
             text-align: left;
        }

        #taskList .btn-action { font-size: 14px; }
        #taskList th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .task-parent td { font-weight: bold; background-color: #e2e6ea; }
        .task-child td { font-weight: bold; background-color: #e9ecef; }
        .task-grandchild td { font-weight: bold; background-color: #f2f4f6; }
        .task-great-grandchild.is-parent-leaf td { background-color: #f8f9fa; }
        .task-great-great-grandchild td:nth-child(3) { font-style: italic; padding-left: 18px !important; }
        .task-justification { display: none; }
        .task-justification td { background-color: #fffbe6; color: red; }
        .task-justification td:nth-child(3) { padding-left: 30px !important; font-style: italic; }
        .task-justification td:nth-child(2) { padding-left: 25px !important; font-style: italic; }
        .task-justification td.col-tt {
            text-align: right;
            padding-right: 1px;
        }

        #taskList th.text-right, #taskList td.text-right { text-align: right; padding-right: 4px; }
        #taskList th.col-donvi, #taskList td.col-donvi,
        #taskList th.col-soluong, #taskList td.col-soluong {
            text-align: center;
        }

        #status { margin-top: 15px; font-weight: bold; }
        #status.success { color: #28a745; }
        #status.error { color: #dc3545; }

        #summarySection {
            background-color: #e9ecef; padding: 15px; border-radius: 5px; margin-top: 20px;
            display: flex; justify-content: space-between; flex-wrap: wrap;
            position: relative;
        }
        .summary-column { width: 48%; }
        #summarySection p { margin: 5px 0; font-size: 16px; }
        #summarySection p strong { color: #333; }
        .percentage { color: #007bff; font-weight: bold; }

        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn { from {opacity: 0;} to {opacity: 1;} }
        .modal-content {
            background-color: #fefefe; margin: 5% auto; padding: 25px;
            border: 1px solid #888; width: 90%; max-width: 1200px; border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2); animation: slideIn 0.3s;
        }
        @keyframes slideIn { from {transform: translateY(-50px);} to {transform: translateY(0);} }
        .modal-table { width: 100%; border-collapse: collapse; margin-top: 15px; table-layout: fixed; }
        .modal-table th, .modal-table td { border: 1px solid #ddd; padding: 8px; }
        .modal-table th { background-color: #f2f2f2; font-size: 80%; }
        .modal-table input { width: 95%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; }
        .modal-table input:disabled { background-color: #e9ecef; cursor: not-allowed;}

        .col-noidung { width: 23%; }
        .col-dv-thuchien { width: 8%; }
        .col-tt, .col-donvi, .col-soluong, .col-tansuat-th, .col-capdo, .col-hoso { width: 3%; }
		.col-soluong { width: 4%; }
        .col-ghichu { width: 10%; }
        .col-chiphi, .col-thanhtien, .col-kh-nam-truoc, .col-th-nam-truoc { width: 8%; }
        .col-tg-batdau, .col-tg-hoanthanh { width: 3%; }
        .col-dvt, .col-dongia { width: 6%; }

        .modal-table th:nth-child(1), .modal-table td:nth-child(1) { width: 3%; }
        .modal-table th:nth-child(2), .modal-table td:nth-child(2) { width: 25%; }
        .modal-table th:nth-child(3), .modal-table td:nth-child(3) { width: 6%; }
        .modal-table th:nth-child(4), .modal-table td:nth-child(4) { width: 7%; }
        .modal-table th:nth-child(6), .modal-table td:nth-child(6) { width: 3%; }
        .modal-table th:nth-child(8), .modal-table td:nth-child(8) { width: 3%; }
        .modal-table th:nth-child(9), .modal-table td:nth-child(9) { width: 7%; }
        .modal-table th:nth-child(10), .modal-table td:nth-child(10) { width: 3%; }
        .modal-table th:nth-child(11), .modal-table td:nth-child(11) { width: 3%; }

        .execution-modal-table th:nth-child(1), .execution-modal-table td:nth-child(1) { width: 8%; }
        .execution-modal-table th:nth-child(2), .execution-modal-table td:nth-child(2) { width: 54%; }
        .execution-modal-table th:nth-child(3), .execution-modal-table td:nth-child(3) { width: 12%; }
        .execution-modal-table th:nth-child(4), .execution-modal-table td:nth-child(4) { width: 13%; }
        .execution-modal-table th:nth-child(5), .execution-modal-table td:nth-child(5) { width: 13%; }

        .modal-footer { text-align: right; margin-top: 20px; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }

        #scrollToTopBtn {
            display: none; position: fixed; bottom: 25px; right: 25px; z-index: 999;
            border: none; outline: none; background-color: #007bff; color: white; cursor: pointer;
            padding: 0; border-radius: 50%; font-size: 24px; width: 50px; height: 50px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3); transition: background-color: 0.3s, transform 0.2s;
        }
        #scrollToTopBtn:hover { background-color: #0056b3; transform: translateY(-2px); }

        .dropdown { position: relative; display: inline-block; }
        .dropdown-content {
            display: none; position: absolute; background-color: #f9f9f9; min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 1; right: 0; border-radius: 4px;
        }
        .dropdown-content a { color: black; padding: 12px 16px; text-decoration: none; display: block; font-size: 14px; }
        .dropdown-content a:hover { background-color: #f1f1f2; }
        .show { display: block; }

        .modal-note {
            background-color: #f8f9fa; border-left: 4px solid #007bff; padding: 10px 15px;
            margin: 15px 0; font-size: 14px; color: #495057;
        }

        #yearSelect {
            padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px;
            font-size: 14px; background-color: white; cursor: pointer;
        }
        #yearSelect:focus {
            outline: none; border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

            

        .delete-confirm-modal, .export-options-modal { max-width: 500px; }
        .delete-confirm-modal input {
            width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #ccc;
            border-radius: 4px; box-sizing: border-box;
        }

        .planning-mode .col-hoso,
        .planning-mode .col-kehoach-conlai { display: none; }
		/* --- CSS MỚI CHO 2 CỘT PHÂN BỔ --- */
        /* Mặc định ẩn */
        .col-nam-phanbo, .col-chiphi-phanbo { display: none; }
        
        /* Hiển thị khi ở chế độ Planning */
        .planning-mode .col-nam-phanbo, 
        .planning-mode .col-chiphi-phanbo { display: table-cell; }

        /* Độ rộng cột */
        .planning-mode .col-nam-phanbo { width: 3%; text-align: center; }
        .planning-mode .col-chiphi-phanbo { width: 8%; text-align: right; }
        /* --------------------------------- */
        .col-tansuat-th, 
.col-kh-nam-truoc, 
.col-th-nam-truoc, 
.col-tg-hoanthanh { 
    display: none; 
}

/* === HIỂN THỊ CÁC CỘT THEO YÊU CẦU === */
.col-tg-batdau, 
.col-ghichu, 
.col-action { 
    display: table-cell; 
}

/* Thiết lập độ rộng mặc định cho chế độ xem (View Mode) */
.col-tg-batdau { width: 5%; text-align: center; }
.col-ghichu { width: 10%; } /* Điều chỉnh độ rộng ghi chú cho phù hợp */
.col-action { width: 5%; text-align: center; }
        .planning-mode .col-tansuat-th,
.planning-mode .col-ghichu,
.planning-mode .col-kh-nam-truoc,
.planning-mode .col-th-nam-truoc,
.planning-mode .col-tg-batdau,
.planning-mode .col-tg-hoanthanh,
.planning-mode .col-action { display: table-cell; }
        .planning-mode .task-justification { display: table-row; }

        .planning-mode .col-dv-thuchien { width: 4% !important; }
        .planning-mode .col-chiphi { width: 8%; }
        .planning-mode .col-chiphi-thuchien { width: 8% !important; }
        .planning-mode .col-kh-nam-truoc { width: 8% !important; }
		.planning-mode .col-th-nam-truoc { width: 8% !important; }
        .planning-mode .col-ghichu { width: 12%; }
        .planning-mode .col-action { width: 4% !important; }
		
		/* --- CSS ĐIỀU CHỈNH CỠ CHỮ CHO PLANNING MODE --- */
        /* Mặc định cỡ chữ của bảng là 80%.
           Yêu cầu giảm 15% (còn 85% của hiện tại).
           Tính toán: 80% * 0.85 = 70%.
        */
        #taskList.planning-mode th, 
        #taskList.planning-mode td {
            font-size: 70%; /* Giảm xuống còn 70% kích thước chuẩn */
            padding: 5px;   /* Giảm nhẹ padding (khoảng cách) để hàng gọn hơn */
        }
        
        /* Điều chỉnh cả các ô input/select nằm trong bảng khi ở chế độ này (nếu có) */
        #taskList.planning-mode input,
        #taskList.planning-mode select,
        #taskList.planning-mode textarea {
            font-size: 100%; /* Kế thừa 70% từ td cha */
        }

/* --- CSS MỚI: GIẢM CỠ CHỮ CHO MODAL THÊM/SỬA --- */
        
        /* 1. Giảm cỡ chữ cho tiêu đề (th) và nội dung (td) trong bảng Modal */
        #dataModal .modal-table th,
        #dataModal .modal-table td {
            font-size: 70%; /* Giảm cỡ chữ xuống còn 70% */
            padding: 4px;   /* Giảm khoảng cách đệm (padding) từ 8px xuống 5px cho gọn */
            line-height: 1.4; /* Điều chỉnh khoảng cách dòng */
        }

        /* 2. Điều chỉnh các ô Input bên trong Modal để khớp với cỡ chữ mới */
        #dataModal .modal-table input {
            font-size: 100%; /* Kế thừa cỡ chữ 70% từ thẻ td cha */
            padding: 3px;    /* Giảm padding trong ô nhập liệu */
            height: auto;    /* Để chiều cao tự động điều chỉnh theo cỡ chữ */
        }
        
        /* 3. (Tùy chọn) Nếu tiêu đề bảng (Header) bị nhỏ quá, bạn có thể giữ nguyên nó */
        /* Bỏ comment dòng dưới nếu bạn muốn tiêu đề to hơn nội dung một chút */
        /* #dataModal .modal-table th { font-size: 90%; } */

        #summaryDetailModal .modal-content { max-width: 95%; }
        .summary-details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .summary-parent-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background-color: #f8f9fa;
        }
        .summary-parent-card h3 {
            margin-top: 0;
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 8px;
            font-size: 1.1rem;
        }
        .summary-columns-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }
        .summary-info-column {
            width: 50%;
            font-size: 14px;
        }
        .summary-info-column h4 {
            margin-top: 0;
            margin-bottom: 8px;
            color: #495057;
            border-bottom: 1px solid #ccc;
            padding-bottom: 4px;
            font-size: 15px;
        }
        .summary-info-column p {
            margin: 4px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            justify-content: space-between;
        }
        .summary-info-column p strong {
            color: #495057;
        }
        .summary-parent-card .value {
            font-weight: bold;
            color: #333;
        }
        .summary-charts-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        .chart-wrapper {
            width: 45%;
            max-width: 150px;
            text-align: center;
        }
        .chart-wrapper p {
            font-size: 12px;
            margin-top: 5px;
            font-weight: bold;
            color: #333;
        }

        @media screen and (max-width: 768px) {
            .responsive-modal-table thead { display: none; }
            .responsive-modal-table, .responsive-modal-table tbody, .responsive-modal-table tr, .responsive-modal-table td {
                display: block; width: 100%;
            }
            .responsive-modal-table tr { margin-bottom: 15px; border: 1px solid #ddd; border-radius: 5px; padding: 10px; }
            .responsive-modal-table td {
                display: flex; justify-content: space-between; padding-left: 50%;
                position: relative; text-align: right; border: none; padding-bottom: 5px;
            }
            .responsive-modal-table td:before {
                content: attr(data-label); position: absolute; left: 10px; width: 45%;
                padding-right: 10px; font-weight: bold; text-align: left;
            }
            .search-modal-mobile td { font-size: 12px; }
            .search-modal-mobile .btn-edit-exec { display: none; }
            .search-modal-mobile .btn-profile-exec {
                flex: 1; padding: 10px 0; font-size: 16px; margin-top: 5px;
            }
            .summary-details-grid {
                grid-template-columns: 1fr;
            }
        }

.task-justification-parent td:nth-child(3) { 
            font-weight: bold;
            padding-left: 25px !important; 
        }
        .task-justification-child td:nth-child(3) { 
            font-style: italic; 
            padding-left: 40px !important; 
        }
        .task-justification-child td:nth-child(2) { 
            padding-left: 15px !important; 
        }
    
/* CSS cho modal Kế hoạch đã duyệt */
    #approvedPlanLinks {
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 10px;
        background-color: #f9f9f9;
        min-height: 100px;
    }
    #approvedPlanLinks p.loading-text,
    #approvedPlanLinks p.empty-text {
        text-align: center;
        color: #777;
        margin-top: 20px;
        font-style: italic;
    }
    .plan-link-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
        border-bottom: 1px solid #eee;
    }
    .plan-link-item:last-child {
        border-bottom: none;
    }
    .plan-link-item a {
        color: #0056b3;
        text-decoration: none;
        font-weight: 500;
        font-size: 16px;
        word-break: break-all; /* Tự xuống dòng nếu link quá dài */
        margin-right: 15px;
    }
    .plan-link-item a:hover {
        text-decoration: underline;
    }
    .plan-link-delete-btn {
        padding: 4px 8px;
        font-size: 12px;
        margin-left: 15px;
        flex-shrink: 0; /* Ngăn nút bị co lại */
    }

    /* CSS cho modal Dán link */
    #pasteLinkModal input[type="text"],
    #pasteLinkModal input[type="url"] {
        width: 100%;
        padding: 12px;
        margin-bottom: 15px;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
        font-size: 16px;
    }

    /* === KẾT THÚC MÃ MỚI === */


/* Thêm CSS này */
#taskList .editable-cell {
    cursor: pointer;
    transition: background-color 0.2s;
}
#taskList .editable-cell:hover {
    background-color: #f0f8ff; /* Màu xanh Alice blue nhạt */
}

/* Kiểu cho input khi đang chỉnh sửa */
.editable-input {
    width: 95%;
    padding: 6px;
    border: 1px solid #007bff;
    border-radius: 4px;
    box-sizing: border-box; /* Đảm bảo input vừa khít với ô */
}

/* --- CSS MỚI: ẨN NÚT ĐIỀU HƯỚNG (SPINNERS) TRONG Ô NHẬP SỐ --- */
        
        /* Dành cho Chrome, Safari, Edge, Opera */
        input[type=number]::-webkit-outer-spin-button,
        input[type=number]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Dành cho Firefox */
        input[type=number] {
            -moz-appearance: textfield;
        }

</style>


    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <script src="xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="chart.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

    <div id="login-container">
        <div id="login-box">
            <span class="close-button" onclick="closeLoginModal()">&times;</span>

            <img src="PVGLPG.gif" alt="Logo" style="width: 120px; height: auto; margin-bottom: 20px;">
            <h2>Đăng nhập Hệ thống</h2>
            <form id="login-form">
                <input type="text" id="email"
                       value="xetai***@pvgaslpg*****"
                       data-real-email="xetai-cnmb@pvgaslpg.com.vn"
                       readonly
                       style="background-color: #e9ecef; cursor: not-allowed; text-align: center; color: #495057;">
                <input type="password" id="password" placeholder="Mật khẩu" required autofocus>
                <button type="submit" class="btn-primary">Đăng nhập</button>
                <p id="login-error" style="display: none;"></p>
            </form>
        </div>
    </div>

    <div id="container">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <img src="PVGLPG.gif" alt="Logo" style="width: 100px; height: auto;">
            <h1 style="color: #008037; font-weight: bold; text-transform: uppercase; text-align: center; flex-grow: 1;">
                LẬP VÀ THEO DÕI KẾ HOẠCH<br>BDSC XE VẬN TẢI
            </h1>
            <div style="width: 150px;"></div>
        </div>

        <div class="button-group" style="padding-bottom: 10px; border-bottom: 1px solid #eee;">
            <div>
                <button class="btn-secondary" onclick="recalculateAllCostsAndReload()">Tải lại & Tính toán lại</button>
                <button class="btn-primary" onclick="openDataManagementModal()">Quản lý Dữ liệu</button>

                <button id="authButton" class="btn-info" onclick="promptForAuthentication()">Đăng nhập</button>
                <button id="logoutButton" class="btn-warning" style="display: none;" onclick="logoutUser()">Đăng xuất</button>
                <button id="deleteSelectedBtn" class="btn-danger" onclick="deleteSelectedTasks()" disabled>Xoá mục đã chọn</button>
                <button id="exportExcel1Btn" class="btn-success" onclick="exportToExcel(1)">Xuất Excel 1</button>
                <button id="exportExcel2Btn" class="btn-success" onclick="exportToExcel(2)" disabled>Xuất Excel 2</button>
            </div>
        </div>
        <div id="status"></div>

        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px;">
            <h2>CÁC ĐƠN VỊ CHI NHÁNH MIỀN BẮC</h2>
             <div> <label for="yearSelect" style="margin-right: 10px; font-weight: bold;">Năm:</label>
                <select id="yearSelect" onchange="changeYear(this.value)"></select>
                
                <button id="approvedPlanBtn" class="btn-secondary" onclick="openApprovedPlanModal()" style="margin-left: 10px;">KH đã duyệt</button>
             </div>
        </div>

        <div class="button-group" style="margin-bottom: 15px; justify-content: space-between;">
             <div>
                <button id="multiExecuteBtn" class="btn-info" onclick="openMultiExecutionModal()" disabled>Thực hiện công việc đã chọn</button>
                <button id="searchExecutionBtn" class="btn-primary" onclick="openSearchModal()">Tra cứu thực hiện</button>
             </div>
             <div style="display: flex; align-items: center;">
                <label for="planningModeToggle" style="margin-right: 10px; font-weight: bold;">Mở giao diện xây dựng kế hoạch</label>
                <input type="checkbox" id="planningModeToggle" onchange="togglePlanningColumns(this.checked)" disabled>
             </div>
        </div>

        <div id="summarySection"></div>

        <table id="taskList">
            <thead>
                <tr>
                    <th style="width: 2%;"><input type="checkbox" onchange="toggleAllCheckboxes(this)"></th>
                    <th class="col-tt" style="width: 3%;">TT</th>
                    <th class="col-noidung">Đầu việc/ Dự án</th>
                    <th class="col-dv-thuchien" style="width: 5%;">ĐV thực hiện</th>
                    
                    <th class="text-right col-kh-nam-truoc" style="width: 7%;">KH năm trước</th>
                    <th class="text-right col-th-nam-truoc" style="width: 7%;">Thực hiện năm trước</th>
                    
                    <th class="col-donvi">Đ.vị tính</th>
                    <th class="col-soluong">Số lượng</th>
                    <th class="col-tansuat-th">Tần suất TH</th>
                    <th class="text-right col-chiphi">Chi phí KH</th>
                    <th class="text-right col-chiphi-thuchien" style="width: 6%;">Chi phí thực hiện</th>
                    <th class="text-right col-kehoach-conlai" style="width: 6%;">Kế hoạch còn lại</th>
                    <th class="col-nam-phanbo">Năm PB</th>
                    <th class="col-chiphi-phanbo">CP phân bổ</th>
					
					<th class="col-capdo">Cấp độ</th>

                    <th class="col-tg-batdau" style="width: 4%;">TG bắt đầu</th>
                    <th class="col-tg-hoanthanh" style="width: 4%;">TG hoàn thành</th>

                    <th class="col-ghichu">Ghi chú</th>
                    <th class="col-hoso" style="width: 3%;">Hồ sơ</th>
                    <th style="width: 5%;" class="col-action">Hành động</th>
                </tr>
            </thead>
            <tbody id="taskListBody"></tbody>
        </table>
    </div>

    <!-- Các modal giữ nguyên như file gốc -->
    <div id="dataModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <div id="modalTitle"></div>
            <div id="modalBody"></div>
            <div class="modal-footer">
                <div id="modal-footer-left" style="float: left;"></div>
                <button id="modalDeleteButton" class="btn-danger" style="display: none; float: left;">Xóa</button>
                <button id="modalSaveButton" class="btn-success">Lưu thay đổi</button>
            </div>
        </div>
    </div>

    <div id="dataManagementModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Quản lý Dữ liệu</h2>
            <div style="margin-top: 20px;">
                <h3>Nhập dữ liệu từ file Excel</h3>
                <input type="file" id="excelFile" accept=".xlsx, .xls">
                <p><small><i>Chú ý: để chương trình nhận đúng dữ liệu, hãy định dạng các dữ liệu số trong file Excel ở định dạng General.</i></small></p>
                <button class="btn-primary" onclick="importData()" style="margin-top: 10px;">Nhập dữ liệu</button>
            </div>
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ccc;">
                <h3>Xóa toàn bộ dữ liệu</h3>
                <p style="color: #dc3545;"><strong>Cảnh báo:</strong> Hành động này không thể hoàn tác.</p>
                <button class="btn-danger" onclick="openDeleteAllDataModal()">Xoá tất cả</button>
            </div>
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ccc;">
                <h3>Mở khóa sửa đổi</h3>
                <button id="unlockButton" class="btn-warning" onclick="promptForUnlock()">Mở khóa cho phép sửa đổi</button>
                <div id="editModeToggle" style="display: none; margin-top: 10px; text-align: left;">
                    <input type="checkbox" id="editModeCheckbox" onchange="toggleEditMode(this.checked)" style="width: auto;">
                    <label for="editModeCheckbox">Cho phép sửa đổi, thêm, xóa dữ liệu</label>
                </div>
            </div>
        </div>
    </div>

    <div id="deleteAllDataModal" class="modal">
        <div class="modal-content delete-confirm-modal">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Xác nhận xóa toàn bộ dữ liệu</h2>
            <p style="color: #dc3545; font-weight: bold;">CẢNH BÁO: Bạn sắp xóa TOÀN BỘ dữ liệu. Hành động này không thể hoàn tác.</p>
            <p>Vui lòng nhập đầy đủ thông tin đăng nhập để xác nhận:</p>
            <div>
                <input type="text" id="deleteConfirmEmail" placeholder="Email đăng nhập">
                <input type="password" id="deleteConfirmPassword" placeholder="Mật khẩu">
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeAllModals()">Hủy</button>
                <button class="btn-danger" onclick="confirmDeleteAllData()">Xác nhận xóa toàn bộ</button>
            </div>
        </div>
    </div>

    <div id="uploadPdfModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2 id="uploadPdfModalTitle">Tải lên Hồ sơ PDF</h2>
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center mt-4">
                 <input type="file" id="pdf_file_input" accept=".pdf" class="block w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold
                    file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
            </div>
            <div class="modal-footer">
                <button id="uploadPdfButton" class="btn-primary">Tải Lên</button>
            </div>
        </div>
    </div>

    <div id="exportOptionsModal" class="modal">
        <div class="modal-content export-options-modal">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Tùy chọn Xuất file Excel</h2>
            <p>Vui lòng chọn định dạng file bạn muốn xuất:</p>
            
            <div style="display: flex; justify-content: space-around; margin-top: 20px; gap: 15px; flex-wrap: wrap;">
                
                <button class="btn-primary" style="flex: 1; min-width: 200px; padding: 15px;" onclick="exportPlainDataExcel()">
                    1. File Excel (.xlsx)
                    <br><small>(Có công thức, không định dạng màu)</small>
                </button>
                
                <button class="btn-success" style="flex: 1; min-width: 200px; padding: 15px;" onclick="exportFormattedExcel_HTML()">
                    2. File Excel 97 (.xls)
                    <br><small>(Có chữ đậm nhạt, có màu, không công thức)</small>
                </button>
                
                <button class="btn-info" style="flex: 1; min-width: 200px; padding: 15px;" onclick="exportToClipboard()">
                    3. Sao chép vào Clipboard
                    <br><small>(Dữ liệu có công thức, để dán thủ công vào Excel)</small>
                </button>
                </div>
        </div>
    </div>

    <div id="planningModeModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <span class="close-button" onclick="closePlanningModal()">&times;</span>
            <h2>Chọn phạm vi xem Kế hoạch</h2>
            <p>Vui lòng chọn dữ liệu bạn muốn hiển thị ở chế độ lập kế hoạch:</p>
            <div id="planningModeOptions" style="margin-top: 20px; max-height: 40vh; overflow-y: auto;">
            </div>
        </div>
    </div>

    <div id="summaryDetailModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Chi tiết thực hiện theo từng đơn vị năm <span id="summaryDetailYear"></span></h2>
            <div id="summaryDetailContent" class="summary-details-grid">
            </div>
        </div>
    </div>
<div id="approvedPlanModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Kế hoạch đã duyệt năm <span id="approvedPlanYear"></span></h2>
            <div id="approvedPlanLinks" style="margin-top: 20px; max-height: 60vh; overflow-y: auto;">
                </div>
            <div class="modal-footer">
                <button id="addPlanLinkBtn" class="btn-primary" onclick="openAddPlanLinkModal()">Nhập QĐ</button>
            </div>
        </div>
    </div>

    <div id="addPlanLinkModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Thêm Kế hoạch đã duyệt</h2>
            <p>Vui lòng chọn phương thức:</p>
            <div style="display: flex; justify-content: space-around; margin-top: 20px; gap: 15px;">
                <button class="btn-primary" style="flex: 1; padding: 15px;" onclick="openPasteLinkModal()">1. Dán link có sẵn</button>
                <button class="btn-success" style="flex: 1; padding: 15px;" onclick="startPlanUploadFlow()">2. Tải file từ máy tính</button>
            </div>
        </div>
    </div>

    <div id="pasteLinkModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Dán link tài liệu</h2>
            <div style="margin-top: 20px;">
                <input type="text" id="pastedLinkName" placeholder="Tên hiển thị (ví dụ: Quyết định 123)" style="width: 100%; box-sizing: border-box;">
                <input type="url" id="pastedLinkUrl" placeholder="https://..." style="width: 100%; box-sizing: border-box;">
            </div>
            <div class="modal-footer">
                <button class="btn-success" onclick="savePastedLink()">Lưu link</button>
            </div>
        </div>
    </div>

      

<button id="scrollToTopBtn" title="Lên đầu trang" onclick="scrollToTop()">&uarr;</button>

    <div style="text-align: center; padding: 20px; color: #888; font-size: 12px;">
      Contact: hai.nm@pvgaslpg.com.vn
    </div>

    <script type="module">
    // Thêm hai hàm chuyển đổi vào đầu script
    function convertTTForStorage(tt) {
        return String(tt).replace(/\./g, ',');
    }

    function convertTTForDisplay(tt) {
        return String(tt).replace(/,/g, '.');
    }

// === BẮT ĐẦU MÃ MỚI: HÀM HỖ TRỢ SỐ LA MÃ ===
    function numberToRoman(num) {
        const romanMap = [
            { value: 1000, numeral: 'M' },
            { value: 900, numeral: 'CM' },
            { value: 500, numeral: 'D' },
            { value: 400, numeral: 'CD' },
            { value: 100, numeral: 'C' },
            { value: 90, numeral: 'XC' },
            { value: 50, numeral: 'L' },
            { value: 40, numeral: 'XL' },
            { value: 10, numeral: 'X' },
            { value: 9, numeral: 'IX' },
            { value: 5, numeral: 'V' },
            { value: 4, numeral: 'IV' },
            { value: 1, numeral: 'I' }
        ];
        let result = '';
        if (num <= 0) return '';
        for (const { value, numeral } of romanMap) {
            while (num >= value) {
                result += numeral;
                num -= value;
            }
        }
        return result;
    }

    function romanToNumber(roman) {
        if (!roman) return 0;
        const romanMap = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 };
        let result = 0;
        const r = roman.toUpperCase(); // Đảm bảo là chữ hoa
        for (let i = 0; i < r.length; i++) {
            const current = romanMap[r[i]];
            const next = romanMap[r[i + 1]];
            if (next && current < next) {
                result -= current;
            } else {
                result += current;
            }
        }
        return result;
    }
    // === KẾT THÚC MÃ MỚI ===
	
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, EmailAuthProvider, reauthenticateWithCredential, signOut } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { getDatabase, ref, set, get, update, remove, child, push, query, orderByChild, equalTo, onValue, off } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

    const firebaseConfig = {
        apiKey: "AIzaSyApKOu598qpanbjPRYdDYBplMFiM402HNw",
  authDomain: "congtacbdsc2.firebaseapp.com",
  databaseURL: "https://congtacbdsc2-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "congtacbdsc2",
  storageBucket: "congtacbdsc2.firebasestorage.app",
  messagingSenderId: "528060092768",
  appId: "1:528060092768:web:472d6ece2344795dff4e05",
  measurementId: "G-2QYPT9MSX8"
    };
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    const CLIENT_ID = "588583798336-o4gjnfqaupmmdp8mi38o9m8r4n0bbghs.apps.googleusercontent.com";
    const DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"];
    const SCOPES = "https://www.googleapis.com/auth/drive.file";
    const FOLDER_ID = "1uyHJHfNFLIdPQbYu1uF4zliORCM6QK3P";

    const statusDiv = document.getElementById('status');
    let selectedTasks = new Set();
    let selectedJustifications = new Set();
    let executionGroups = new Map();
    let docDataMap = new Map();
let parentNoiDungMap = new Map();
    let tokenClient;
    let gapiReady = false;
let gisInited = false;
    let editModeStatusByYear = {};
    let currentYear = new Date().getFullYear();
    let planningModeByYear = {};
    let isAuthenticated = false;
    let activeExportType = 'simplified';
    let activeCharts = [];

    // =======================================================
// === CÁC HÀM HELPER CHO LOGIC NHẬP LIỆU MỚI (V4) =======
// =======================================================

/**
 * Tìm giá trị trong một hàng (row) dựa trên danh sách các khóa (keys) có thể có.
 * Ưu tiên các khóa xuất hiện trước trong danh sách.
 */
const findValue = (row, keys, headers) => {
    for (const key of keys) {
        // Tìm header gốc trong file Excel (không phân biệt hoa thường/khoảng trắng)
        const lowerKey = key.toLowerCase().trim();
        const originalHeader = headers.find(h => String(h).toLowerCase().trim() === lowerKey);

        // Nếu tìm thấy header và hàng đó có giá trị cho header này
        if (originalHeader && row[originalHeader] !== undefined && row[originalHeader] !== null && row[originalHeader] !== '') {
            // Kiểm tra xem giá trị có phải là chuỗi rỗng không
            if (String(row[originalHeader]).trim() === '') {
                 continue; // Bỏ qua chuỗi rỗng, thử key tiếp theo
            }
            return row[originalHeader]; // Trả về giá trị tìm thấy
        }
    }
    // Nếu không tìm thấy giá trị hợp lệ nào sau khi thử hết keys
    return undefined;
};


/**
 * Đọc dữ liệu các lần thực hiện từ một hàng Excel.
 */
const readExecutionsForRow = (row, headers) => {
    const executions = [];
    let i = 1;
    const headersSet = new Set(headers.map(h => String(h).toLowerCase().trim())); // Để kiểm tra nhanh

    while (true) {
        const ngayTHKey = `ngày th (${i})`;
        const soLuongKey = `số lượng (${i})`;
        const donGiaKey = `đơn giá (${i})`;
        const thanhTienKey = `thành tiền (${i})`;
        const timestampKey = `timestamp (${i})`;
        const hoSoLinkKey = `hồ sơ link (${i})`;

        // Tìm header gốc tương ứng trong file Excel
        const originalNgayTH = headers.find(h => String(h).toLowerCase().trim() === ngayTHKey);
        const originalSoLuong = headers.find(h => String(h).toLowerCase().trim() === soLuongKey);
        const originalDonGia = headers.find(h => String(h).toLowerCase().trim() === donGiaKey);
        const originalThanhTien = headers.find(h => String(h).toLowerCase().trim() === thanhTienKey);
        const originalTimestamp = headers.find(h => String(h).toLowerCase().trim() === timestampKey);
        const originalHoSoLink = headers.find(h => String(h).toLowerCase().trim() === hoSoLinkKey);

        // Chỉ dừng nếu không có BẤT KỲ cột nào của lần thực hiện thứ 'i' tồn tại
        if (!originalNgayTH && !originalSoLuong && !originalDonGia && !originalThanhTien && !originalTimestamp && !originalHoSoLink) {
            break; // Hết cột thực hiện
        }

        const ngayThucHien = originalNgayTH ? row[originalNgayTH] : '';
        const dvt = originalSoLuong ? parseNumber(row[originalSoLuong]) : 0;
        const donGia = originalDonGia ? parseNumber(row[originalDonGia]) : 0;
        const thanhTien = originalThanhTien ? parseNumber(row[originalThanhTien]) : 0;
        const timestamp = originalTimestamp ? row[originalTimestamp] : null;
        const hoSoLink = originalHoSoLink ? row[originalHoSoLink] : null;

        // Chỉ thêm vào nếu có ít nhất một giá trị hợp lệ
        if (ngayThucHien || dvt > 0 || donGia > 0 || thanhTien > 0 || timestamp || hoSoLink) {
            executions.push({
                ngayThucHien: ngayThucHien || '',
                dvt: dvt,
                donGia: donGia,
                thanhTien: thanhTien,
                timestamp: timestamp || null,
                lanThucHien: i, // Giữ lại số thứ tự lần thực hiện
                hoSoLink: hoSoLink || null
            });
        }
        i++;
    }
    return executions;
};

/**
 * Kiểm tra xem có bất kỳ header nào trong danh sách 'keys'
 * tồn tại trong Set các header của file Excel hay không.
 */
const hasHeaderForField = (keys, headersSet) => {
    for (const key of keys) {
        // Đảm bảo so sánh không phân biệt hoa thường
        if (headersSet.has(key.toLowerCase().trim())) return true;
    }
    return false;
};

// --- Đảm bảo các hàm helper khác này cũng tồn tại ở global scope ---
// (Bạn có thể đã có chúng từ mã nguồn gốc)
// function convertTTForStorage(tt) { ... }
// function convertTTForDisplay(tt) { ... }
// const parseNumber = (str) => { ... };
// const parseFormattedNumber = (str) => { ... };
// function getParentCollectionName() { ... }

// =======================================================
// === KẾT THÚC KHỐI HELPER =============================
// =======================================================

const parseNumber = (str) => {
        if (str === null || str === undefined) return 0;
        let s = String(str).trim();
        if (s === '') return 0;
        const lastDot = s.lastIndexOf('.');
        const lastComma = s.lastIndexOf(',');
        let numberStr;
        if (lastComma > lastDot) {
            numberStr = s.replace(/\./g, '').replace(',', '.');
        } else {
            numberStr = s.replace(/,/g, '');
        }
        const result = parseFloat(numberStr);
        return isNaN(result) ? 0 : result;
    };
    const parseFormattedNumber = (str) => {
        if (str === null || str === undefined) return 0;
        let s = String(str).trim();
        if (s === '') return 0;
        const numberStr = s.replace(/\./g, '').replace(',', '.');
        const result = parseFloat(numberStr);
        return isNaN(result) ? 0 : result;
    };

    function getParentCollectionName() {
        return `congViecMe${currentYear}`;
    }

// === CÁC HÀM HELPER CHO LOGIC IMPORT MỚI ===

/**
 * Hàm chuẩn hóa TT: Loại bỏ khoảng trắng thừa, chuyển dấu phẩy thành dấu chấm,
 * loại bỏ dấu chấm ở cuối câu (ví dụ "1." -> "1").
 */
function normalizeTT(rawTT) {
    if (!rawTT) return '';
    return String(rawTT)
        .trim()                  // Xóa khoảng trắng đầu cuối
        .replace(/\s+/g, '')     // Xóa khoảng trắng ở giữa (VD: "1. 1" -> "1.1")
        .replace(/,/g, '.')      // Chuyển phẩy thành chấm (VD: "1,1" -> "1.1")
        .replace(/\.$/, '')      // Xóa dấu chấm cuối cùng (VD: "A." -> "A")
        .replace(/^\./, '');     // Xóa dấu chấm đầu tiên (nếu có)
}

/**
 * Hàm xác định cấp độ của TT dựa trên Regex
 * ĐÃ SỬA: Chỉ nhận diện số La Mã nếu viết IN HOA.
 */
function detectLevel(tt) {
    // 1. Cấp 1 (Parent): A, B, C... (Chữ cái in hoa)
    const isLevel1_Alpha = /^[A-Z]$/;

    // 2. Cấp 2 (Child - Roman): I, II, III, IV... (CHỈ IN HOA)
    // --- SỬA ĐỔI: Đã xóa cờ 'i' ở cuối regex để bắt buộc khớp chính xác chữ hoa ---
    const isLevel2_Roman = /^(I|II|III|IV|V|VI|VII|VIII|IX|X|XI|XII|XIII|XIV|XV|XVI|XVII|XVIII|XIX|XX|XXI|XXII|XXIII|XXIV|XXV|XXVI|XXVII|XXVIII|XXIX|XXX|XXXI|XXXII|XXXIII|XXXIV|XXXV|XXXVI|XXXVII|XXXVIII|XXXIX)$/;

    // 3. Cấp 3 (Grandchild - Integer): 1, 2, 3...
    const isLevel3_Integer = /^\d+$/;

    // 4. Cấp 4 (GreatGrandchild - x.x): 1.1, 2.3...
    const isLevel4_Decimal = /^\d+\.\d+$/;

    // 5. Cấp 5 (GreatGreatGrandchild - x.x.x): 1.1.1, 2.3.1...
    const isLevel5_Decimal = /^\d+\.\d+\.\d+$/;

    // 6. Giải trình (Justification - a, b, c... hoặc (a), a))
    // Regex này bắt các chữ cái thường
    const isJustification = /^(\(?[a-z]\)?|[a-z]\.)$/; 
    
    // 7. Giải trình con (SubJustification - a1, a2...)
    const isSubJustification = /^[a-z]\d+$/;

    // --- LOGIC PHÂN LOẠI ---
    
    // Kiểm tra số La Mã trước. Vì đã bỏ 'i', nó chỉ khớp I, V, X...
    // Nếu là 'i', 'v' (thường), nó sẽ trả về false và trôi xuống check isJustification bên dưới.
    if (isLevel2_Roman.test(tt)) return 'child';
    
    if (isLevel1_Alpha.test(tt)) return 'parent';
    
    if (isLevel5_Decimal.test(tt)) return 'greatGreatGrandchild';
    if (isLevel4_Decimal.test(tt)) return 'greatGrandchild';
    if (isLevel3_Integer.test(tt)) return 'grandchild';
    
    if (isSubJustification.test(tt)) return 'subJustification';
    
    // Xử lý giải trình (a, b, i...)
    if (isJustification.test(tt)) return 'justification';

    return 'unknown';
}


function buildImportUpdates_Merge(jsonData, headers) {
    console.log('=== START Smart Import Logic (Optimized Regex) ===');
    const updates = {};
    const rootPath = getParentCollectionName();

    // Map header để tìm dữ liệu bất kể chữ hoa/thường
    const headersSet = new Set(headers.map(h => String(h).toLowerCase().trim()));
    const hasExecutionColumns = headers.some(h => String(h).toLowerCase().trim().startsWith('ngày th'));

    // State management: Lưu giữ đường dẫn cha hiện tại
    let state = {
        parent: null,           // Cấp 1 (A)
        child: null,            // Cấp 2 (I)
        grandchild: null,       // Cấp 3 (1)
        greatGrandchild: null,  // Cấp 4 (1.1)
        lastLeaf: null,         // Nút lá cuối cùng (để gán giải trình)
        lastJustification: null // Giải trình cấp 1 cuối cùng (để gán giải trình con)
    };

    const masterDataFieldMapping = {
         noiDung: ['đầu việc/dự án', 'đầu việc/ dự án', 'đầu việc', 'dự án', 'nội dung', 'nội dung công việc'],
         donVi: ['đơn vị tính', 'đ.vị tính', 'đơn vị', 'đvt'],
         soLuong: ['số lượng', 'số lượng vật tư'],
         donGia: ['đơn giá (gt)'],
         chiPhi: ['chi phí', 'chi phi', 'chi phí kế hoạch', 'chi phí kh'],
         tanSuatTH: ['tần suất th', 'tần suất thực hiện'],
         dvThucHien: ['đv th.hiện', 'đơn vị thực hiện', 'đơn vị th', 'đv thực hiện'],
         namPhanBo: ['năm phân bổ', 'năm pb', 'số năm phân bổ', 'nam phan bo'],
         capDo: ['cấp độ', 'cap do'],
         khNamTruoc: ['kh năm trước', 'kế hoạch năm trước'],
         thucHienNamTruoc: ['thực hiện năm trước', 'th nam truoc', 'th năm trước'],
         tgBatDau: ['tg bắt đầu', 'tg bat dau', 'thời gian bắt đầu'],
         tgHoanThanh: ['tg hoàn thành', 'tg hoan thanh', 'thời gian hoàn thành'],
         ghiChu: ['ghi chú', 'ghi chu']
    };

    jsonData.forEach((row, index) => {
        // 1. Chuẩn hóa TT đầu vào
        const rawTT = String(row.TT || '');
        const tt = normalizeTT(rawTT); // Ví dụ: " 1,1 " -> "1.1"

        if (!tt) return; // Bỏ qua dòng trống TT

        // 2. Xác định cấp độ
        let level = detectLevel(tt);
        
        // --- XỬ LÝ NGOẠI LỆ "I" ---
        // Nếu tt là "I", nó có thể là Cấp 1 (A, B... I, K) hoặc Cấp 2 (I, II).
        // Logic thông minh: Nếu chưa có Cấp 1 nào (đầu file) -> I là cấp 1.
        // Nếu vừa mới có Cấp 1 (ví dụ A) -> I là cấp 2.
        if (tt === 'I') {
            if (state.parent) level = 'child'; // Đã có cha (VD: A), thì I là con
            else level = 'parent'; // Chưa có cha, I là cha đầu tiên (hiếm gặp nhưng có thể)
        }
        
        // Chuẩn hóa TT cho Storage (Firebase dùng dấu phẩy cho path số)
        const storageTT = (level === 'justification' || level === 'subJustification') 
            ? tt.replace(/[\(\)\.]/g, '') // (a) -> a, a. -> a
            : convertTTForStorage(tt);    // 1.1 -> 1,1

        let currentPath = '';
        let isTask = false;
        let isLeaf = false;

        try {
            switch (level) {
                case 'parent': // A, B
                    currentPath = `${rootPath}/${storageTT}`;
                    // Reset cây con
                    state.parent = currentPath;
                    state.child = null; state.grandchild = null; state.greatGrandchild = null;
                    state.lastLeaf = null;
                    isTask = true;
                    break;

                case 'child': // I, II
                    if (!state.parent) throw new Error(`Mục "${tt}" thiếu cấp cha (A, B...).`);
                    currentPath = `${state.parent}/children/${storageTT}`;
                    state.child = currentPath;
                    state.grandchild = null; state.greatGrandchild = null;
                    state.lastLeaf = null;
                    isTask = true;
                    break;

                case 'grandchild': // 1, 2
                    if (!state.child) throw new Error(`Mục "${tt}" thiếu cấp cha La Mã (I, II...).`);
                    currentPath = `${state.child}/grandchildren/${storageTT}`;
                    state.grandchild = currentPath;
                    state.greatGrandchild = null;
                    state.lastLeaf = null;
                    isTask = true;
                    break;

                case 'greatGrandchild': // 1.1, 1.2
                    // Kiểm tra logic cha con: 1.1 phải nằm trong 1
                    const parentOfL4 = storageTT.substring(0, storageTT.lastIndexOf(',')); // 1,1 -> 1
                    if (!state.grandchild || !state.grandchild.endsWith(`/${parentOfL4}`)) {
                         // Fallback mềm dẻo: Nếu không khớp cha logic, cứ nhét vào cha gần nhất
                         if (!state.grandchild) throw new Error(`Mục "${tt}" thiếu cấp cha (1, 2...).`);
                    }
                    
                    currentPath = `${state.grandchild}/greatGrandchildren/${storageTT}`;
                    state.greatGrandchild = currentPath;
                    state.lastLeaf = currentPath; // Tạm coi là lá, nếu có con 1.1.1 thì nó sẽ mất quyền lá
                    isTask = true;
                    isLeaf = true; 
                    break;

                case 'greatGreatGrandchild': // 1.1.1
                    // Logic tương tự cấp 4
                    if (!state.greatGrandchild) throw new Error(`Mục "${tt}" thiếu cấp cha (1.1, 1.2...).`);
                    
                    currentPath = `${state.greatGrandchild}/greatGreatGrandchildren/${storageTT}`;
                    state.lastLeaf = currentPath;
                    isTask = true;
                    isLeaf = true;
                    
                    // Cấp 4 bây giờ trở thành container, không còn là lá
                    if (state.greatGrandchild) {
                        updates[`${state.greatGrandchild}/hasChildren`] = true;
                        updates[`${state.greatGrandchild}/executions`] = null; // Xóa thực hiện ở cha nếu có
                    }
                    break;

                case 'justification': // a, b
                    if (!state.lastLeaf) throw new Error(`Giải trình "${tt}" không có công việc cha.`);
                    currentPath = `${state.lastLeaf}/justifications/${storageTT}`;
                    state.lastJustification = currentPath;
                    break;

                case 'subJustification': // a1, a2
                    if (!state.lastJustification) throw new Error(`Giải trình con "${tt}" thiếu giải trình cha (a, b...).`);
                    currentPath = `${state.lastJustification}/subJustifications/${storageTT}`;
                    updates[`${state.lastJustification}/hasSubJustifications`] = true;
                    // Reset giá trị cha vì giờ nó là tổng của con
                    updates[`${state.lastJustification}/chiPhi`] = 0; 
                    break;

                default:
                    console.warn(`Không nhận diện được cấp độ của TT: ${tt}`);
                    return;
            }

            // --- THU THẬP DỮ LIỆU ---
            const data = {};
            // Luôn cập nhật TT chuẩn
            updates[`${currentPath}/tt`] = storageTT;

            for (const [field, keys] of Object.entries(masterDataFieldMapping)) {
                if (hasHeaderForField(keys, headersSet)) {
                    const value = findValue(row, keys, headers);
                    if (value !== undefined) {
                        if (['soLuong', 'donGia', 'khNamTruoc', 'chiPhi', 'thucHienNamTruoc', 'namPhanBo'].includes(field)) {
                            data[field] = parseNumber(value);
                        } else if (field === 'tanSuatTH') {
                            // Logic tần suất: Nếu trống -> 1
                            data[field] = (value === '' || value === null) ? 1 : (parseInt(value, 10) || 0);
                        } else {
                            data[field] = value;
                        }
                    } else {
                        // Nếu trong file Excel có cột đó nhưng ô trống -> Set null
                        data[field] = null; 
                    }
                }
            }

            // Xử lý logic đặc biệt cho Chi phí phân bổ
            if ((isLeaf && isTask) && data.namPhanBo && data.namPhanBo > 0) {
                 const cp = data.chiPhi || 0;
                 data.chiPhiPhanBo = Math.round(cp / data.namPhanBo);
            } else if (isLeaf && isTask) {
                 data.chiPhiPhanBo = 0;
            }

            // Xử lý Executions (Thực hiện) - Chỉ dành cho nút lá
            if (isLeaf && isTask && hasExecutionColumns) {
                const executions = readExecutionsForRow(row, headers);
                if (executions.length > 0) {
                    data.executions = executions.reduce((obj, exec, i) => {
                        obj[exec.lanThucHien || (i + 1)] = exec;
                        return obj;
                    }, {});
                } else {
                    data.executions = null;
                }
            }

            // Ghi dữ liệu vào updates
            for (const field in data) {
                updates[`${currentPath}/${field}`] = data[field];
            }

            // Khởi tạo các trường tính toán nếu chưa có
            if (isTask) {
                if (updates[`${currentPath}/chiPhiThucHien`] === undefined) updates[`${currentPath}/chiPhiThucHien`] = 0;
                if (updates[`${currentPath}/keHoachConLai`] === undefined) updates[`${currentPath}/keHoachConLai`] = 0;
            }

        } catch (e) {
            console.error(`Lỗi dòng ${index + 2} (TT: ${tt}): ${e.message}`);
            // Có thể thêm logic thông báo lỗi vào UI tại đây nếu muốn
        }
    });

    console.log(`=== END Smart Import. Total updates: ${Object.keys(updates).length} ===`);
    return updates;
}

    // === BẮT ĐẦU MÃ MỚI ===

    /**
     * Mở modal hiển thị danh sách Kế hoạch đã duyệt (KHĐD) cho năm hiện tại.
     * Hoạt động ngay cả khi chưa đăng nhập Firebase.
     */
    window.openApprovedPlanModal = async function() {
        const modal = document.getElementById('approvedPlanModal');
        const linksContainer = document.getElementById('approvedPlanLinks');
        const addBtn = document.getElementById('addPlanLinkBtn');
        
        document.getElementById('approvedPlanYear').textContent = currentYear;
        linksContainer.innerHTML = '<p class="loading-text">Đang tải danh sách...</p>';
        modal.style.display = 'block';

        // Hiển thị/ẩn nút "Nhập QĐ" dựa trên trạng thái đăng nhập Firebase
        addBtn.style.display = isAuthenticated ? 'block' : 'none';

        try {
            // Đường dẫn lưu trữ mới, độc lập với 'congViecMeYYYY'
            const dbPath = `approved_plans/${currentYear}`;
            const planRef = ref(db, dbPath);
            const snapshot = await get(planRef);

            if (snapshot.exists()) {
                const data = snapshot.val();
                let html = '';
                // Sắp xếp các link theo thời gian thêm (mới nhất trước)
                const sortedKeys = Object.keys(data).sort((a, b) => 
                    (data[b].timestamp || 0) - (data[a].timestamp || 0)
                );

                for (const key of sortedKeys) {
                    const link = data[key];
                    if (!link.url) continue; // Bỏ qua nếu dữ liệu không có url

                    // Chỉ hiển thị nút Xóa khi đã đăng nhập và cho phép chỉnh sửa
                    const canEdit = isAuthenticated && editModeStatusByYear[currentYear] === true;
const deleteBtnHtml = canEdit ? 
    `<button class="btn-danger btn-action plan-link-delete-btn" onclick="deleteApprovedPlanLink('${key}', '${link.name || link.url}')">Xóa</button>` : '';
                    
                    html += `<div class="plan-link-item">
                                <a href="${link.url}" target="_blank" title="${link.url}">${link.name || link.url}</a>
                                ${deleteBtnHtml}
                             </div>`;
                }
                linksContainer.innerHTML = html || '<p class="empty-text">Chưa có kế hoạch nào được duyệt cho năm này.</p>';
            } else {
                linksContainer.innerHTML = '<p class="empty-text">Chưa có kế hoạch nào được duyệt cho năm này.</p>';
            }
        } catch (error) {
            console.error("Lỗi khi tải Kế hoạch đã duyệt:", error);
            linksContainer.innerHTML = `<p class="empty-text" style="color: red;">Lỗi tải dữ liệu: ${error.message}</p>`;
        }
    }

    /**
     * Xóa một link Kế hoạch đã duyệt khỏi CSDL.
     * Yêu cầu xác thực Firebase.
     */
    window.deleteApprovedPlanLink = async function(linkKey, linkName) {
        if (!isAuthenticated) return showAuthError();
        if (!confirm(`Bạn có chắc chắn muốn xóa link này không?\n\n${linkName}`)) return;

        try {
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đang xóa link...';
            const dbPath = `approved_plans/${currentYear}/${linkKey}`;
            await remove(ref(db, dbPath)); // Sử dụng hàm 'remove' của Firebase
            statusDiv.innerText = 'Đã xóa link thành công.';
            await openApprovedPlanModal(); // Tải lại danh sách trong modal
        } catch (error) {
            console.error("Lỗi khi xóa link:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi: ${error.message}`;
        }
    }

    /**
     * Mở modal lựa chọn cách thêm link (dán/tải file).
     * Yêu cầu xác thực Firebase.
     */
    window.openAddPlanLinkModal = function() {
        if (!isAuthenticated) return showAuthError();
        // Đóng modal danh sách
        document.getElementById('approvedPlanModal').style.display = 'none';
        // Mở modal lựa chọn
        document.getElementById('addPlanLinkModal').style.display = 'block';
    }

    /**
     * Mở modal để dán link thủ công.
     */
    window.openPasteLinkModal = function() {
        // Đóng modal lựa chọn
        document.getElementById('addPlanLinkModal').style.display = 'none';
        // Xóa giá trị cũ và mở modal dán link
        document.getElementById('pastedLinkName').value = '';
        document.getElementById('pastedLinkUrl').value = '';
        document.getElementById('pasteLinkModal').style.display = 'block';
        document.getElementById('pastedLinkName').focus();
    }

    /**
     * Lưu link được dán thủ công vào CSDL.
     * Yêu cầu xác thực Firebase.
     */
    window.savePastedLink = async function() {
        if (!isAuthenticated) return showAuthError();
        
        const name = document.getElementById('pastedLinkName').value.trim();
        const url = document.getElementById('pastedLinkUrl').value.trim();

        if (!url) {
            alert("Vui lòng nhập đường link (URL).");
            return;
        }
        if (!name) {
            alert("Vui lòng nhập tên hiển thị cho link.");
            return;
        }
        
        const saveData = {
            url: url,
            name: name,
            timestamp: Date.now()
        };

        const saveButton = document.querySelector('#pasteLinkModal .btn-success');
        try {
            saveButton.disabled = true;
            saveButton.textContent = 'Đang lưu...';
            
            const listRef = ref(db, `approved_plans/${currentYear}`);
            await push(listRef, saveData); // Sử dụng 'push' để tạo ID duy nhất

            closeAllModals(); // Đóng modal dán link
            await openApprovedPlanModal(); // Mở lại modal danh sách (sẽ tự động tải lại)
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đã lưu link thành công.';

        } catch (error) {
            console.error("Lỗi khi lưu link:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi: ${error.message}`;
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = 'Lưu link';
        }
    }

    /**
     * Bắt đầu quy trình tải file Kế hoạch lên Google Drive.
     * Tái sử dụng hàm requestGoogleAuth() và modal #uploadPdfModal.
     * Yêu cầu xác thực Firebase.
     */
    window.startPlanUploadFlow = async function() {
        if (!isAuthenticated) return showAuthError();
        
        closeAllModals(); // Đóng modal lựa chọn
        statusDiv.innerText = 'Kiểm tra quyền truy cập Google Drive...';
        statusDiv.className = '';

        try {
            // 1. Yêu cầu/Kiểm tra xác thực Google (hàm này đã có sẵn)
            await requestGoogleAuth();
            
            // 2. Nếu xác thực thành công, mở modal upload
            statusDiv.innerText = '';
            document.getElementById('uploadPdfModalTitle').textContent = 'Tải lên Kế hoạch đã duyệt (PDF)';
            
            // 3. **QUAN TRỌNG:** Gán hàm 'onclick' MỚI cho nút tải lên
            document.getElementById('uploadPdfButton').onclick = window.performApprovedPlanUpload;
            
            document.getElementById('pdf_file_input').value = '';
            document.getElementById('uploadPdfModal').style.display = 'block';

        } catch (error) {
            // Lỗi đã được xử lý và hiển thị bởi requestGoogleAuth()
            console.error('Không thể tải lên do lỗi xác thực Google:', error);
        }
    }

    /**
     * Hàm xử lý việc tải file Kế hoạch (được gọi từ modal #uploadPdfModal).
     * Đây là bản sao của 'performPdfUpload' nhưng lưu vào CSDL 'approved_plans'.
     * Yêu cầu xác thực Firebase.
     */
    window.performApprovedPlanUpload = async function() {
        if (!isAuthenticated) return showAuthError();
        
        const googleToken = gapi.client.getToken();
        if (!googleToken || !googleToken.access_token) {
            statusDiv.className = 'error';
            statusDiv.innerText = 'Phiên đăng nhập Google đã hết hạn. Vui lòng thử lại thao tác "Tải file".';
            closeAllModals();
            return;
        }

        const uploadButton = document.getElementById('uploadPdfButton');
        const fileInput = document.getElementById('pdf_file_input');
        const file = fileInput.files[0];
        if (!file) { 
            alert('Vui lòng chọn một tệp PDF.'); 
            return; 
        }
        
        try {
            uploadButton.disabled = true; 
            uploadButton.textContent = 'Đang tải...';
            statusDiv.className = 'success'; 
            statusDiv.innerText = 'Đang tải tệp lên Google Drive...';
            
            // Sử dụng cùng FOLDER_ID với chức năng hồ sơ
            const metadata = { name: file.name, mimeType: 'application/pdf', parents: [FOLDER_ID] };
            const formData = new FormData();
            formData.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
            formData.append('file', file);
            
            const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${googleToken.access_token}` },
                body: formData
            });
            
            if (!response.ok) { 
                const error = await response.json(); 
                throw new Error(`Lỗi API Drive: ${error.error.message}`); 
            }
            
            const fileData = await response.json();
            const fileLink = `https://drive.google.com/file/d/${fileData.id}/view`;
            console.log('Tải lên Drive thành công:', fileLink);
            
            statusDiv.innerText = 'Đang cập nhật link vào cơ sở dữ liệu...';

            // **THAY ĐỔI:** Lưu dữ liệu vào path 'approved_plans'
            const saveData = {
                url: fileLink,
                name: file.name, // Lưu lại tên file
                timestamp: Date.now()
            };
            const listRef = ref(db, `approved_plans/${currentYear}`);
            await push(listRef, saveData); // Sử dụng 'push'
            // **KẾT THÚC THAY ĐỔI**

            closeAllModals(); // Đóng modal upload
            await openApprovedPlanModal(); // Mở lại modal danh sách (sẽ tự động tải lại)
            statusDiv.className = 'success';
            statusDiv.innerText = `Tải lên và cập nhật Kế hoạch thành công!`;

        } catch (error)
        {
            console.error('Lỗi khi tải tệp kế hoạch:', error);
            statusDiv.className = 'error';
            let errorMsg = error.message;
            if (errorMsg.includes('API Drive')) {
                errorMsg = `Lỗi tải lên Google Drive: ${error.message}.`;
            } else if (errorMsg.includes('token')) {
                errorMsg = `Lỗi xác thực Google: ${error.message}. Vui lòng thử lại.`;
            }
            statusDiv.innerText = `Đã xảy ra lỗi: ${errorMsg}`;
        } finally {
            uploadButton.disabled = false;
            uploadButton.textContent = 'Tải Lên';
            fileInput.value = '';
        }
    };
    
    // === KẾT THÚC MÃ MỚI ===

    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('container');
    const loginForm = document.getElementById('login-form');
    const loginError = document.getElementById('login-error');



// Hàm gọi lại sau khi nhận token
    // Hàm gọi lại sau khi nhận token
    function tokenResponseCallback(resp) {
        if (resp.error !== undefined) {
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi xác thực Google: ${resp.error}`;
            throw (resp);
        }
        console.log('Xác thực Google thành công (Callback).');
        // === THÊM DÒNG NÀY ===
        gapi.client.setToken(resp); // Lưu token vào thư viện GAPI client
        // ======================
        // Cập nhật giao diện (nếu chưa được cập nhật bởi luồng promise)
        // updateSigninStatus(true); // Có thể không cần nếu requestGoogleAuth xử lý
    }

    // Hàm xử lý việc yêu cầu xác thực
    async function requestGoogleAuth() {
        return new Promise((resolve, reject) => {
             if (!gapiReady || !gisInited || !tokenClient) {
                 statusDiv.className = 'error';
                 statusDiv.innerText = 'Thư viện Google chưa sẵn sàng. Vui lòng thử lại sau giây lát.';
                 return reject(new Error('Google libraries not ready'));
             }

             // Kiểm tra xem đã có token chưa
             const currentToken = gapi.client.getToken();
             if (currentToken && currentToken.access_token) {
                 console.log('Đã có token Google hợp lệ.');
                 return resolve(true); // Đã đăng nhập
             }

             // Nếu chưa có token, yêu cầu người dùng cấp quyền
             console.log('Yêu cầu cấp quyền Google Drive...');

             // *** Đảm bảo callback được gán TRƯỚC khi gọi requestAccessToken ***
             tokenClient.callback = (resp) => { // Gán callback tạm thời
                 if (resp.error) {
                     statusDiv.className = 'error';
                     statusDiv.innerText = `Lỗi cấp quyền: ${resp.error_description || resp.error}`; // Hiển thị mô tả lỗi nếu có
                     console.error('Lỗi cấp quyền Google:', resp);
                     tokenClient.callback = tokenResponseCallback; // *** Khôi phục callback mặc định ***
                     return reject(resp.error);
                 }
                 // Xác thực thành công -> tokenResponseCallback mặc định đã chạy và setToken
                 statusDiv.className = 'success';
                 statusDiv.innerText = 'Đã cấp quyền thành công. Bạn có thể tải tệp lên.';
                 console.log('Cấp quyền thành công (Promise resolved).');
                 tokenClient.callback = tokenResponseCallback; // *** Khôi phục callback mặc định ***
                 resolve(true);
             };
             // *** Gọi requestAccessToken SAU KHI gán callback ***
             tokenClient.requestAccessToken({ prompt: 'consent' }); // Hiển thị popup yêu cầu quyền
        });
    }


    // ĐỊNH NGHĨA TẤT CẢ CÁC HÀM CẦN THIẾT
    window.initializeYearDropdown = function() {
        const yearSelect = document.getElementById('yearSelect');
        const currentYearValue = new Date().getFullYear();
        const nextYear = currentYearValue + 1;
        yearSelect.innerHTML = '';
        const years = [currentYearValue, nextYear];
        for (let i = currentYearValue - 1; i >= currentYearValue - 3; i--) {
            years.unshift(i);
        }
        years.forEach(year => {
            const option = document.createElement('option');
            option.value = year;
            option.textContent = year;
            yearSelect.appendChild(option);
        });
        currentYear = currentYearValue;
        yearSelect.value = currentYearValue;
    };

   window.openDataManagementModal = function() {
        const modal = document.getElementById('dataManagementModal');
        modal.style.display = 'block';

        const unlockBtn = document.getElementById('unlockButton');
        const toggleDiv = document.getElementById('editModeToggle');
        const checkbox = document.getElementById('editModeCheckbox');
        const adminEmail = "admin@pvgaslpg.com.vn";

        // Reset trạng thái nút để tránh bị mờ từ lần trước
        unlockBtn.disabled = false;
        unlockBtn.textContent = 'Mở khóa cho phép sửa đổi';

        // 1. Kiểm tra xem người dùng hiện tại có phải là Admin không
        const currentUser = auth.currentUser;
        const isAdmin = currentUser && currentUser.email === adminEmail;

        // 2. Lấy trạng thái thực tế từ Database (đang bật hay tắt)
        const isCurrentlyEnabled = editModeStatusByYear[currentYear] === true;

        if (isAdmin) {
            // Nếu là Admin: Hiện công tắc, Ẩn nút khóa
            unlockBtn.style.display = 'none';
            toggleDiv.style.display = 'block';
            
            // QUAN TRỌNG: Checkbox hiển thị đúng theo dữ liệu DB, không ép buộc = true
            checkbox.checked = isCurrentlyEnabled;
        } else {
            // Nếu không phải Admin: Hiện nút khóa
            unlockBtn.style.display = 'block';
            toggleDiv.style.display = 'none';
            checkbox.checked = isCurrentlyEnabled; // Vẫn gán để đồng bộ ngầm
        }
    };

    window.promptForAuthentication = function() {
        closeAllModals();
        loginContainer.style.display = 'block';
    };

    window.closeLoginModal = function() {
        const loginContainer = document.getElementById('login-container');
        const passwordInput = document.getElementById('password');
        const loginError = document.getElementById('login-error');

        loginContainer.style.display = 'none';
        passwordInput.value = '';
        loginError.style.display = 'none';
    };

    // Đổi tên hàm để phản ánh đúng chức năng mới
window.calculateModalChiPhi = function(input) {
    const row = input.closest('tr');
    if (!row) return;

    const soLuongInput = row.querySelector('input[data-field="soLuong"]');
    const donGiaInput = row.querySelector('input[data-field="donGia"]');
    const chiPhiInput = row.querySelector('input[data-field="chiPhi"]');
    const namPbInput = row.querySelector('input[data-field="namPhanBo"]');
    const cpPbInput = row.querySelector('input[data-field="chiPhiPhanBo"]');
    
    // 1. Tính Chi Phí (nếu là lá)
    let currentChiPhi = 0;
    if (chiPhiInput && !chiPhiInput.disabled) {
        const soLuong = parseNumber(soLuongInput.value);
        const donGia = parseNumber(donGiaInput.value);
        currentChiPhi = soLuong * donGia;
        chiPhiInput.value = formatNumber(currentChiPhi);
    } else if (chiPhiInput) {
        currentChiPhi = parseNumber(chiPhiInput.value);
    }

    // 2. Tính CP Phân Bổ (CHỈ NẾU Ô NĂM PHÂN BỔ ĐƯỢC PHÉP NHẬP)
    if (namPbInput && !namPbInput.disabled && cpPbInput) {
        const nam = parseNumber(namPbInput.value);
        if (nam > 0) {
            cpPbInput.value = formatNumber(Math.round(currentChiPhi / nam));
        } else {
            cpPbInput.value = 0;
        }
    }
};

// === HÀM MỚI ĐỂ XUẤT EXCEL TRA CỨU (CẬP NHẬT LẦN 4 bổ sung tên CV cấp 3 và mã hiệu) ===
window.exportExecutionSearchExcel = async function() {
        if (executionGroups.size === 0) {
            alert("Không có dữ liệu thực hiện để xuất.");
            return;
        }

        try {
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đang chuẩn bị dữ liệu Excel...';
            
            const excelData = [];
            let sequenceNumber = 1;

            excelData.push([
                "Thứ tự", 
                "Ngày thực hiện", 
                "Mã hiệu", 
                "Nội dung công việc", 
                "ĐV thực hiện", 
                "Thành tiền"
            ]);

            const sortedTimestamps = Array.from(executionGroups.keys()).sort((a, b) => {
                const firstExecA = Object.values(Object.values(executionGroups.get(a) || {})[0] || {})[0]?.[0];
                const firstExecB = Object.values(Object.values(executionGroups.get(b) || {})[0] || {})[0]?.[0];
                const dateA = new Date(firstExecA?.ngayThucHien || 0);
                const dateB = new Date(firstExecB?.ngayThucHien || 0);
                if (dateB - dateA !== 0) return dateB - dateA;
                return (firstExecB?.timestamp || 0) - (firstExecA?.timestamp || 0);
            });


            for (const timestampKey of sortedTimestamps) {
                const timestampGroup = executionGroups.get(timestampKey); 
                
                const allExecsInTimestamp = Object.values(timestampGroup).flatMap(grandchildGroup => 
                    Object.values(grandchildGroup).flat()
                );
                if (allExecsInTimestamp.length === 0) continue;

                const firstExec = allExecsInTimestamp[0];
                const ngayThucHienGroup = firstExec.ngayThucHien || '';

                let khuVuc = 'Không xác định';
                const pathParts = firstExec.parentLeafNodePath.split('/');
                if (pathParts.length > 1) {
                    const parentId = pathParts[1];
                    khuVuc = parentNoiDungMap.get(parentId) || parentId;
                }
                
                const totalThanhTienGroup = allExecsInTimestamp.reduce((sum, exec) => sum + (exec.thanhTien || 0), 0);

                const groupHeaderRow = [
                    sequenceNumber++,     
                    ngayThucHienGroup,    
                    '',                   
                    khuVuc,               
                    '',                   
                    totalThanhTienGroup   
                ];
                excelData.push(groupHeaderRow);
                
                const sortedGrandchildPaths = Object.keys(timestampGroup).sort((a, b) => {
                    const idA = parseInt(a.split('/').pop(), 10) || 0;
                    const idB = parseInt(b.split('/').pop(), 10) || 0;
                    return idA - idB;
                });
                
                for (const grandchildPath of sortedGrandchildPaths) {
                    const grandchildGroup = timestampGroup[grandchildPath]; 
                    const allExecsInGrandchild = Object.values(grandchildGroup).flat();
                    if (allExecsInGrandchild.length === 0) continue;
                    
                    // === BẮT ĐẦU THAY ĐỔI: Lấy Mã hiệu (tt) Cấp 3 ===
                    let dauMucC3 = 'Không xác định';
                    let maHieuC3 = ''; // <-- Biến mới

                    const grandchildData = docDataMap.get(grandchildPath);
                    if (grandchildData) {
                        dauMucC3 = grandchildData.noiDung || 'Không xác định';
                        maHieuC3 = grandchildData.tt ? convertTTForDisplay(grandchildData.tt) : '';
                    } else {
                        // Fallback (nếu docDataMap bị lỡ) - Lấy cả node
                        try {
                            const taskSnap = await get(ref(db, grandchildPath)); 
                            if (taskSnap.exists()) {
                                const data = taskSnap.val();
                                dauMucC3 = data.noiDung || 'Không xác định';
                                maHieuC3 = data.tt ? convertTTForDisplay(data.tt) : '';
                            }
                        } catch (e) { console.warn(`Không thể lấy data cho ${grandchildPath}`); }
                    }
                    // === KẾT THÚC THAY ĐỔI ===
                    
                    const totalThanhTienC3 = allExecsInGrandchild.reduce((sum, exec) => sum + (exec.thanhTien || 0), 0);

                    // === THAY ĐỔI: Thêm maHieuC3 vào mảng ===
                    const subGroupHeaderRow = [
                       '',                   // Thứ tự (để trống)
                       '',                   // Ngày thực hiện (để trống)
                       maHieuC3,             // Mã hiệu (CẬP NHẬT)
                       `  ${dauMucC3}`,       // Nội dung: Tên Cấp 3
                       '',                   // ĐV thực hiện (để trống)
                       totalThanhTienC3      // Thành tiền: Tổng của nhóm Cấp 3
                    ];
                    excelData.push(subGroupHeaderRow);
                    // === KẾT THÚC THAY ĐỔI ===

                    for (const exec of allExecsInGrandchild) {
                       let maHieu = '';
                       const taskData = docDataMap.get(exec.parentLeafNodePath);
                        if (taskData && taskData.tt) {
                           maHieu = convertTTForDisplay(taskData.tt);
                       } else {
                           try {
                               const taskSnap = await get(ref(db, exec.parentLeafNodePath + '/tt'));
                               if (taskSnap.exists()) {
                                   maHieu = convertTTForDisplay(taskSnap.val());
                               }
                           } catch (e) { console.warn(`Không thể lấy tt cho ${exec.parentLeafNodePath}`); }
                       }

                       const detailRow = [
                           '',                   
                           '',                   
                           maHieu,               
                           `    - ${exec.noiDung || ''}`, 
                           exec.dvThucHien || '', 
                           exec.thanhTien || 0    
                       ];
                       excelData.push(detailRow);
                    }
                }
            } 

            statusDiv.innerText = 'Đang tạo file Excel...';
            
            const ws = XLSX.utils.aoa_to_sheet(excelData);
            
            const moneyFormat = '#,##0'; 
            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let R = 1; R <= range.e.r; ++R) {
                const cell_address = XLSX.utils.encode_cell({c: 5, r: R}); 
                if (!ws[cell_address]) continue; 
                if (typeof ws[cell_address].v === 'number') { 
                    ws[cell_address].t = 'n';
                    ws[cell_address].z = moneyFormat;
                }
            }

            // Logic in đậm (giữ nguyên, sẽ tự động in đậm Cấp 3)
            for (let R = 1; R <= range.e.r; ++R) {
                const maHieuCellAddr = XLSX.utils.encode_cell({c: 2, r: R});
                // Sửa logic: Chỉ in đậm nếu cột Mã hiệu trống (dành cho Cấp 1)
                if (!ws[maHieuCellAddr] || ws[maHieuCellAddr].v === '') {
                     for (let C = 0; C <= range.e.c; ++C) {
                         const cellAddr = XLSX.utils.encode_cell({c: C, r: R});
                         if (!ws[cellAddr]) ws[cellAddr] = { t: 's', v: '' };
                         if (!ws[cellAddr].s) ws[cellAddr].s = {};
                         if (!ws[cellAddr].s.font) ws[cellAddr].s.font = {};
                         ws[cellAddr].s.font.bold = true;
                     }
                } 
                // === THAY ĐỔI: Logic in đậm MỚI cho Cấp 3 ===
                // Nếu cột Mã hiệu (C) không trống, NHƯNG cột Ngày (B) trống
                // => đây là hàng Cấp 3
                else {
                    const ngayCellAddr = XLSX.utils.encode_cell({c: 1, r: R});
                    if (!ws[ngayCellAddr] || ws[ngayCellAddr].v === '') {
                        for (let C = 0; C <= range.e.c; ++C) {
                             const cellAddr = XLSX.utils.encode_cell({c: C, r: R});
                             if (!ws[cellAddr]) ws[cellAddr] = { t: 's', v: '' };
                             if (!ws[cellAddr].s) ws[cellAddr].s = {};
                             if (!ws[cellAddr].s.font) ws[cellAddr].s.font = {};
                             ws[cellAddr].s.font.bold = true;
                         }
                    }
                }
                // === KẾT THÚC THAY ĐỔI ===
            }

            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "TraCuuThucHien");

            XLSX.writeFile(wb, `TraCuuThucHien_${currentYear}.xlsx`);

            statusDiv.innerText = 'Xuất Excel thành công!';

        } catch (error) {
            console.error("Lỗi khi xuất Excel tra cứu:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi khi xuất file: ${error.message}`;
        }
    };
    // === KẾT THÚC HÀM XUẤT EXCEL ===

    window.calculateThanhTien = function(input) {
    const row = input.closest('tr');
    if (!row) return;

    const soLuongInput = row.querySelector('input[data-field="dvt"]');
    const donGiaInput = row.querySelector('input[data-field="donGia"]');
    const thanhTienInput = row.querySelector('input[data-field="thanhTien"]');

    const soLuong = parseNumber(soLuongInput.value);
    const donGia = parseNumber(donGiaInput.value);
    const cost = soLuong * donGia;

    // Cập nhật giá trị của ô thành tiền
    thanhTienInput.value = formatNumber(cost);
};

/**
 * HÀM TÍNH TOÁN LẠI TOÀN BỘ (PHIÊN BẢN TỐI ƯU HÓA - BATCH PROCESSING)
 * Thực hiện theo quy trình 7 bước từ dưới lên trên, giảm thiểu lặp lại.
 */
/**
 * HÀM TÍNH TOÁN LẠI TOÀN BỘ (CẬP NHẬT: XỬ LÝ NĂM PHÂN BỔ MẶC ĐỊNH)
 */
window.recalculateAllCostsAndReload = async function(showConfirm = true) {
    if (!isAuthenticated) return showAuthError();

    if (showConfirm && !confirm("Bạn có muốn tính toán lại toàn bộ chi phí không? Hệ thống sẽ rà soát và tổng hợp dữ liệu theo từng cấp.")) {
        return;
    }

    const button = document.querySelector('button[onclick="recalculateAllCostsAndReload()"]');
    if(button) button.disabled = true;
    
    try {
        statusDiv.className = 'success';
        statusDiv.innerText = 'Đang tải dữ liệu (Bước 0/7)...';

        const rootRef = ref(db, getParentCollectionName());
        const snapshot = await get(rootRef);
        
        if (!snapshot.exists()) {
            statusDiv.innerText = 'Không có dữ liệu để tính toán.';
            if(button) button.disabled = false;
            return;
        }

        const allData = snapshot.val();
        const updates = {}; 

        const updateNode = (path, fields) => {
            for (const key in fields) {
                updates[`${path}/${key}`] = fields[key];
                let node = allData;
                const parts = path.split('/').slice(1); 
                for (let i = 0; i < parts.length - 1; i++) {
                    if(node) node = node[parts[i]];
                }
                if (node && node[parts[parts.length-1]]) {
                    node[parts[parts.length-1]][key] = fields[key];
                }
            }
            
            let node = allData;
            const parts = path.split('/').slice(1);
            for (let p of parts) if(node) node = node[p];
            
            if (node) {
                const cp = node.chiPhi || 0;
                const cpth = node.chiPhiThucHien || 0;
                const khcl = cp - cpth;
                updates[`${path}/keHoachConLai`] = khcl;
                node.keHoachConLai = khcl; 
            }
        };

        const parents = Object.keys(allData);

        statusDiv.innerText = 'Đang xử lý nút lá (Bước 1-3/7)...';
        
        const processLeafNode = (node, path) => {
            let totalChiPhi = 0;
            let totalThucHien = 0;
            let hasExecutions = false;

            if (node.executions) {
                for (const key in node.executions) {
                    totalThucHien += (node.executions[key].thanhTien || 0);
                    hasExecutions = true;
                }
            }

            if (node.justifications) {
                for (const jKey in node.justifications) {
                    const just = node.justifications[jKey];
                    let justCost = 0;
                    
                    if (just.hasSubJustifications && just.subJustifications) {
                        for (const sKey in just.subJustifications) {
                            justCost += (just.subJustifications[sKey].chiPhi || 0);
                        }
                        if (just.chiPhi !== justCost) {
                            updates[`${path}/justifications/${jKey}/chiPhi`] = justCost;
                            just.chiPhi = justCost;
                        }
                    } else {
                        justCost = just.chiPhi || 0;
                    }
                    totalChiPhi += justCost;
                }
            } else {
                totalChiPhi = node.chiPhi || 0;
            }

            // === CẬP NHẬT LOGIC NĂM PHÂN BỔ MẶC ĐỊNH ===
            let cpPhanBo = 0;
            let namPhanBo = node.namPhanBo;

            // Nếu namPhanBo chưa có giá trị (null/undefined/0)
            // NHƯNG có chi phí > 0, thì gán mặc định là 1
            if (!namPhanBo && totalChiPhi > 0) {
                namPhanBo = 1;
                // Ghi nhận cập nhật giá trị mặc định vào updates
                updates[`${path}/namPhanBo`] = 1;
            }

            // Tính toán CP Phân Bổ
            if (namPhanBo > 0) {
                cpPhanBo = Math.round(totalChiPhi / namPhanBo);
            }
            // ============================================

            updateNode(path, {
                chiPhi: totalChiPhi,
                chiPhiThucHien: totalThucHien,
                daThucHien: hasExecutions,
                chiPhiPhanBo: cpPhanBo 
            });
        };

        const traverseToLeaves = (node, path) => {
            const hasChildren = (node.children || node.grandchildren || node.greatGrandchildren || node.greatGreatGrandchildren || node.hasChildren);
            
            if (!hasChildren) {
                processLeafNode(node, path);
            } else {
                if (node.executions) {
                    let th = 0;
                    for(let k in node.executions) th += node.executions[k].thanhTien || 0;
                     updateNode(path, { chiPhiThucHien: th, daThucHien: true });
                }
                updates[`${path}/soLuong`] = null;
                updates[`${path}/donGia`] = null;
                updates[`${path}/donVi`] = null;
            }

            if (node.children) Object.keys(node.children).forEach(k => traverseToLeaves(node.children[k], `${path}/children/${k}`));
            if (node.grandchildren) Object.keys(node.grandchildren).forEach(k => traverseToLeaves(node.grandchildren[k], `${path}/grandchildren/${k}`));
            if (node.greatGrandchildren) Object.keys(node.greatGrandchildren).forEach(k => traverseToLeaves(node.greatGrandchildren[k], `${path}/greatGrandchildren/${k}`));
            if (node.greatGreatGrandchildren) Object.keys(node.greatGreatGrandchildren).forEach(k => traverseToLeaves(node.greatGreatGrandchildren[k], `${path}/greatGreatGrandchildren/${k}`));
        };

        for (const pid of parents) {
            traverseToLeaves(allData[pid], `${getParentCollectionName()}/${pid}`);
        }

        statusDiv.innerText = 'Đang tổng hợp dữ liệu (Bước 4-7/7)...';

        const aggregateFromChildren = (parentNode, childCollectionName) => {
            let sumCP = 0, sumTH = 0, sumKHPrev = 0, sumTHPrev = 0, sumCPPhanBo = 0;
            let anyExecuted = false;
            
            if (parentNode[childCollectionName]) {
                for (const key in parentNode[childCollectionName]) {
                    const child = parentNode[childCollectionName][key];
                    sumCP += (child.chiPhi || 0);
                    sumTH += (child.chiPhiThucHien || 0);
                    sumKHPrev += (child.khNamTruoc || 0);
                    sumTHPrev += (child.thucHienNamTruoc || 0);
                    sumCPPhanBo += (parseFloat(child.chiPhiPhanBo) || 0);

                    if (child.daThucHien || (child.executions && Object.keys(child.executions).length > 0)) {
                         anyExecuted = true;
                    }
                    if (child.children || child.grandchildren || child.greatGrandchildren || child.greatGreatGrandchildren) {
                         if(child.daThucHien) anyExecuted = true;
                    }
                }
            }
            return { 
                chiPhi: sumCP, 
                chiPhiThucHien: sumTH, 
                khNamTruoc: sumKHPrev, 
                thucHienNamTruoc: sumTHPrev, 
                daThucHien: anyExecuted,
                chiPhiPhanBo: sumCPPhanBo 
            };
        };

        const aggregateNodeRecursively = (node, path) => {
            if (node.children) Object.keys(node.children).forEach(k => aggregateNodeRecursively(node.children[k], `${path}/children/${k}`));
            if (node.grandchildren) Object.keys(node.grandchildren).forEach(k => aggregateNodeRecursively(node.grandchildren[k], `${path}/grandchildren/${k}`));
            if (node.greatGrandchildren) Object.keys(node.greatGrandchildren).forEach(k => aggregateNodeRecursively(node.greatGrandchildren[k], `${path}/greatGrandchildren/${k}`));

            let aggResult = null;

            if (node.greatGreatGrandchildren) { 
                 aggResult = aggregateFromChildren(node, 'greatGreatGrandchildren');
            } else if (node.greatGrandchildren) { 
                 aggResult = aggregateFromChildren(node, 'greatGrandchildren');
            } else if (node.grandchildren) { 
                 aggResult = aggregateFromChildren(node, 'grandchildren');
            } else if (node.children) { 
                 aggResult = aggregateFromChildren(node, 'children');
            }

            if (aggResult) {
                updateNode(path, aggResult);
            }
        };

        for (const pid of parents) {
            aggregateNodeRecursively(allData[pid], `${getParentCollectionName()}/${pid}`);
        }

        statusDiv.innerText = 'Đang lưu dữ liệu...';
        if (Object.keys(updates).length > 0) {
            await update(ref(db), updates);
        }

        await calculateSummaryData();
        await fetchData();

        statusDiv.className = 'success';
        statusDiv.innerText = 'Đã tính toán lại toàn bộ dữ liệu thành công!';

    } catch (error) {
        console.error("Lỗi khi tính toán lại:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Đã xảy ra lỗi: ${error.message}`;
    } finally {
        if(button) button.disabled = false;
    }
};

/**
 * HÀM HELPER MỚI
 * Trả về một đối tượng chứa các trường cần set về 'null' cho một nút cha.
 */
function getCleanupFieldsForParentNode(path) {
    return {
        [`${path}/donVi`]: null,
        [`${path}/soLuong`]: null,
        [`${path}/donGia`]: null,
        [`${path}/tanSuatTH`]: null
        // Chúng ta giữ lại 'dvThucHien' và 'capDo' vì chúng có thể hữu ích
    };
}

    window.logoutUser = async function() {
        if(confirm('Bạn có muốn đăng xuất và quay về chế độ chỉ xem không?')) {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Lỗi đăng xuất:", error);
                statusDiv.className = 'error';
                statusDiv.innerText = 'Lỗi khi đăng xuất: ' + error.message;
            }
        }
    };

    window.deleteSelectedTasks = async function() {
        if (!isAuthenticated) return showAuthError();
        if (selectedTasks.size === 0 && selectedJustifications.size === 0) { alert("Vui lòng chọn ít nhất một mục để xoá."); return; }

        try {
            for (const path of selectedTasks) {
                const execSnapshot = await get(ref(db, `${path}/executions`));
                if (execSnapshot.exists() && Object.keys(execSnapshot.val()).length > 0) {
                    const taskDoc = await get(ref(db, path));
                    const taskName = taskDoc.exists() ? taskDoc.val().noiDung : 'không xác định';
                    alert(`Công việc "${taskName}" (Mục ${taskDoc.val().tt}) đã được thực hiện nên không được phép xóa.`);
                    return;
                }
            }
        } catch (error) {
            statusDiv.className = 'error'; statusDiv.innerText = `Lỗi khi kiểm tra công việc: ${error.message}`; return;
        }

        const totalToDelete = selectedTasks.size + selectedJustifications.size;
        if (!confirm(`Bạn có chắc chắn muốn xoá vĩnh viễn ${totalToDelete} mục đã chọn không?`)) return;

        const deleteButton = document.getElementById('deleteSelectedBtn');
        try {
            deleteButton.disabled = true;
            statusDiv.className = 'success'; statusDiv.innerText = `Đang xoá ${totalToDelete} mục...`;
            const updates = {};
            const allPathsToDelete = [...selectedTasks, ...selectedJustifications];
            const taskPathsToRecalculate = new Set();
            const justPathsToRecalculate = new Set();
            const parentsToUpdate = new Map();

            for (const path of allPathsToDelete) {
                updates[path] = null;
                if (path.includes('justifications')) {
                    justPathsToRecalculate.add(path.substring(0, path.lastIndexOf('/justifications/')));
                } else {
                    taskPathsToRecalculate.add(path);
                    if (path.includes('greatGreatGrandchildren')) {
                        const parentPath = path.substring(0, path.lastIndexOf('/greatGreatGrandchildren/'));
                        if (!parentsToUpdate.has(parentPath)) {
                            const parentSnapshot = await get(ref(db, `${parentPath}/greatGreatGrandchildren`));
                            parentsToUpdate.set(parentPath, parentSnapshot.exists() ? Object.keys(parentSnapshot.val()).length : 0);
                        }
                    }
                }
            }

            await update(ref(db), updates);

            const updateBatch = {};
            for (const [parentPath, childCount] of parentsToUpdate.entries()) {
                if (childCount === 1) {
                     updateBatch[`${parentPath}/hasChildren`] = false;
                }
            }
            await update(ref(db), updateBatch);

            statusDiv.innerText = "Đã xoá. Đang tính toán lại chi phí...";
            if (justPathsToRecalculate.size > 0) await recalculateCostsAfterJustificationChange(Array.from(justPathsToRecalculate));
            if (taskPathsToRecalculate.size > 0) await recalculateCostsForParents(Array.from(taskPathsToRecalculate));

            await fetchData();
            statusDiv.innerText = `Đã xoá thành công ${totalToDelete} mục.`;
        } catch (error) {
            console.error("Lỗi khi xoá công việc:", error);
            statusDiv.className = 'error'; statusDiv.innerText = `Lỗi khi xoá: ${error.message}`;
        } finally {
            updateButtonStates();
        }
    };

    window.exportToExcel = function(type) {
    // Gán giá trị 'simplified' cho Excel 1 và 'full' cho Excel 2
    activeExportType = type === 1 ? 'simplified' : 'full';
    document.getElementById('exportOptionsModal').style.display = 'block';
};

    window.openMultiExecutionModal = function() {
        if (!isAuthenticated) return showAuthError();
        const allSelected = [...selectedTasks];
        
        const leafTasks = allSelected.filter(path => {
            const taskData = docDataMap.get(path);
            if (!taskData) {
                return false; 
            }
            if (path.includes('/greatGreatGrandchildren/')) {
                return true;
            }
            if (path.includes('/greatGrandchildren/')) {
                return taskData.hasChildren !== true;
            }
            return false;
        });

        if (leafTasks.length === 0) {
            if (allSelected.length > 0) {
                 alert("Bạn đã chọn công việc, nhưng không có mục nào là công việc 'lá' (công việc chi tiết cuối cùng) có thể thực hiện. Vui lòng chỉ chọn các công việc chi tiết.");
            } else {
                alert("Vui lòng chọn ít nhất một công việc 'lá' (công việc chi tiết cuối cùng) để thực hiện.");
            }
            return;
        }

        const title = `Thực hiện công việc cho ${leafTasks.length} mục đã chọn`;
        document.getElementById('modalTitle').innerHTML = `<h2>${title}</h2>`;

        // === THAY ĐỔI HEADERS ===
        const headers = [ 
            {text: 'TT', width: '2%'}, 
            {text: 'Khu vực', width: '20%'}, // Thêm cột Khu vực
            {text: 'Mục KH', width: '4%'},    // Thêm cột Mục KH
            {text: 'Công việc thực hiện', width: '25%'},   // Cột Nội dung
            {text: 'Đ.vị tính', width: '4%'}, 
            {text: 'Số lượng', width: '5%'}, 
            {text: 'Đơn giá', width: '9%'}, 
            {text: 'Thành tiền', width: '9%'}
        ];
        // ========================

        let table = createModalTable(headers);
        
        leafTasks.forEach((path, index) => {
            const taskData = docDataMap.get(path);
            const taskTT = taskData ? convertTTForDisplay(taskData.tt) : '';
            const noiDung = taskData?.noiDung || '';
            const donVi = taskData?.donVi || '';
            const donGia = taskData?.donGia || 0;

            // === LẤY THÔNG TIN KHU VỰC ===
            let khuVuc = 'Không xác định';
            const pathParts = path.split('/');
            if (pathParts.length > 1) {
                const parentId = pathParts[1]; // ID của công việc cấp 1 (vd: 'A', 'B')
                khuVuc = parentNoiDungMap.get(parentId) || parentId; // Lấy tên từ map
            }
            // ============================

            // === THAY ĐỔI HTML HÀNG ===
            table += `<tr data-path="${path}">
                <td><input type="text" value="${index + 1}" disabled></td>
                <td><input type="text" value="${khuVuc}" disabled></td> 
                <td><input type="text" value="${taskTT}" disabled></td> 
                <td><input type="text" value="${noiDung}" disabled></td>
                <td><input type="text" value="${donVi}" disabled></td>
                <td><input type="number" value="" data-field="dvt" oninput="calculateThanhTien(this)" onfocus="this.select()"></td>
                <td><input type="number" value="${donGia}" data-field="donGia" oninput="calculateThanhTien(this)" onfocus="this.select()"></td>
                <td><input type="text" value="" data-field="thanhTien" disabled oninput="this.value=formatNumber(parseNumber(this.value))" onfocus="this.select()"></td> 
            </tr>`;
             // Lưu ý: Đã sửa lại ô Thành tiền thành disabled vì nó được tính tự động
            // ========================
        });
        
        table += '</tbody></table>';
        const dateInput = `<div style="margin-top: 15px;"><label for="executionDate">Ngày thực hiện:</label><input type="date" id="executionDate" style="margin-left: 10px; padding: 8px;"></div>`;
        document.getElementById('modalBody').innerHTML = dateInput + table;
        document.getElementById('modalSaveButton').onclick = saveMultiExecutionData;
        document.getElementById('modalSaveButton').style.display = 'block';
        document.getElementById('modalDeleteButton').style.display = 'none';
        document.getElementById('modal-footer-left').innerHTML = '';
        document.getElementById('dataModal').style.display = 'block';
    };



    window.togglePlanningColumns = function(isChecked) {
        if (isChecked) {
            if (!isAuthenticated) {
                activatePlanningModeForSelection('all');
            } else {
                activatePlanningModeForSelection('all');
            }
        } else {
            const taskList = document.getElementById('taskList');
            planningModeByYear[currentYear] = false;
            taskList.classList.remove('planning-mode');
            document.getElementById('exportExcel1Btn').disabled = false;
            document.getElementById('exportExcel2Btn').disabled = true;
            const allRows = document.querySelectorAll('#taskListBody tr');
            allRows.forEach(row => row.style.display = '');
        }
    };

    window.changeYear = function(year) {
        currentYear = parseInt(year);
        fetchData();
        updateButtonStates();
        const toggle = document.getElementById('planningModeToggle');
        toggle.checked = planningModeByYear[currentYear] || false;
        if(!toggle.checked) {
             togglePlanningColumns(false);
        }
    };

    window.closeAllModals = function() {
        document.querySelectorAll('.modal').forEach(modal => modal.style.display = 'none');
        activeCharts.forEach(chart => chart.destroy());
        activeCharts = [];
        const toggleDiv = document.getElementById('editModeToggle');
        if (toggleDiv) {
            toggleDiv.style.display = 'none';
            document.getElementById('unlockButton').style.display = 'block';
        }
    };

    window.showLinks = function(event) {
        event.stopPropagation();
        const existingDropdown = document.getElementById('links-dropdown-container');
        if (existingDropdown) existingDropdown.remove();
        
        const button = event.target;
        const links = JSON.parse(button.dataset.links);
        if (!links || links.length === 0) return;

        const dropdown = document.createElement('div');
        dropdown.id = 'links-dropdown-container';
        dropdown.className = 'links-dropdown';

        links.forEach(link => {
            const a = document.createElement('a');
            a.href = link;
            a.textContent = link.length > 50 ? link.substring(0, 50) + '...' : link;
            a.target = '_blank';
            a.title = link;
            dropdown.appendChild(a);
        });

        document.body.appendChild(dropdown);
        
        const rect = button.getBoundingClientRect();
        dropdown.style.left = `${rect.left + window.scrollX}px`;
        dropdown.style.top = `${rect.bottom + window.scrollY}px`;
    };

    /**
 * THAY THẾ HÀM importData() HIỆN TẠI BẰNG HÀM NÀY.
 *
 * Điều phối quy trình nhập Excel theo nguyên tắc "Hợp nhất thông minh" (Smart Merge):
 * 1. Đọc file Excel, lấy cả dữ liệu (jsonData) và danh sách cột (headers).
 * 2. Xây dựng gói dữ liệu "chỉ cập nhật" (buildImportUpdates_Merge).
 * 3. Hợp nhất (update) gói dữ liệu này vào CSDL mà không xóa.
 * 4. Kích hoạt quy trình tính toán & dọn dẹp (recalculateAllCostsAndReload).
 * 5. Tải lại giao diện.
 */
window.importData = function() {
    if (!isAuthenticated) return showAuthError();

    const fileInput = document.getElementById('excelFile');
    if (!fileInput.files.length) {
        statusDiv.className = 'error';
        statusDiv.innerText = "Vui lòng chọn một file Excel (.xlsx).";
        return;
    }

    // Thông báo về hành động Hợp nhất
    if (!confirm(`HÀNH ĐỘNG: HỢP NHẤT DỮ LIỆU.\n\nCác tác vụ trong file Excel sẽ được CẬP NHẬT vào CSDL.\nCác tác vụ không có trong file Excel sẽ được GIỮ NGUYÊN.\n\nCẢNH BÁO: Nếu file Excel có cột "Thực hiện" (ví dụ: 'Ngày TH (1)'), dữ liệu thực hiện CŨ của các tác vụ đó sẽ bị GHI ĐÈ.\n\nBạn có muốn tiếp tục không?`)) {
        fileInput.value = ''; // Reset file input nếu hủy
        return;
    }

    const reader = new FileReader();
    reader.onload = async (event) => {
        const importButton = document.querySelector('#dataManagementModal .btn-primary[onclick="importData()"]');
        try {
            if(importButton) importButton.disabled = true; // Vô hiệu hóa nút nhập
            statusDiv.className = 'success';
            statusDiv.innerText = "Đang đọc file Excel...";

            const workbook = XLSX.read(new Uint8Array(event.target.result), { type: 'array' });
            // Đọc sheet đầu tiên
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            // Lấy header một cách an toàn
            const headerJson = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            const headers = headerJson.length > 0 ? headerJson[0].map(String) : []; // Lấy dòng đầu tiên làm header
            // Đọc dữ liệu với header đã xác định
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: '' }); // defval: '' để ô trống là chuỗi rỗng

            statusDiv.innerText = "Đã đọc file. Đang xây dựng gói dữ liệu hợp nhất...";

            // BƯỚC 1: Xây dựng gói dữ liệu (Hàm mới v4 - "Schema-Aware")
            const updates = buildImportUpdates_Merge(jsonData, headers);

            if (Object.keys(updates).length === 0) {
                 throw new Error("Không tìm thấy dữ liệu hợp lệ trong file Excel. Vui lòng kiểm tra định dạng cột TT (tiêu đề cột TT phải là chữ hoa, các mã hiệu phải đúng tiêu chuẩn) và nội dung bảng dữ liệu.");
            }

            // BƯỚC 2: Hợp nhất (Merge) dữ liệu vào CSDL
            statusDiv.innerText = "Đang hợp nhất dữ liệu vào CSDL...";
            // KHÔNG XÓA CSDL
            await update(ref(db), updates);

            // BƯỚC 3: Kích hoạt quy trình rà soát, tính toán và dọn dẹp
            statusDiv.innerText = "Hợp nhất thành công! Đang rà soát và tính toán lại toàn bộ dữ liệu...";
            await window.recalculateAllCostsAndReload(false); // false = không hiển thị confirm()

            statusDiv.innerText = "Hoàn tất! Đang tải lại giao diện...";
            closeAllModals();
            await fetchData(); // Tải lại giao diện với dữ liệu đã được tính toán

        } catch (error) {
            console.error("Lỗi khi nhập: ", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi: ${error.message}`;
        } finally {
             if(importButton) importButton.disabled = false; // Kích hoạt lại nút nhập
             fileInput.value = ''; // Reset file input sau khi hoàn tất hoặc lỗi
        }
    };
     reader.onerror = (error) => {
         console.error("Lỗi đọc file:", error);
         statusDiv.className = 'error';
         statusDiv.innerText = 'Lỗi khi đọc file. Vui lòng thử lại.';
         fileInput.value = ''; // Reset file input
     };
    reader.readAsArrayBuffer(fileInput.files[0]);
};

    window.openDeleteAllDataModal = function() {
        if (!isAuthenticated) return showAuthError();
        document.getElementById('deleteAllDataModal').style.display = 'block';
        document.getElementById('deleteConfirmEmail').value = '';
        document.getElementById('deleteConfirmPassword').value = '';
    };

    window.confirmDeleteAllData = async function() {
        if (!isAuthenticated) return showAuthError();
        const email = document.getElementById('deleteConfirmEmail').value;
        const password = document.getElementById('deleteConfirmPassword').value;
        if (!email || !password) { alert('Vui lòng nhập đầy đủ email và mật khẩu.'); return; }
        const deleteButton = document.querySelector('#deleteAllDataModal .btn-danger');
        try {
            deleteButton.disabled = true;
            deleteButton.textContent = 'Đang xác nhận...';
            const credential = EmailAuthProvider.credential(email, password);
            await reauthenticateWithCredential(auth.currentUser, credential);
            statusDiv.className = 'success'; statusDiv.innerText = "Đã xác thực thành công. Đang tiến hành xóa...";
            
            await set(ref(db, getParentCollectionName()), null);
            
            statusDiv.innerText = "Đã xoá thành công.";
            closeAllModals();
            await fetchData();
        } catch (error) {
            console.error("Lỗi khi xoá: ", error);
            if (error.code === 'auth/invalid-credential') {
                alert('Email hoặc mật khẩu không chính xác. Thao tác xóa đã bị hủy.');
            } else {
                statusDiv.className = 'error';
                statusDiv.innerText = "Lỗi khi xoá: " + error.message;
            }
        } finally {
            deleteButton.disabled = false;
            deleteButton.textContent = 'Xác nhận xóa toàn bộ';
        }
    };

   // HÀM MỚI: Xác thực bằng tài khoản Admin cố định
  // HÀM MỚI (CẬP NHẬT): Tự động mở nếu đã là Admin, ngược lại yêu cầu mật khẩu
   window.promptForUnlock = async function() {
        const adminEmail = "admin@pvgaslpg.com.vn";
        const unlockBtn = document.getElementById('unlockButton');
        const originalText = "Mở khóa cho phép sửa đổi";
        const toggleDiv = document.getElementById('editModeToggle');
        const checkbox = document.getElementById('editModeCheckbox');

        // Lấy trạng thái thực tế từ Database để hiển thị đúng
        const isCurrentlyEnabled = editModeStatusByYear[currentYear] === true;

        // 1. KIỂM TRA ĐĂNG NHẬP HIỆN TẠI (Đi tiếp nếu đã là Admin)
        const currentUser = auth.currentUser;
        if (currentUser && currentUser.email === adminEmail) {
            // Đã là Admin -> Chỉ chuyển đổi giao diện
            statusDiv.className = 'success';
            statusDiv.innerText = "Đã nhận diện Admin.";

            unlockBtn.style.display = 'none';
            toggleDiv.style.display = 'block';
            
            // SỬA LỖI: Chỉ hiển thị trạng thái hiện tại, KHÔNG tự động bật
            checkbox.checked = isCurrentlyEnabled;
            return;
        }

        // 2. Nếu chưa phải Admin -> Hỏi mật khẩu
        const password = prompt(`Nhập mật khẩu quản trị (${adminEmail}):`);
        if (password === null) return;

        try {
            unlockBtn.disabled = true;
            unlockBtn.textContent = "Đang xác thực...";

            // Thực hiện Đăng nhập
            await signInWithEmailAndPassword(auth, adminEmail, password);

            statusDiv.className = 'success';
            statusDiv.innerText = "Xác thực thành công.";
            
            // SỬA LỖI: Chỉ chuyển đổi giao diện hiển thị
            unlockBtn.style.display = 'none';
            toggleDiv.style.display = 'block';
            
            // SỬA LỖI: Tuyệt đối không tự động update DB hay tự động check
            // Checkbox chỉ phản ánh đúng trạng thái hiện tại của hệ thống
            checkbox.checked = isCurrentlyEnabled;

        } catch (error) {
            console.error(error);
            alert("Mật khẩu không chính xác hoặc lỗi kết nối.");
            statusDiv.className = 'error';
            statusDiv.innerText = "Lỗi xác thực.";
            
            // Reset lại nút nếu lỗi
            unlockBtn.disabled = false;
            unlockBtn.textContent = originalText;
        }
    };

    window.toggleEditMode = async function(isChecked) {
        if (!isAuthenticated) {
            document.getElementById('editModeCheckbox').checked = !isChecked;
            return showAuthError();
        }
        try {
            const settingsRef = ref(db, 'settings/global');
            await update(settingsRef, { editModeStatus: { [currentYear]: isChecked } });
        } catch (error) {
            console.error("Lỗi khi cập nhật trạng thái mở khóa:", error);
            alert("Đã có lỗi xảy ra khi lưu trạng thái. Vui lòng thử lại.");
        }
    };

window.saveTasks = async function() {
        if (!isAuthenticated) return showAuthError();
        const saveButton = document.getElementById('modalSaveButton');
        try {
            saveButton.disabled = true; saveButton.textContent = 'Đang lưu...';
            const updates = {};
            const rows = document.querySelectorAll("#dataModal .modal-table tbody tr");
            const pathsToRecalculate = new Set();
            const justificationPathsToRecalculate = new Set();

            for (const row of rows) {
                const path = row.dataset.path;
                const isLeafNode = row.dataset.isLeaf === 'true'; 
                const isJustification = path.includes('/justifications/');

                row.querySelectorAll('input[data-field]').forEach(input => {
                    const field = input.dataset.field;
                    const fieldPath = `${path}/${field}`; 

                    if (field === 'chiPhi' && input.disabled) { return; }

                    if (field === 'tt') {
                        updates[fieldPath] = convertTTForStorage(input.value);
                    } 
                    else if (['chiPhi', 'khNamTruoc', 'thucHienNamTruoc', 'soLuong', 'donGia'].includes(field)) { 
                        updates[fieldPath] = parseFormattedNumber(input.value);
                    }
                    // === CẬP NHẬT: Mặc định namPhanBo = 1 ===
                    else if (field === 'namPhanBo') {
                        if (input.value.trim() === '' || input.value == 0) {
                            updates[fieldPath] = 1; // Nếu trống hoặc 0 -> lưu 1
                        } else {
                            updates[fieldPath] = parseFormattedNumber(input.value);
                        }
                    }
                    // === CẬP NHẬT: Mặc định tanSuatTH = 1 ===
                    else if (field === 'tanSuatTH') {
                        if (input.value.trim() === '') {
                            updates[fieldPath] = 1; 
                        } else {
                            const value = parseInt(input.value, 10);
                            updates[fieldPath] = isNaN(value) || value < 0 ? 0 : value;
                        }
                    } 
                    else {
                        updates[fieldPath] = input.value;
                    }
                });

                if (isJustification) {
                    const leafNodePath = path.substring(0, path.indexOf('/justifications/'));
                    justificationPathsToRecalculate.add(leafNodePath);
                    
                    const soLuongInput = row.querySelector('input[data-field="soLuong"]');
                    if (soLuongInput && !soLuongInput.disabled) {
                        const soLuong = parseFormattedNumber(soLuongInput.value);
                        const donGia = parseFormattedNumber(row.querySelector('input[data-field="donGia"]').value);
                        updates[`${path}/chiPhi`] = soLuong * donGia;
                    }
                } else {
                    pathsToRecalculate.add(path);
                    const docSnap = await get(ref(db, path));
                    if (docSnap.exists() && !docSnap.val().hasChildren) {
                        const chiPhiInput = row.querySelector('input[data-field="chiPhi"]');
                        const chiPhi = chiPhiInput ? parseFormattedNumber(chiPhiInput.value) : (docSnap.val().chiPhi || 0);
                        const chiPhiThucHien = docSnap.val().chiPhiThucHien || 0;
                        updates[`${path}/keHoachConLai`] = chiPhi - chiPhiThucHien;
                    }
                    
                    // Tính CP Phân Bổ (Chỉ cho nút lá)
                    if (isLeafNode) {
                        const namPbInput = row.querySelector('input[data-field="namPhanBo"]');
                        let finalChiPhi = updates[`${path}/chiPhi`] !== undefined ? updates[`${path}/chiPhi`] : parseFormattedNumber(row.querySelector('input[data-field="chiPhi"]').value);
                        
                        if (namPbInput) {
                            // Lấy giá trị vừa xử lý logic mặc định ở trên
                            let nam = updates[`${path}/namPhanBo`];
                            if (nam === undefined) { // Trường hợp không thay đổi input nhưng cần lấy giá trị
                                if (namPbInput.value.trim() === '' || namPbInput.value == 0) nam = 1;
                                else nam = parseFormattedNumber(namPbInput.value);
                            }
                            
                            const cpPb = (nam > 0) ? Math.round(finalChiPhi / nam) : 0;
                            updates[`${path}/chiPhiPhanBo`] = cpPb;
                        }
                    }
                }
            }

            if (Object.keys(updates).length > 0) {
                await update(ref(db), updates);
            }
            
            if (justificationPathsToRecalculate.size > 0) {
                 await recalculateCostsAfterJustificationChange(Array.from(justificationPathsToRecalculate));
            }
            
            if (pathsToRecalculate.size > 0) {
                await recalculateCostsForParents(Array.from(pathsToRecalculate));
            }

            await calculateSummaryData();
            closeAllModals();
            await fetchData();
            statusDiv.className = 'success';
            statusDiv.innerText = `Đã cập nhật ${rows.length} công việc.`;
        } catch (error) {
            console.error("Lỗi khi lưu:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi khi lưu: ${error.message}`;
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = 'Lưu thay đổi';
        }
    };

// === CẬP NHẬT: HÀM saveNewTasks (Xử lý Lưu nhiều dòng từ Modal Thêm mới) ===
   window.saveNewTasks = async function(parentPath, level) {
        if (!isAuthenticated) return showAuthError();
        const saveButton = document.getElementById('modalSaveButton');
        try {
            saveButton.disabled = true; saveButton.textContent = 'Đang lưu...';
            
            const updates = {};
            const parentUpdates = {}; 
            const rows = document.querySelectorAll("#dataModal .modal-table tbody tr");
            
            if (rows.length === 0) {
                 throw new Error("Không có dòng nào để lưu.");
            }

            const pathsToRecalculate = new Set();
            const justificationPathsToRecalculate = new Set();

            let subCollectionName;
            if (level === 'child') subCollectionName = 'children';
            else if (level === 'grandchild') subCollectionName = 'grandchildren';
            else if (level === 'greatGrandchild') subCollectionName = 'greatGrandchildren';
            else if (level === 'greatGreatGrandchild') subCollectionName = 'greatGreatGrandchildren';
            else if (level === 'justification') subCollectionName = 'justifications';
            else if (level === 'subJustification') subCollectionName = 'subJustifications';
            else {
                console.error("Level không hợp lệ:", level);
                return;
            }

            const parentRef = ref(db, parentPath);
            const parentSnap = await get(parentRef);
            const parentData = parentSnap.exists() ? parentSnap.val() : {};

            for (const row of rows) {
                const newData = {};
                const ttInput = row.querySelector('input[data-field="tt"]');
                if (!ttInput) continue;
                
                const newTT = convertTTForStorage(ttInput.value);

                row.querySelectorAll('input[data-field]').forEach(input => {
                    const field = input.dataset.field;
                    if (field === 'tt') return; 

                    if (level === 'justification' || level === 'subJustification') {
                        if (['noiDung', 'donVi'].includes(field)) {
                            newData[field] = input.value;
                        } else if (['soLuong', 'donGia'].includes(field)) {
                            newData[field] = parseFormattedNumber(input.value);
                        }
                    } else {
                        // Logic Tần suất
                        if (field === 'tanSuatTH') {
                            if (input.value.trim() === '') {
                                newData[field] = 1; 
                            } else {
                                const value = parseInt(input.value, 10);
                                newData[field] = isNaN(value) || value < 0 ? 0 : value;
                            }
                        } 
                        // === CẬP NHẬT: Mặc định namPhanBo = 1 ===
                        else if (field === 'namPhanBo') {
                             if (input.value.trim() === '' || input.value == 0) newData[field] = 1;
                             else newData[field] = parseFormattedNumber(input.value);
                        }
                        // =========================================
                        else if (['chiPhi', 'khNamTruoc', 'thucHienNamTruoc'].includes(field)) {
                            newData[field] = parseFormattedNumber(input.value);
                        } else {
                            newData[field] = input.value;
                        }
                    }
                });

                newData.tt = newTT; 
                const newDocPath = `${parentPath}/${subCollectionName}/${newTT}`;

               if (level === 'justification' || level === 'subJustification') {
                    const soLuong = newData.soLuong || 0;
                    const donGia = newData.donGia || 0;
                    newData.chiPhi = soLuong * donGia;

                    let leafNodePath = parentPath;
                    if (level === 'subJustification') {
                        leafNodePath = parentPath.substring(0, parentPath.indexOf('/justifications/'));
                    }
                    justificationPathsToRecalculate.add(leafNodePath);
                    pathsToRecalculate.add(leafNodePath); 

                } else {
                    newData.isHidden = false;
                    newData.chiPhi = newData.chiPhi || 0;
                    newData.chiPhiThucHien = 0;
                    newData.keHoachConLai = newData.chiPhi;
                    newData.khNamTruoc = newData.khNamTruoc || 0;
                    newData.thucHienNamTruoc = newData.thucHienNamTruoc || 0;
                    newData.tgBatDau = newData.tgBatDau || '';
                    newData.tgHoanThanh = newData.tgHoanThanh || '';
                    
                    // Tính CP Phân Bổ (với namPhanBo đã được gán default 1 ở trên)
                    if (['greatGrandchild', 'greatGreatGrandchild'].includes(level)) {
                        const nam = newData.namPhanBo || 1; // Đảm bảo không chia 0
                        newData.chiPhiPhanBo = Math.round(newData.chiPhi / nam);
                    } else {
                        newData.chiPhiPhanBo = 0; 
                    }

                    pathsToRecalculate.add(newDocPath);
                }

                if (!newData.noiDung) {
                    alert(`Nội dung cho mục ${convertTTForDisplay(newTT)} không được để trống!`);
                    throw new Error("Validation failed");
                }

                updates[newDocPath] = newData;

                if (level === 'subJustification' && !parentUpdates[`${parentPath}/hasSubJustifications`]) {
                    parentUpdates[`${parentPath}/hasSubJustifications`] = true;
                    parentUpdates[`${parentPath}/soLuong`] = '';
                    parentUpdates[`${parentPath}/donGia`] = '';
                }

                if (level === 'greatGreatGrandchild' && !parentUpdates[`${parentPath}/hasChildren`]) {
                    if (parentData && !parentData.hasChildren) {
                        const execSnapshot = await get(ref(db, `${parentPath}/executions`));
                        const justSnapshot = await get(ref(db, `${parentPath}/justifications`));
                        if ((execSnapshot.exists() && Object.keys(execSnapshot.val()).length > 0) || 
                            (justSnapshot.exists() && Object.keys(justSnapshot.val()).length > 0)) {
                            alert(`Lỗi: Không thể thêm công việc con vào mục ${parentData.tt} vì nó đã được thực hiện hoặc đã có giải trình.`);
                            throw new Error("Cannot add child to executed/justified item");
                        }
                        parentUpdates[`${parentPath}/hasChildren`] = true;
                        parentUpdates[`${parentPath}/chiPhi`] = 0;
                        parentUpdates[`${parentPath}/chiPhiThucHien`] = 0;
                        parentUpdates[`${parentPath}/keHoachConLai`] = 0;
                        parentUpdates[`${parentPath}/soLuong`] = '';
                        parentUpdates[`${parentPath}/donVi`] = '';
                        parentUpdates[`${parentPath}/namPhanBo`] = '';
                        parentUpdates[`${parentPath}/chiPhiPhanBo`] = 0;
                    } else {
                        parentUpdates[`${parentPath}/hasChildren`] = true;
                    }
                }
            } 

            Object.assign(updates, parentUpdates);
            await update(ref(db), updates);

            if (justificationPathsToRecalculate.size > 0) {
                await recalculateCostsAfterJustificationChange(Array.from(justificationPathsToRecalculate));
            }
            if (pathsToRecalculate.size > 0) {
                await recalculateCostsForParents(Array.from(pathsToRecalculate));
            }
            
            closeAllModals();
            await fetchData();
            statusDiv.className = 'success';
            statusDiv.innerText = `Đã thêm thành công ${rows.length} mục mới.`;

        } catch (error) {
            console.error("Lỗi khi lưu nhiều mục mới:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi khi lưu: ${error.message}`;
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = 'Lưu thay đổi';
        }
    };



    window.saveMultiExecutionData = async function() {
    if (!isAuthenticated) return showAuthError();
    const saveButton = document.getElementById('modalSaveButton');
    try {
        saveButton.disabled = true; saveButton.textContent = 'Đang lưu...';
        const updates = {};
        const rows = document.querySelectorAll("#dataModal .modal-table tbody tr");
        const ngayThucHien = document.getElementById('executionDate').value;
        if (!ngayThucHien) throw new Error("Vui lòng chọn ngày thực hiện.");
        statusDiv.className = 'success'; statusDiv.innerText = "Đang lưu dữ liệu thực hiện...";
        const commonTimestamp = Date.now();
        const pathsToRecalculate = [];
        const childPathsToUpdate = new Set();

        for (const row of rows) {
            const leafNodePath = row.dataset.path;
            const leafNodeDocSnap = await get(ref(db, leafNodePath));
            if (!leafNodeDocSnap.exists()) continue;

            const pathParts = leafNodePath.split('/');
            const childPath = pathParts.slice(0, 4).join('/');
            childPathsToUpdate.add(childPath);

            const leafNodeData = leafNodeDocSnap.val();
            const initialChiPhi = leafNodeData.chiPhi || 0;
            const soLuong = parseNumber(row.querySelector('input[data-field="dvt"]').value);
            const thanhTien = parseFormattedNumber(row.querySelector('input[data-field="thanhTien"]').value);

            if (soLuong <= 0) continue; // Chỉ bỏ qua nếu không nhập số lượng

            pathsToRecalculate.push(leafNodePath);
            const executionCollectionRef = ref(db, `${leafNodePath}/executions`);
            const executionSnapshot = await get(executionCollectionRef);
            let lanThucHien = 1;
            if (executionSnapshot.exists()) {
                lanThucHien = Object.keys(executionSnapshot.val()).length + 1;
            }
            const newExecutionData = {
                dvt: soLuong,
                donGia: parseNumber(row.querySelector('input[data-field="donGia"]').value),
                thanhTien: thanhTien,
                lanThucHien: lanThucHien,
                ngayThucHien: ngayThucHien,
                timestamp: commonTimestamp
             };
            updates[`${leafNodePath}/executions/${lanThucHien}`] = newExecutionData;

            const currentThucHien = leafNodeData.chiPhiThucHien || 0;
            const newThucHien = currentThucHien + thanhTien;
            updates[`${leafNodePath}/chiPhiThucHien`] = newThucHien;
            updates[`${leafNodePath}/keHoachConLai`] = leafNodeData.chiPhi - newThucHien;
        }

        childPathsToUpdate.forEach(path => {
            updates[`${path}/daThucHien`] = true; // Đánh dấu nút cấp 2 là đã thực hiện
        });

        await update(ref(db), updates); // Ghi dữ liệu thực hiện và cập nhật chi phí lá, cờ daThucHien

        // Tính toán lại chi phí lan truyền lên các cấp cha
        await recalculateCostsForParents(pathsToRecalculate);

        // Kiểm tra lại trạng thái daThucHien cho các nút cấp 2 (đảm bảo đúng nếu có xóa execution trước đó)
        for (const childPath of childPathsToUpdate) {
            await checkAndUpdateDaThucHien(childPath);
        }

        // --- TÍNH TOÁN LẠI SUMMARY DATA NGAY LẬP TỨC ---
        await calculateSummaryData();
        // --- KẾT THÚC THÊM ---

        closeAllModals();
        await fetchData(); // Tải lại giao diện với dữ liệu mới nhất (bao gồm cả summary)
        statusDiv.innerText = `Đã lưu các mục thực hiện thành công.`;

    } catch (error) {
        console.error("Lỗi khi lưu thực hiện:", error);
        statusDiv.className = 'error'; statusDiv.innerText = `Lỗi khi lưu: ${error.message}`;
    } finally {
        saveButton.disabled = false; saveButton.textContent = 'Lưu thay đổi';
    }
};

    // === BẮT ĐẦU ĐOẠN MÃ THAY THẾ ===
window.saveExecutionEdits = async function() {
    if (!isAuthenticated) return showAuthError();
    const saveButton = document.getElementById('modalSaveButton');
    try {
        saveButton.disabled = true;
        saveButton.textContent = 'Đang lưu...';
        const updates = {};
        const rows = document.querySelectorAll("#dataModal .modal-table tbody tr");
        const pathsToRecalculate = new Set();
        const childPathsToUpdate = new Set();

        for (const row of rows) {
            const execPath = row.dataset.execPath;
            const parentLeafNodePath = execPath.substring(0, execPath.lastIndexOf('/executions/'));
            const childPath = parentLeafNodePath.split('/').slice(0, 4).join('/');
            pathsToRecalculate.add(parentLeafNodePath);
            childPathsToUpdate.add(childPath);

            // SỬA LỖI: Cập nhật từng trường bằng đường dẫn đầy đủ để merge, không ghi đè
            updates[`${execPath}/dvt`] = parseNumber(row.querySelector('input[data-field="dvt"]').value);
            updates[`${execPath}/donGia`] = parseNumber(row.querySelector('input[data-field="donGia"]').value);
            updates[`${execPath}/thanhTien`] = parseFormattedNumber(row.querySelector('input[data-field="thanhTien"]').value);
        }

        // Đoạn code còn lại không cần thay đổi
        childPathsToUpdate.forEach(path => {
            updates[`${path}/daThucHien`] = true;
        });

        await update(ref(db), updates);

        const recalcPromises = Array.from(pathsToRecalculate).map(path => recalculateExecutionCost(path));
        await Promise.all(recalcPromises);

        for (const childPath of childPathsToUpdate) {
            await checkAndUpdateDaThucHien(childPath);
        }

        await recalculateCostsForParents(Array.from(pathsToRecalculate));

        closeAllModals();
        await fetchData(); // Tải lại dữ liệu để cập nhật giao diện
        statusDiv.className = 'success';
        statusDiv.innerText = "Đã cập nhật thành công lần thực hiện.";

    } catch (error) {
        console.error("Lỗi khi sửa thực hiện:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi khi sửa: ${error.message}`;
    } finally {
        saveButton.disabled = false;
        saveButton.textContent = 'Lưu thay đổi';
    }
};


    window.handleEditClick = async function(docPath, level) {
        if (!isAuthenticated) return showAuthError();
        const allSelected = [...selectedTasks, ...selectedJustifications];
        const isMultiSelect = allSelected.some(p => p === docPath) && allSelected.length > 1;

        let pathsToEdit = isMultiSelect ? allSelected.sort() : [docPath];
        let title = isMultiSelect ? `Sửa ${pathsToEdit.length} mục đã chọn` : 'Sửa thông tin';
        document.getElementById('modalTitle').innerHTML = `<h2>${title}</h2>`;

        const isJustification = level === 'justification' || (pathsToEdit[0] && pathsToEdit[0].includes('justifications'));

        // === CẬP NHẬT HEADERS ĐẦY ĐỦ (ĐỒNG BỘ VỚI OPENADDMODAL) ===
        const headers = isJustification
            ? [ 
                {text: 'TT', width: '5%'}, 
                'Nội dung', 
                {text: 'Đ.vị tính', width: '10%'}, 
                {text: 'Số lượng', width: '10%'}, 
                {text: 'Đơn giá', width: '15%'}, 
                {text: 'Chi phí', width: '15%'}
            ]
            : [ 
                {text: 'TT', width: '4%'}, 
                {text: 'Nội dung', width: '20%'}, 
                {text: 'ĐV th.hiện', width: '5%'}, 
                {text: 'KH năm trước', width: '6%'}, 
                {text: 'Thực hiện năm trước', width: '6%'}, 
                {text: 'Đ.vị tính', width: '4%'}, 
                {text: 'Số lượng', width: '5%'}, 
                {text: 'Tần suất', width: '3%'}, 
                {text: 'Chi phí', width: '7%'}, 
                
                // --- 2 CỘT MỚI ---
                {text: 'Năm PB', width: '3%'},     
                {text: 'CP phân bổ', width: '3%'}, 
                // -----------------

                {text: 'Cấp độ', width: '3%'}, 
                {text: 'TG bắt đầu', width: '5%'}, 
                {text: 'TG hoàn thành', width: '5%'}, 
                {text: 'Ghi chú', width: '15%'} 
            ];
        // ==========================================================

        let table = createModalTable(headers);
        for (const path of pathsToEdit) {
            const currentIsJustification = path.includes('justifications');
            if (isMultiSelect && currentIsJustification !== isJustification) {
                continue;
            }
            const docSnap = await get(ref(db, path));
            if (!docSnap.exists()) continue;
            const data = docSnap.val();
            const pathLevel = currentIsJustification ? 'justification' : level;
            let context = {};
            if (pathLevel === 'greatGrandchild' && !data.hasChildren) {
                const justSnapshot = await get(ref(db, `${path}/justifications`));
                context.hasJustifications = justSnapshot.exists() && Object.keys(justSnapshot.val()).length > 0;
            }
            table += createInputRow(path, data, pathLevel, context);
        }
        table += '</tbody></table>';

        document.getElementById('modalBody').innerHTML = table;
        document.getElementById('modalSaveButton').onclick = saveTasks;
        document.getElementById('modalSaveButton').style.display = 'block';
        document.getElementById('modalDeleteButton').style.display = 'none';
        document.getElementById('modal-footer-left').innerHTML = '';
        document.getElementById('dataModal').style.display = 'block';
    };

// === BẮT ĐẦU: HÀM MỚI ĐỂ THÊM DÒNG VÀO MODAL ===
    window.addNewRowToModal = function(parentPath, level) {
        const modalTableBody = document.querySelector("#dataModal .modal-table tbody");
        if (!modalTableBody || !modalTableBody.lastElementChild) {
            console.error("Không tìm thấy bảng modal hoặc dòng cuối cùng.");
            return;
        }

        const lastRow = modalTableBody.lastElementChild;
        const lastTTInput = lastRow.querySelector('input[data-field="tt"]');
        if (!lastTTInput) {
             console.error("Không tìm thấy trường TT ở dòng cuối.");
             return;
        }

        try {
            const lastDisplayTT = lastTTInput.value;
            const nextDisplayTT = incrementTT(lastDisplayTT); // Sử dụng helper
            const nextStorageTT = convertTTForStorage(nextDisplayTT); // Chuyển về dạng '1,1'

            const newData = { tt: nextStorageTT };
            
            // Sử dụng một path giả lập, vì createInputRow yêu cầu nó.
            // Hàm saveNewTasks sẽ bỏ qua path này và tự xây dựng path thật.
            const dummyPath = `new_item_${Date.now()}`; 
            
            // Gọi createInputRow để tạo HTML cho dòng mới
            const rowHtml = createInputRow(dummyPath, newData, level);

            // Chuyển chuỗi HTML thành một DOM element
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = `<table><tbody>${rowHtml}</tbody></table>`;
            const newTr = tempDiv.querySelector('tr');

            if (newTr) {
                // Thêm dòng mới vào bảng
                modalTableBody.appendChild(newTr);
                // Tự động focus vào ô nội dung của dòng mới
                newTr.querySelector('input[data-field="noiDung"]').focus();
            }
        } catch (e) {
            console.error("Lỗi khi thêm dòng mới vào modal:", e);
        }
    }
    // === KẾT THÚC: HÀM MỚI ĐỂ THÊM DÒNG VÀO MODAL ===

  
   window.openAddModal = async function(parentPath, level) {
        if (!isAuthenticated) return showAuthError();

if (level === 'greatGreatGrandchild') {
            await openCombinedAddModal(parentPath);
            return;
        }
        // Logic title giữ nguyên
        let title;
        if (level === 'justification') {
            title = 'Thêm giải trình';
        } else if (level === 'subJustification') {
            title = 'Thêm giải trình con';
        } else if (level === 'child') {
            title = 'Thêm lĩnh vực ATCLMT';
        } else if (level === 'grandchild') {
            title = 'Thêm đầu mục công việc';
        } else if (level === 'greatGrandchild') {
            title = 'Thêm đầu công việc';
        } else if (level === 'greatGreatGrandchild') {
            title = 'Thêm công việc chi tiết';
        } else {
            title = `Thêm mục mới (Cấp: ${level})`;
        }
        document.getElementById('modalTitle').innerHTML = `<h2>${title}</h2>`;

        // === CẬP NHẬT HEADERS ĐẦY ĐỦ (BAO GỒM 2 CỘT MỚI & ĐỘ RỘNG) ===
        const isJustificationLevel = (level === 'justification' || level === 'subJustification');
        const headers = isJustificationLevel
            ? [ 
                {text: 'TT', width: '5%'}, 
                'Nội dung', 
                {text: 'Đ.vị tính', width: '10%'}, 
                {text: 'Số lượng', width: '10%'}, 
                {text: 'Đơn giá', width: '15%'}, 
                {text: 'Chi phí', width: '15%'}
            ]
            : [ 
                {text: 'TT', width: '4%'}, 
                {text: 'Nội dung', width: '20%'}, 
                {text: 'ĐV th.hiện', width: '5%'}, 
                {text: 'KH năm trước', width: '6%'}, 
                {text: 'Thực hiện năm trước', width: '6%'}, 
                {text: 'Đ.vị tính', width: '4%'}, 
                {text: 'Số lượng', width: '5%'}, 
                {text: 'Tần suất', width: '3%'}, 
                {text: 'Chi phí', width: '7%'}, 
                
                // --- 2 CỘT MỚI ---
                {text: 'Năm PB', width: '3%'},     
                {text: 'CP phân bổ', width: '3%'}, 
                // -----------------

                {text: 'Cấp độ', width: '3%'}, 
                {text: 'TG bắt đầu', width: '5%'}, 
                {text: 'TG hoàn thành', width: '5%'}, 
                {text: 'Ghi chú', width: '15%'} 
            ];
        // ==============================================================

        let table = createModalTable(headers);
        
        // Tạo TT đầu tiên
        const newTT = await generateNextTT(parentPath, level);
        const convertedNewTT = convertTTForStorage(newTT);

        const newData = { tt: convertedNewTT };
        
        // Sử dụng một path giả lập cho createInputRow
        const dummyPath = `new_item_${Date.now()}`;
        table += createInputRow(dummyPath, newData, level);
        table += '</tbody></table>';

        document.getElementById('modalBody').innerHTML = table;

        // Gán hàm LƯU MỚI
        document.getElementById('modalSaveButton').onclick = () => saveNewTasks(parentPath, level);
        
        // Thêm nút "+"
        document.getElementById('modal-footer-left').innerHTML = `
            <button class="btn-info" onclick="addNewRowToModal('${parentPath}', '${level}')" title="Thêm dòng mới">+ Thêm dòng</button>
        `;

        document.getElementById('modalSaveButton').style.display = 'block';
        document.getElementById('modalDeleteButton').style.display = 'none';
        document.getElementById('dataModal').style.display = 'block';
        
        // Tự động focus vào ô nội dung
        document.querySelector("#dataModal .modal-table tbody tr input[data-field='noiDung']").focus();
    };
	
		
	// === HÀM MỚI: Mở Modal kết hợp Thêm Task Cấp 5 + Thực hiện ===
   // === HÀM ĐÃ SỬA LỖI (Fix numChildren -> size): Kiểm tra Executions tồn tại ===
    window.openCombinedAddModal = async function(parentPath) {
        if (!isAuthenticated) return showAuthError();

        // 1. KIỂM TRA LOGIC: Task cha có đang chứa thực hiện không?
        try {
            const parentExecRef = ref(db, `${parentPath}/executions`);
            const parentExecSnap = await get(parentExecRef);

            // === SỬA LỖI TẠI ĐÂY: Thay .numChildren() bằng .size ===
            // Trong Firebase v9, DataSnapshot dùng thuộc tính .size để đếm số lượng con
            if (parentExecSnap.exists() && parentExecSnap.size > 0) {
                alert("Đây là công việc đã có thực hiện một phần hoặc toàn bộ, không thể thêm các chi tiết. Muốn thêm chi tiết, phải xoá thực hiện công việc cũ.");
                return; // Dừng lại, không mở modal
            }
        } catch (error) {
            console.error("Lỗi kiểm tra trạng thái công việc:", error);
            alert("Lỗi kết nối khi kiểm tra dữ liệu: " + error.message);
            return;
        }

        // 2. NẾU HỢP LỆ: Tiến hành mở Modal như bình thường
        const modal = document.getElementById('dataModal');
        const title = 'Thêm công việc chi tiết & Thực hiện ngay';
        document.getElementById('modalTitle').innerHTML = `<h2>${title}</h2>`;

        const headers = [
            {text: 'TT', width: '5%'},
            {text: 'Nội dung công việc', width: '30%'},
            {text: 'Đơn vị', width: '10%'}, 
            {text: 'Số lượng', width: '10%'}, 
            {text: 'Đơn giá', width: '15%'}, 
            {text: 'Thành tiền', width: '15%'} 
        ];

        let table = createModalTable(headers);
        
        // Tạo TT mới
        const newTT = await generateNextTT(parentPath, 'greatGreatGrandchild');
        const convertedNewTT = convertTTForStorage(newTT);
        const dummyPath = `new_combined_${Date.now()}`;
        
        // Tạo dòng input đầu tiên
        table += createCombinedInputRow(dummyPath, convertedNewTT);
        table += '</tbody></table>';

        // Ô chọn ngày (để trống theo yêu cầu)
        const dateInputHtml = `
            <div style="margin-bottom: 15px; background: #fff3cd; padding: 10px; border-radius: 5px; border: 1px solid #ffeeba;">
                <label for="combinedExecutionDate" style="font-weight: bold; color: #856404;">Ngày thực hiện chung (*):</label>
                <input type="date" id="combinedExecutionDate" style="margin-left: 10px; padding: 5px; border: 1px solid #ccc; border-radius: 4px;">
                <span style="font-size: 0.9em; font-style: italic; margin-left: 10px;">(Bắt buộc chọn)</span>
            </div>
        `;

        document.getElementById('modalBody').innerHTML = dateInputHtml + table;
        
        // Gán sự kiện lưu
        document.getElementById('modalSaveButton').onclick = () => saveCombinedTasks(parentPath);
        
        // Nút thêm dòng
        document.getElementById('modal-footer-left').innerHTML = `
            <button class="btn-info" onclick="addCombinedRow('${parentPath}')" title="Thêm dòng mới">+ Thêm dòng</button>
        `;

        // Hiển thị Modal
        document.getElementById('modalSaveButton').style.display = 'block';
        document.getElementById('modalDeleteButton').style.display = 'none';
        modal.style.display = 'block';

        // Focus vào ô đầu tiên
        setTimeout(() => {
            const firstInput = document.querySelector("#dataModal .modal-table tbody tr input[data-field='noiDung']");
            if(firstInput) firstInput.focus();
        }, 100);
    };

    // === HÀM MỚI: Tạo HTML cho 1 dòng trong Modal kết hợp ===
    window.createCombinedInputRow = function(path, ttValue) {
        return `<tr data-path="${path}" class="combined-row">
            <td><input type="text" value="${convertTTForDisplay(ttValue)}" data-field="tt" disabled></td>
            
            <td><input type="text" placeholder="Nội dung..." data-field="noiDung"></td>
            <td><input type="text" placeholder="ĐVT..." data-field="donVi"></td>
            
            <td><input type="number" placeholder="SL..." data-field="dvt" oninput="calculateCombinedThanhTien(this)" onfocus="this.select()"></td>
            <td><input type="number" placeholder="Đơn giá..." data-field="donGia" oninput="calculateCombinedThanhTien(this)" onfocus="this.select()"></td>
            <td><input type="text" value="0" data-field="thanhTien" disabled></td>
        </tr>`;
    };

    // === HÀM MỚI: Thêm dòng mới vào Modal kết hợp ===
    window.addCombinedRow = function(parentPath) {
        const tbody = document.querySelector("#dataModal .modal-table tbody");
        const lastRow = tbody.lastElementChild;
        const lastTTInput = lastRow.querySelector('input[data-field="tt"]');
        
        let nextTT = '1';
        if (lastTTInput) {
            nextTT = incrementTT(lastTTInput.value);
        }
        
        const dummyPath = `new_combined_${Date.now()}`;
        const rowHtml = createCombinedInputRow(dummyPath, convertTTForStorage(nextTT));
        
        // Chèn HTML vào cuối bảng
        const temp = document.createElement('tbody');
        temp.innerHTML = rowHtml;
        const newRow = temp.firstElementChild;
        tbody.appendChild(newRow);
        
        newRow.querySelector('input[data-field="noiDung"]').focus();
    };

    // === HÀM MỚI: Tính thành tiền tự động trong Modal kết hợp ===
    window.calculateCombinedThanhTien = function(input) {
        const row = input.closest('tr');
        const slThucHien = parseNumber(row.querySelector('input[data-field="dvt"]').value);
        const donGia = parseNumber(row.querySelector('input[data-field="donGia"]').value);
        const thanhTienInput = row.querySelector('input[data-field="thanhTien"]');
        
        const total = slThucHien * donGia;
        thanhTienInput.value = formatNumber(total);
    };

    // === HÀM MỚI: Lưu dữ liệu kết hợp (Logic cốt lõi) ===
  window.saveCombinedTasks = async function(parentPath) {
        if (!isAuthenticated) return showAuthError();
        
        const saveButton = document.getElementById('modalSaveButton');
        const dateInput = document.getElementById('combinedExecutionDate');
        const ngayThucHien = dateInput.value;

        if (!ngayThucHien) {
            alert("Vui lòng nhập Ngày thực hiện.");
            return;
        }

        try {
            saveButton.disabled = true; 
            saveButton.textContent = 'Đang lưu...';
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đang xử lý lưu kết hợp...';

            const updates = {};
            const rows = document.querySelectorAll("#dataModal .modal-table tbody tr");
            const pathsToRecalculate = new Set();
            const timestamp = Date.now(); 

            updates[`${parentPath}/hasChildren`] = true;
            const parentCleanUp = getCleanupFieldsForParentNode(parentPath);
            Object.assign(updates, parentCleanUp);
            
            updates[`${parentPath}/chiPhi`] = 0;
            updates[`${parentPath}/chiPhiThucHien`] = 0;
            updates[`${parentPath}/keHoachConLai`] = 0;

            for (const row of rows) {
                const tt = convertTTForStorage(row.querySelector('input[data-field="tt"]').value);
                const noiDung = row.querySelector('input[data-field="noiDung"]').value.trim();
                const donVi = row.querySelector('input[data-field="donVi"]').value.trim();
                
                // Lấy SL thực hiện
                const slThucHien = parseFormattedNumber(row.querySelector('input[data-field="dvt"]').value); 
                // === THAY ĐỔI: Gán SL Kế hoạch = SL Thực hiện ===
                const soLuongPlan = slThucHien; 
                
                const donGia = parseFormattedNumber(row.querySelector('input[data-field="donGia"]').value);
                const thanhTien = slThucHien * donGia;

                if (!noiDung) continue; 

                const newTaskPath = `${parentPath}/greatGreatGrandchildren/${tt}`;
                const chiPhiPlan = soLuongPlan * donGia; 

                const taskData = {
                    tt: tt,
                    noiDung: noiDung,
                    donVi: donVi,
                    soLuong: soLuongPlan, // Lưu giá trị bằng dvt
                    donGia: donGia,
                    chiPhi: chiPhiPlan,
                    chiPhiThucHien: thanhTien,
                    keHoachConLai: 0, // Vì Plan = Actual nên còn lại = 0
                    daThucHien: true,
                    khNamTruoc: 0,
                    thucHienNamTruoc: 0,
                    tanSuatTH: 1,
                    namPhanBo: 1,
                    chiPhiPhanBo: 0,
                    capDo: '',
                    tgBatDau: '',
                    tgHoanThanh: '',
                    ghiChu: '',
                    isHidden: false
                };

                if (slThucHien > 0 || thanhTien > 0) {
                    const executionData = {
                        ngayThucHien: ngayThucHien,
                        dvt: slThucHien,
                        donGia: donGia,
                        thanhTien: thanhTien,
                        lanThucHien: 1,
                        timestamp: timestamp
                    };
                    taskData.executions = { '1': executionData };
                }

                updates[newTaskPath] = taskData;
                pathsToRecalculate.add(newTaskPath);
            }

            await update(ref(db), updates);

            if (pathsToRecalculate.size > 0) {
                statusDiv.innerText = 'Đang tính toán lại chi phí cấp cha...';
                await recalculateCostsForParents(Array.from(pathsToRecalculate));
            }

            await calculateSummaryData();
            closeAllModals();
            await fetchData();
            
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đã thêm công việc và ghi nhận thực hiện thành công!';

        } catch (error) {
            console.error("Lỗi lưu kết hợp:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi: ${error.message}`;
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = 'Lưu thay đổi';
        }
    };
	
	
 
// === KẾT THÚC hàm cho nút sửa ===

    window.uploadPdfForExecution = function(timestampKey) {
        document.getElementById('uploadPdfModalTitle').textContent = 'Tải lên Hồ sơ PDF';
        document.getElementById('uploadPdfButton').onclick = () => performPdfUpload(timestampKey);
        document.getElementById('pdf_file_input').value = '';
        document.getElementById('uploadPdfModal').style.display = 'block';
    };

    /**
     * Hàm xử lý Checkbox "Chọn tất cả" ở header bảng
     */
    window.toggleAllCheckboxes = function(headerCheckbox) {
        const isChecked = headerCheckbox.checked;
        const allCheckboxes = document.querySelectorAll('#taskListBody input[type="checkbox"]');
        
        // 1. Reset dữ liệu đã chọn để nạp lại từ đầu (tránh trùng lặp hoặc sót)
        if (!isChecked) {
            selectedTasks.clear();
            selectedJustifications.clear();
        }

        allCheckboxes.forEach(cb => {
            // Cập nhật trạng thái hiển thị
            cb.checked = isChecked;
            cb.indeterminate = false; // Quan trọng: Xóa trạng thái "bán phần" nếu có

            // Cập nhật dữ liệu vào Set
            const path = cb.dataset.path;
            if (isChecked) {
                if (cb.classList.contains('justification-checkbox')) {
                    selectedJustifications.add(path);
                } else {
                    selectedTasks.add(path);
                }
            }
        });

        updateButtonStates();
    };

    /**
     * Hàm Wrapper: Đảm bảo tính tương thích với HTML cũ
     * (Vì trong HTML có chỗ gọi toggleChildrenCheckboxes, có chỗ gọi toggleSelection)
     */
    window.toggleChildrenCheckboxes = function(parentCheckbox) {
        // Chuyển tiếp sang logic mới ở toggleSelection
        window.toggleSelection(parentCheckbox);
    };

    
   /**
     * Hàm xử lý chính: Chọn/Bỏ chọn task 
     * Hỗ trợ lan truyền xuống (Down) và cập nhật ngược lên (Up)
     */
    window.toggleSelection = function(checkbox, isFromCascade = false) {
        const path = checkbox.dataset.path;
        const isChecked = checkbox.checked;
        const isJustification = checkbox.classList.contains('justification-checkbox');

        // 1. Cập nhật vào danh sách đã chọn (Set)
        if (isChecked) {
            if (isJustification) selectedJustifications.add(path);
            else selectedTasks.add(path);
        } else {
            if (isJustification) selectedJustifications.delete(path);
            else selectedTasks.delete(path);
        }

        // 2. LAN TRUYỀN XUỐNG (Cascade Down): Chọn tất cả con cháu
        // Chỉ chạy khi người dùng click trực tiếp (isFromCascade = false)
        if (!isFromCascade) {
            const descendantCheckboxes = document.querySelectorAll(`input[type="checkbox"][data-path^="${path}/"]`);
            descendantCheckboxes.forEach(childCb => {
                if (childCb !== checkbox) {
                    childCb.checked = isChecked;
                    childCb.indeterminate = false; // Con cháu thì phải rõ ràng (Chọn/Không)
                    window.toggleSelection(childCb, true); // Gọi đệ quy nhẹ để cập nhật Set
                }
            });
        }

        // 3. CẬP NHẬT NGƯỢC LÊN (Bubble Up): Kiểm tra trạng thái cha/ông
        // Luôn chạy để đảm bảo tính nhất quán visual
        updateAncestors(path);

        // 4. Cập nhật nút bấm
        if (!isFromCascade) {
            updateButtonStates();
        }
    };

    /**
     * Hàm đệ quy cập nhật trạng thái visual của các cấp cha (Indeterminate)
     */
    function updateAncestors(currentPath) {
        // Tìm đường dẫn cha bằng cách cắt bỏ 2 phần cuối (VD: .../children/ID)
        // Regex: Tìm pattern "/[collection]/[id]" ở cuối chuỗi và loại bỏ nó
        const parentPathMatch = currentPath.match(/^(.*)\/[^\/]+\/[^\/]+$/);
        
        if (!parentPathMatch) return; // Đã đến root hoặc không tìm thấy cha

        const parentPath = parentPathMatch[1];
        const parentCheckbox = document.querySelector(`input[type="checkbox"][data-path="${parentPath}"]`);

        if (parentCheckbox) {
            // Tìm tất cả con TRỰC TIẾP của cha này để kiểm tra trạng thái
            // Logic: Tìm các checkbox có path bắt đầu bằng "parentPath/" 
            // Lưu ý: Cách này tìm cả cháu chắt, nhưng ta chỉ cần kiểm tra tổng thể
            const allDescendants = document.querySelectorAll(`input[type="checkbox"][data-path^="${parentPath}/"]`);
            
            let checkedCount = 0;
            let indeterminateCount = 0;
            const totalCount = allDescendants.length;

            allDescendants.forEach(cb => {
                if (cb.checked) checkedCount++;
                if (cb.indeterminate) indeterminateCount++;
            });

            if (checkedCount === totalCount && totalCount > 0) {
                // Tất cả con đều được chọn -> Cha chọn
                parentCheckbox.checked = true;
                parentCheckbox.indeterminate = false;
                // Cập nhật Set cho cha
                if(parentCheckbox.classList.contains('justification-checkbox')) selectedJustifications.add(parentPath);
                else selectedTasks.add(parentPath);

            } else if (checkedCount === 0 && indeterminateCount === 0) {
                // Không con nào được chọn -> Cha bỏ chọn
                parentCheckbox.checked = false;
                parentCheckbox.indeterminate = false;
                // Xóa Set cho cha
                if(parentCheckbox.classList.contains('justification-checkbox')) selectedJustifications.delete(parentPath);
                else selectedTasks.delete(parentPath);

            } else {
                // Trạng thái hỗn hợp -> Cha Indeterminate (dấu gạch ngang)
                // Lưu ý: Indeterminate về mặt logic dữ liệu thường coi là chưa chọn (checked = false)
                // hoặc tùy nghiệp vụ. Ở đây ta để checked = false để khi click vào nó sẽ thành true (chọn hết).
                parentCheckbox.checked = false;
                parentCheckbox.indeterminate = true;
                // Xóa Set cho cha (vì chưa chọn trọn vẹn)
                if(parentCheckbox.classList.contains('justification-checkbox')) selectedJustifications.delete(parentPath);
                else selectedTasks.delete(parentPath);
            }

            // Tiếp tục đệ quy lên cấp ông/cố
            updateAncestors(parentPath);
        }
    }

    window.scrollToTop = function() {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    };

   // === HÀM XUẤT EXCEL THUẦN ===

// === BẮT ĐẦU KHỐI MÃ MỚI ĐỂ XUẤT EXCEL CÓ CÔNG THỨC ===

/**
 * HÀM PHỤ TRỢ 1: (ĐÃ SỬA LỖI)
 * Đệ quy "khô" qua toàn bộ dữ liệu để tìm số lần thực hiện tối đa.
 * Cần thiết để biết tạo bao nhiêu cột header.
 */
function findMaxExecutions(nodes) {
    let maxExec = 0;
    if (!nodes) return 0;

    const nodesArray = Array.isArray(nodes) ? nodes : Object.values(nodes);

    for (const node of nodesArray) {
        // === SỬA LỖI: THÊM KIỂM TRA "if (node)" ===
        // Bỏ qua các entry bị null hoặc undefined trong CSDL
        if (node) { 
            if (node.executions) {
                const execCount = Object.keys(node.executions).length;
                if (execCount > maxExec) maxExec = execCount;
            }
            
            // Đệ quy xuống các cấp con
            let childMax = 0;
            if (node.children) childMax = Math.max(childMax, findMaxExecutions(node.children));
            if (node.grandchildren) childMax = Math.max(childMax, findMaxExecutions(node.grandchildren));
            if (node.greatGrandchildren) childMax = Math.max(childMax, findMaxExecutions(node.greatGrandchildren));
            if (node.greatGreatGrandchildren) childMax = Math.max(childMax, findMaxExecutions(node.greatGreatGrandchildren));
            
            if (childMax > maxExec) maxExec = childMax;
        }
        // === KẾT THÚC SỬA LỖI ===
    }
    return maxExec;
}


/**
 * HÀM PHỤ TRỢ 2: (ĐÃ CẬP NHẬT: Thêm 'v:' cho các ô công thức)
 * Xử lý đệ quy các giải trình (Justifications) và ghi vào worksheet.
 * Trả về mảng các HÀNG (row index) của các giải trình con để SUM.
 */
function processJustificationForExcel(justificationNode, parentTT, level, ctx) {
    const r = ctx.currentRow;
    const isParentJustification = justificationNode.hasSubJustifications === true && justificationNode.subJustifications;
    let subJustificationRows = [];

    // Ghi dữ liệu giải trình cấp 1 (a, b, c...)
    ctx.ws[ctx.COLS.TT + r] = { t: 's', v: convertTTForDisplay(justificationNode.tt) };
    ctx.ws[ctx.COLS.NOI_DUNG + r] = { t: 's', v: justificationNode.noiDung || '' };
    
    const justStyle = { 
        font: { color: { rgb: "FF0000" }, italic: true },
        numFmt: ctx.moneyFormat 
    };
    
    if (isParentJustification) {
        const subJustifications = Object.keys(justificationNode.subJustifications)
            .map(subId => ({ id: subId, ...justificationNode.subJustifications[subId] }))
            .sort((a,b) => a.tt.localeCompare(b.tt));
        
        for (const subJustData of subJustifications) {
            ctx.currentRow++;
            const subJustChildRows = processJustificationForExcel(subJustData, justificationNode.tt, level + 1, ctx);
            subJustificationRows.push(...subJustChildRows);
        }
    }

    ctx.ws[ctx.COLS.DON_VI + r] = { t: 's', v: justificationNode.donVi || '', s: justStyle };
    
    if (!isParentJustification) {
        ctx.ws[ctx.COLS.SO_LUONG + r] = { t: 'n', v: justificationNode.soLuong || 0, s: justStyle };
        if (activeExportType === 'full' && ctx.COLS.DON_GIA) {
            ctx.ws[ctx.COLS.DON_GIA + r] = { t: 'n', v: justificationNode.donGia || 0, s: justStyle };
        }
    }
    
    // --- GHI CHI PHÍ ---
    const cellValue = justificationNode.chiPhi || 0; 

    if (isParentJustification && subJustificationRows.length > 0) {
        const sumCells = subJustificationRows.map(childR => ctx.COLS.CHI_PHI + childR).join(',');
        ctx.ws[ctx.COLS.CHI_PHI + r] = { t: 'n', v: cellValue, f: `SUM(${sumCells})`, s: justStyle };

    } else if (!isParentJustification && activeExportType === 'full' && ctx.COLS.DON_GIA) {
        const soLuongAddr = ctx.COLS.SO_LUONG + r;
        const donGiaAddr = ctx.COLS.DON_GIA + r; 
        ctx.ws[ctx.COLS.CHI_PHI + r] = { t: 'n', v: cellValue, f: `${soLuongAddr}*${donGiaAddr}`, s: justStyle };

    } else {
        ctx.ws[ctx.COLS.CHI_PHI + r] = { t: 'n', v: cellValue, s: justStyle };
    }
    
    // --- QUAN TRỌNG: Để trống 2 cột Phân bổ cho dòng Giải trình ---
    // (Không cần ghi gì cả, ô sẽ tự động trống, nhưng đảm bảo không bị lệch cột sau này)

    // Thêm style
    ctx.ws[ctx.COLS.TT + r].s = justStyle;
    ctx.ws[ctx.COLS.NOI_DUNG + r].s = justStyle;
    if (ctx.ws[ctx.COLS.SO_LUONG + r]) ctx.ws[ctx.COLS.SO_LUONG + r].s = justStyle;
    if (activeExportType === 'full' && ctx.COLS.DON_GIA && ctx.ws[ctx.COLS.DON_GIA + r]) {
        ctx.ws[ctx.COLS.DON_GIA + r].s = justStyle;
    }
    
    return [r];
}


/**
 * HÀM PHỤ TRỢ 3: (ĐÃ CẬP NHẬT: Thêm 'v:' cho các ô công thức)
 * Xử lý đệ quy các mục CÔNG VIỆC và ghi vào worksheet.
 * Trả về mảng các HÀNG (row index) của các mục con để SUM.
 */
function processNodeForExcel(node, path, level, ctx) {
    const r = ctx.currentRow;
    let childRows = [];
    let justificationRows = [];
    
    const hasL5Children = node.greatGreatGrandchildren && Object.keys(node.greatGreatGrandchildren).length > 0;
    const hasL4Children = node.greatGrandchildren && Object.keys(node.greatGrandchildren).length > 0;
    const hasL3Children = node.grandchildren && Object.keys(node.grandchildren).length > 0;
    const hasL2Children = node.children && Object.keys(node.children).length > 0;
    let isContainer = (node.hasChildren === true) || hasL2Children || hasL3Children || hasL4Children || hasL5Children;

    // Đệ quy xử lý con
    if (node.children) {
        const children = Object.keys(node.children).map(id => ({ id, ...node.children[id] })).sort(childSort);
        for (const childData of children) {
            ctx.currentRow++;
            childRows.push(...processNodeForExcel(childData, `${path}/children/${childData.id}`, level + 1, ctx));
        }
    }
    if (node.grandchildren) {
        const grandchildren = Object.keys(node.grandchildren).map(id => ({ id, ...node.grandchildren[id] })).sort((a,b)=>parseInt(a.id,10)-parseInt(b.id,10));
        for (const grandchildData of grandchildren) {
            ctx.currentRow++;
            childRows.push(...processNodeForExcel(grandchildData, `${path}/grandchildren/${grandchildData.id}`, level + 2, ctx));
        }
    }
    if (node.greatGrandchildren) {
        const greatGrandchildren = Object.keys(node.greatGrandchildren).map(id => ({ id, ...node.greatGrandchildren[id]})).sort(numericSort);
        for (const greatGrandchildData of greatGrandchildren) {
            ctx.currentRow++;
            childRows.push(...processNodeForExcel(greatGrandchildData, `${path}/greatGrandchildren/${greatGrandchildData.id}`, level + 3, ctx));
        }
    }
    if (node.greatGreatGrandchildren) {
        const greatGreatGrandchildren = Object.keys(node.greatGreatGrandchildren).map(id => ({ id, ...node.greatGreatGrandchildren[id]})).sort(numericSort);
        for (const gggcData of greatGreatGrandchildren) {
            ctx.currentRow++;
            childRows.push(...processNodeForExcel(gggcData, `${path}/greatGreatGrandchildren/${gggcData.id}`, level + 4, ctx));
        }
    }
    
    if (!isContainer && node.justifications && activeExportType === 'full') {
         const justifications = Object.keys(node.justifications)
            .map(id => ({ id, ...node.justifications[id] }))
            .sort((a,b) => a.id.localeCompare(b.id));
            
        for (const justData of justifications) {
            ctx.currentRow++;
            justificationRows.push(...processJustificationForExcel(justData, node.tt, level + 5, ctx));
        }
    }

    // --- GHI DỮ LIỆU CƠ BẢN ---
    
    ctx.ws[ctx.COLS.TT + r] = { t: 's', v: convertTTForDisplay(node.tt) };
    ctx.ws[ctx.COLS.NOI_DUNG + r] = { t: 's', v: node.noiDung || '' };
    ctx.ws[ctx.COLS.DV_THUCHIEN + r] = { t: 's', v: node.dvThucHien || '' };
    ctx.ws[ctx.COLS.DON_VI + r] = { t: 's', v: node.donVi || '' };
    ctx.ws[ctx.COLS.TAN_SUAT + r] = { t: 'n', v: node.tanSuatTH === undefined || node.tanSuatTH === null ? '' : node.tanSuatTH };
    
    // Ghi Năm Phân Bổ (Chỉ ghi giá trị, không cần công thức)
    ctx.ws[ctx.COLS.NAM_PHAN_BO + r] = { t: 'n', v: node.namPhanBo || '' };
    
    // Ghi Cấp độ
    ctx.ws[ctx.COLS.CAP_DO + r] = { t: 's', v: node.capDo || '' };

    // Ghi các cột bổ sung (Full mode)
    if (activeExportType === 'full') {
        ctx.ws[ctx.COLS.TG_BATDAU + r] = { t: 's', v: node.tgBatDau || '' };
        ctx.ws[ctx.COLS.TG_HOANTHANH + r] = { t: 's', v: node.tgHoanThanh || '' };
        ctx.ws[ctx.COLS.GHI_CHU + r] = { t: 's', v: node.ghiChu || '' };
    }

    // Xử lý Số lượng (Lấy từ Summary nếu là Cấp 1)
    if (level === 0 && ctx.summaryData && ctx.summaryData[node.id]) {
        const totalLeafNodesCap1 = ctx.summaryData[node.id].totalLeafNodesCap1 || 0;
        ctx.ws[ctx.COLS.SO_LUONG + r] = { t: 'n', v: totalLeafNodesCap1, s: { numFmt: ctx.moneyFormat } };
    } else if (!isContainer) {
        ctx.ws[ctx.COLS.SO_LUONG + r] = { t: 'n', v: node.soLuong || '', s: { numFmt: ctx.moneyFormat } };
    } else {
        ctx.ws[ctx.COLS.SO_LUONG + r] = { t: 'n', v: 0, s: { numFmt: ctx.moneyFormat } };
    }
    
    // Ghi Đơn giá
    if (activeExportType === 'full' && ctx.COLS.DON_GIA) {
        ctx.ws[ctx.COLS.DON_GIA + r] = { t: 'n', v: !isContainer ? (node.donGia || 0) : 0, s: { numFmt: ctx.moneyFormat } };
    }

    // --- XỬ LÝ CÁC CỘT TÍNH TOÁN (SUM/FORMULA) ---
    
    const sumFields = [
        { key: 'chiPhi', col: ctx.COLS.CHI_PHI },
        { key: 'chiPhiThucHien', col: ctx.COLS.CHI_PHI_THUCHIEN },
        // === THÊM CP_PHAN_BO VÀO DANH SÁCH TÍNH TOÁN ===
        { key: 'chiPhiPhanBo', col: ctx.COLS.CP_PHAN_BO } 
        // ================================================
    ];
    
    if (activeExportType === 'full') {
        sumFields.unshift({ key: 'khNamTruoc', col: ctx.COLS.KH_NAM_TRUOC });
        sumFields.unshift({ key: 'thucHienNamTruoc', col: ctx.COLS.TH_NAM_TRUOC });
    }

    for (const field of sumFields) {
        const cellAddress = field.col + r;
        const cellValue = node[field.key] || 0; // Giá trị đã tính sẵn trong DB

        if (isContainer && childRows.length > 0) {
            // TRƯỜNG HỢP 1: NÚT CHA (Parent)
            // Dùng công thức SUM để cộng tổng các con
            // Điều này áp dụng cho cả Chi Phí, Thực Hiện và CP Phân Bổ
            const sumCells = childRows.map(childR => field.col + childR).join(',');
            ctx.ws[cellAddress] = { t: 'n', v: cellValue, f: `SUM(${sumCells})`, s: { numFmt: ctx.moneyFormat } };
        
        } else if (!isContainer && field.key === 'chiPhiPhanBo') {
            // TRƯỜNG HỢP 2: NÚT LÁ - CP PHÂN BỔ
            // Dùng công thức chia: Chi phí / Năm phân bổ
            const chiPhiAddr = ctx.COLS.CHI_PHI + r;
            const namPbAddr = ctx.COLS.NAM_PHAN_BO + r;
            
            if (node.namPhanBo && node.namPhanBo > 0) {
                 ctx.ws[cellAddress] = { 
                    t: 'n', 
                    v: cellValue, 
                    f: `IF(${namPbAddr}>0, ${chiPhiAddr}/${namPbAddr}, 0)`, 
                    s: { numFmt: ctx.moneyFormat } 
                };
            } else {
                ctx.ws[cellAddress] = { t: 'n', v: 0, s: { numFmt: ctx.moneyFormat } };
            }

        } else if (!isContainer && field.key === 'chiPhi' && justificationRows.length > 0) {
            // TRƯỜNG HỢP 3: NÚT LÁ - CHI PHÍ (Có giải trình)
            // Dùng công thức SUM giải trình
            const sumCells = justificationRows.map(justR => ctx.COLS.CHI_PHI + justR).join(',');
            ctx.ws[cellAddress] = { t: 'n', v: cellValue, f: `SUM(${sumCells})`, s: { numFmt: ctx.moneyFormat } };

        } else {
            // TRƯỜNG HỢP 4: CÁC TRƯỜNG HỢP KHÁC (Giá trị thường)
            ctx.ws[cellAddress] = { t: 'n', v: cellValue, s: { numFmt: ctx.moneyFormat } };
        }
    }
    
    // Ghi Kế Hoạch Còn Lại
    const chiPhiAddr = ctx.COLS.CHI_PHI + r;
    const chiPhiThucHienAddr = ctx.COLS.CHI_PHI_THUCHIEN + r;
    const keHoachConLaiValue = (node.chiPhi || 0) - (node.chiPhiThucHien || 0);
    
    ctx.ws[ctx.COLS.KH_CON_LAI + r] = { 
        t: 'n', 
        v: keHoachConLaiValue,
        f: `${chiPhiAddr}-${chiPhiThucHienAddr}`,
        s: { numFmt: ctx.moneyFormat } 
    };

    // Ghi Thực hiện (Executions)
    if (node.executions && !isContainer) {
        for (const execId in node.executions) {
            const exec = node.executions[execId];
            const lanThucHien = exec.lanThucHien !== undefined ? parseInt(exec.lanThucHien, 10) : parseInt(execId, 10);
            if (isNaN(lanThucHien) || lanThucHien <= 0) continue;

            const colMap = ctx.execHeaderMap[lanThucHien];
            if (!colMap) continue;

            if (colMap.ngayTh) ctx.ws[colMap.ngayTh + r] = { t: 's', v: exec.ngayThucHien || '', s: { numFmt: '@' } };
            if (colMap.soLuong) ctx.ws[colMap.soLuong + r] = { t: 'n', v: exec.dvt || 0, s: { numFmt: ctx.moneyFormat } };
            if (colMap.donGia) ctx.ws[colMap.donGia + r] = { t: 'n', v: exec.donGia || 0, s: { numFmt: ctx.moneyFormat } };
            if (colMap.thanhTien) ctx.ws[colMap.thanhTien + r] = { t: 'n', v: exec.thanhTien || 0, s: { numFmt: ctx.moneyFormat } };
            
            if (activeExportType === 'full') {
                 if (colMap.timestamp) ctx.ws[colMap.timestamp + r] = { t: 's', v: String(exec.timestamp || ''), s: { numFmt: '@' } };
                 if (colMap.hoSoLink) ctx.ws[colMap.hoSoLink + r] = { t: 's', v: exec.hoSoLink || '' };
            }
        }
    }
    
    // Trả về row index hiện tại để cha sử dụng cho hàm SUM
    return [r];
}

/**
 * HÀM LÕI MỚI (Helper function)
 * Tách logic tạo worksheet ra khỏi hàm export
 * Hàm này sẽ được cả exportPlainDataExcel và exportToClipboard sử dụng
 */
async function generateWorksheetWithFormulas() {
    const parentQuery = ref(db, getParentCollectionName());
    const parentSnapshot = await get(parentQuery);
    if (!parentSnapshot.exists()) {
        throw new Error('Không có dữ liệu để xuất.');
    }
    const parentsData = parentSnapshot.val();

    // === LẤY DỮ LIỆU SUMMARY ===
    const summaryRef = ref(db, `summary_data/${currentYear}`);
    const summarySnap = await get(summaryRef);
    const summaryData = summarySnap.exists() ? summarySnap.val() : {};
    // ==========================

    const maxLanThucHien = findMaxExecutions(parentsData);

    const baseHeadersFull = [
        'TT', 'Đầu việc/Dự án', 'ĐV th.hiện', 'KH năm trước', 'Thực hiện năm trước', 
        'Tần suất TH', 'Đ.vị tính', 'Số lượng', 'Đơn giá (GT)', 'Chi phí KH', 
        'Chi phí thực hiện', 'Kế hoạch còn lại', 
        'Năm phân bổ', 'CP phân bổ', 
        'Cấp độ', 'TG bắt đầu', 'TG hoàn thành', 'Ghi chú'
    ];
    
    const baseHeadersSimplified = baseHeadersFull.filter(h => !['Đơn giá (GT)', 'KH năm trước', 'Thực hiện năm trước', 'TG bắt đầu', 'TG hoàn thành', 'Ghi chú'].includes(h));
    
    const headersToUse = activeExportType === 'full' ? baseHeadersFull : baseHeadersSimplified;
    
    const executionHeaders = [];
    const execHeaderMap = {};
    let currentColIndex = headersToUse.length; 
    
    for (let i = 1; i <= maxLanThucHien; i++) {
        const colMap = {};
        colMap.ngayTh = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Ngày TH (${i})`); currentColIndex++;
        colMap.soLuong = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Số lượng (${i})`); currentColIndex++;
        colMap.donGia = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Đơn giá (${i})`); currentColIndex++;
        colMap.thanhTien = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Thành tiền (${i})`); currentColIndex++;
        if (activeExportType === 'full') {
            colMap.timestamp = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Timestamp (${i})`); currentColIndex++;
            colMap.hoSoLink = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Hồ sơ Link (${i})`); currentColIndex++;
        }
        execHeaderMap[i] = colMap;
    }

    const finalHeaders = [...headersToUse, ...executionHeaders];
    const COLS = {};
    const colNameMap = {
        'TT': 'TT', 'Đầu việc/Dự án': 'NOI_DUNG', 'ĐV th.hiện': 'DV_THUCHIEN',
        'KH năm trước': 'KH_NAM_TRUOC', 'Thực hiện năm trước': 'TH_NAM_TRUOC',
        'Tần suất TH': 'TAN_SUAT', 'Đ.vị tính': 'DON_VI', 'Số lượng': 'SO_LUONG',
        'Đơn giá (GT)': 'DON_GIA', 'Chi phí KH': 'CHI_PHI',
        'Chi phí thực hiện': 'CHI_PHI_THUCHIEN', 'Kế hoạch còn lại': 'KH_CON_LAI',
        'Năm phân bổ': 'NAM_PHAN_BO', 'CP phân bổ': 'CP_PHAN_BO',   
        'Cấp độ': 'CAP_DO', 'TG bắt đầu': 'TG_BATDAU', 'TG hoàn thành': 'TG_HOANTHANH',
        'Ghi chú': 'GHI_CHU'
    };
    
    finalHeaders.forEach((h, i) => {
        const key = colNameMap[h];
        if (key) {
            COLS[key] = XLSX.utils.encode_col(i);
        }
    });

    const wb = XLSX.utils.book_new();
    const ws = {}; 
    const moneyFormat = '#,##0';

    const ctx = {
        ws: ws,
        currentRow: 1, 
        COLS: COLS,
        execHeaderMap: execHeaderMap,
        moneyFormat: moneyFormat,
        summaryData: summaryData // TRUYỀN SUMMARY DATA VÀO CONTEXT
    };

    finalHeaders.forEach((h, i) => {
        const cellAddress = XLSX.utils.encode_cell({ c: i, r: 0 });
        ws[cellAddress] = { t: 's', v: h };
    });
    
    statusDiv.innerText = 'Đang xử lý dữ liệu và tạo công thức...';
    
    const parents = Object.keys(parentsData).map(id => ({ id, ...parentsData[id] })).sort((a,b) => a.id.localeCompare(b.id));
    ctx.currentRow = 2; 

    for (const p of parents) {
        processNodeForExcel(p, `${getParentCollectionName()}/${p.id}`, 0, ctx);
        ctx.currentRow++; 
    }
    
    const range = { s: { c: 0, r: 0 }, e: { c: finalHeaders.length - 1, r: ctx.currentRow - 1 } };
    ws['!ref'] = XLSX.utils.encode_range(range);

    return { wb, ws, finalHeaders };
}

/**
 * HÀM CẬP NHẬT: (Nút 1)
 * Xuất Excel với công thức tính toán (Tải file).
 */
window.exportPlainDataExcel = async function() {
    try {
        statusDiv.className = 'success';
        statusDiv.innerText = 'Đang chuẩn bị dữ liệu file Excel...';
        closeAllModals();

        // 1. Gọi hàm lõi để lấy dữ liệu
        const { wb, ws, finalHeaders } = await generateWorksheetWithFormulas();
        
        // 2. Tạo file và tải về
        XLSX.utils.book_append_sheet(wb, ws, 'Data');
        XLSX.writeFile(wb, `AT-CL-MT_${currentYear}_withFormulas.xlsx`);
        
        statusDiv.innerText = 'Xuất file Excel (có công thức) thành công!';

    } catch (error) {
        console.error("Lỗi khi xuất Excel (có công thức):", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi khi xuất file: ${error.message}`;
    }
};

/**
 * HÀM MỚI: (Nút 3 - Sửa lỗi triệt để bằng cách TỰ TẠO TSV)
 * Xuất dữ liệu vào Clipboard.
 */
window.exportToClipboard = async function() {
    try {
        statusDiv.className = 'success';
        statusDiv.innerText = 'Đang chuẩn bị dữ liệu cho clipboard...';
        closeAllModals();

        // 1. Gọi hàm lõi để lấy dữ liệu (hàm này vẫn đúng)
        // ws là đối tượng worksheet chứa cả giá trị 'v:' và công thức 'f:'
        const { ws } = await generateWorksheetWithFormulas();

        statusDiv.innerText = 'Đang chuyển đổi dữ liệu...';

        // 2. Tự xây dựng chuỗi TSV (thay vì dùng sheet_to_txt)
        // Đây là cách duy nhất để fix encoding VÀ giữ công thức
        const tsvData = [];
        const range = XLSX.utils.decode_range(ws['!ref']);
        
        for (let R = range.s.r; R <= range.e.r; ++R) {
            const row = [];
            for (let C = range.s.c; C <= range.e.c; ++C) {
                const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                const cell = ws[cellAddress];

                if (!cell) {
                    row.push(""); // Ô trống
                    continue;
                }

                // === LOGIC MỚI: Ưu tiên CÔNG THỨC (f) trước ===
                if (cell.f) {
                    // Excel hiểu định dạng TSV này: =FORMULA
                    // Chúng ta không cần dấu "=" ở đầu chuỗi (ví dụ: ="=SUM(A1:A2)")
                    // Chỉ cần =SUM(A1:A2) là đủ
                    row.push(`=${cell.f}`);
                }
                // Sau đó mới đến GIÁ TRỊ (v)
                else if (cell.v !== undefined && cell.v !== null) {
                    let value = cell.v;
                    
                    // Nếu là chuỗi, chúng ta cần "escape" nó
                    if (cell.t === 's' || typeof value === 'string') {
                        let str = String(value);
                        // Nếu chuỗi chứa dấu " (quote), tab, hoặc newline,
                        // chúng ta cần bọc nó trong dấu " và gấp đôi các dấu " bên trong.
                        if (str.includes('"') || str.includes('\t') || str.includes('\n')) {
                            str = `"${str.replace(/"/g, '""')}"`;
                        }
                        row.push(str);
                    } else {
                        // Nếu là số hoặc boolean, cứ đẩy thẳng vào
                        row.push(String(value));
                    }
                } 
                else {
                    row.push(""); // Ô có tồn tại nhưng không có giá trị
                }
            }
            tsvData.push(row.join('\t')); // Nối các cột bằng TAB
        }
        
        const clipboardString = tsvData.join('\n'); // Nối các hàng bằng NEWLINE
        // === KẾT THÚC LOGIC MỚI ===


        // 3. Sử dụng Clipboard API (đang chạy trên https)
        if (!navigator.clipboard) {
            throw new Error('Trình duyệt không hỗ trợ Clipboard API.');
        }

        // 4. Ghi chuỗi TSV đã được xây dựng chuẩn vào clipboard
        await navigator.clipboard.writeText(clipboardString); 
        
        statusDiv.className = 'success';
        statusDiv.innerText = 'Đã sao chép dữ liệu vào Clipboard! Bạn có thể dán (Paste) vào Excel.';

    } catch (error) {
        console.error("Lỗi khi sao chép vào Clipboard:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi sao chép: ${error.message}`;
    }
};

// === HÀM exportFormattedExcel_HTML ĐẦY ĐỦ (ĐÃ SỬA LỖI MÀU & TIMESTAMP) ===
// === HÀM exportFormattedExcel_HTML ĐẦY ĐỦ (ĐÃ SỬA THỨ TỰ CỘT) ===
window.exportFormattedExcel_HTML = async function() {
    try {
        statusDiv.className = 'success';
        statusDiv.innerText = 'Đang chuẩn bị dữ liệu...';
        closeAllModals();

        const parentQuery = ref(db, getParentCollectionName());
        const parentSnapshot = await get(parentQuery);
        if (!parentSnapshot.exists()) {
            alert('Không có dữ liệu để xuất.');
            statusDiv.innerText = '';
            return;
        }
        const parentsData = parentSnapshot.val();
        
        // === LẤY DỮ LIỆU SUMMARY ===
        const summaryRef = ref(db, `summary_data/${currentYear}`);
        const summarySnap = await get(summaryRef);
        const summaryData = summarySnap.exists() ? summarySnap.val() : {};
        // ==========================

        const allRows = [];
        let maxLanThucHien = 0;

        const processNode = (node, path, parentTT = '', level = 0) => {
            if (node.tt) {
                // Xử lý số lượng cấp 1
                let soLuongVal = node.soLuong;
                if (level === 0 && summaryData[node.id]) {
                    soLuongVal = summaryData[node.id].totalLeafNodesCap1 || 0;
                }

                const row = {
                    'TT': convertTTForDisplay(node.tt),
                    'Đầu việc/Dự án': node.noiDung || '',
                    'ĐV th.hiện': node.dvThucHien || '',
                    'KH năm trước': node.khNamTruoc === 0 ? 0 : (node.khNamTruoc || ''),
                    'Thực hiện năm trước': node.thucHienNamTruoc === 0 ? 0 : (node.thucHienNamTruoc || ''),
                    'Tần suất TH': node.tanSuatTH === undefined || node.tanSuatTH === null || node.tanSuatTH === '' ? '' : node.tanSuatTH,
                    'Đ.vị tính': node.donVi || '',
                    
                    // Sử dụng biến soLuongVal đã xử lý
                    'Số lượng': soLuongVal === 0 ? 0 : (soLuongVal || ''),
                    
                    'Đơn giá (GT)': node.donGia === 0 ? 0 : (node.donGia || ''),
                    'Chi phí KH': node.chiPhi === 0 ? 0 : (node.chiPhi || ''),
                    'Chi phí thực hiện': node.chiPhiThucHien === 0 ? 0 : (node.chiPhiThucHien || ''),
                    'Kế hoạch còn lại': node.keHoachConLai === 0 ? 0 : (node.keHoachConLai || ''),
                    'Năm phân bổ': node.namPhanBo || '',
                    'CP phân bổ': node.chiPhiPhanBo === 0 ? 0 : (node.chiPhiPhanBo || ''),
                    'Cấp độ': node.capDo || '',
                    'TG bắt đầu': node.tgBatDau || '',
                    'TG hoàn thành': node.tgHoanThanh || '',
                    'Ghi chú': node.ghiChu || '',
                    level: level,
                    isJustification: false
                };
                // ... (phần xử lý executions và đệ quy con giữ nguyên) ...
                if (node.executions) {
                    for (const execId in node.executions) {
                        const exec = node.executions[execId];
                        const lanThucHien = exec.lanThucHien !== undefined ? parseInt(exec.lanThucHien, 10) : parseInt(execId, 10);
                        if (!isNaN(lanThucHien)) {
                             row[`Ngày TH (${lanThucHien})`] = exec.ngayThucHien || '';
                             row[`Số lượng (${lanThucHien})`] = exec.dvt === 0 ? 0 : (exec.dvt || '');
                             row[`Đơn giá (${lanThucHien})`] = exec.donGia === 0 ? 0 : (exec.donGia || '');
                             row[`Thành tiền (${lanThucHien})`] = exec.thanhTien === 0 ? 0 : (exec.thanhTien || '');
                             if (activeExportType === 'full') {
                                 row[`Timestamp (${lanThucHien})`] = String(exec.timestamp || '');
                                 row[`Hồ sơ Link (${lanThucHien})`] = exec.hoSoLink || '';
                             }
                             if (lanThucHien > maxLanThucHien) {
                                 maxLanThucHien = lanThucHien;
                             }
                        }
                    }
                }
                allRows.push(row);
            }

            if (node.children) {
                const children = Object.keys(node.children).map(id => ({ id, ...node.children[id] })).sort(childSort);
                children.forEach(child => processNode(child, `${path}/children/${child.id}`, node.tt, level + 1));
            }
            if (node.grandchildren) {
                const grandchildren = Object.keys(node.grandchildren).map(id => ({ id, ...node.grandchildren[id] })).sort((a,b)=>parseInt(a.id,10)-parseInt(b.id,10));
                grandchildren.forEach(gc => processNode(gc, `${path}/grandchildren/${gc.id}`, node.tt, level + 2));
            }
            if (node.greatGrandchildren) {
                const greatGrandchildren = Object.keys(node.greatGrandchildren).map(id => ({ id, ...node.greatGrandchildren[id] })).sort(numericSort);
                greatGrandchildren.forEach(ggc => processNode(ggc, `${path}/greatGrandchildren/${ggc.id}`, node.tt, level + 3));
            }
            if (node.greatGreatGrandchildren) {
                const greatGreatGrandchildren = Object.keys(node.greatGreatGrandchildren).map(id => ({ id, ...node.greatGreatGrandchildren[id] })).sort(numericSort);
                greatGreatGrandchildren.forEach(gggc => processNode(gggc, `${path}/greatGreatGrandchildren/${gggc.id}`, node.tt, level + 4));
            }

            if (activeExportType === 'full' && node.justifications) {
                const justifications = Object.keys(node.justifications).map(id => ({ id, ...node.justifications[id] })).sort((a,b) => a.id.localeCompare(b.id));
                justifications.forEach(just => {
                    const justRow = {
                        'TT': convertTTForDisplay(just.tt),
                        'Đầu việc/Dự án': just.noiDung || '',
                        'ĐV th.hiện': '', 'KH năm trước': '', 'Thực hiện năm trước': '', 'Tần suất TH': '',
                        'Đ.vị tính': just.donVi || '',
                        'Số lượng': just.soLuong === 0 ? 0 : (just.soLuong || ''),
                        'Đơn giá (GT)': just.donGia === 0 ? 0 : (just.donGia || ''),
                        'Chi phí KH': just.chiPhi === 0 ? 0 : (just.chiPhi || ''),
                        'Chi phí thực hiện': '', 'Kế hoạch còn lại': '', 
                        'Năm phân bổ': '', 'CP phân bổ': '',
                        'Cấp độ': '', 'TG bắt đầu': '', 'TG hoàn thành': '', 'Ghi chú': '',
                        level: level + 5, isJustification: true
                    };
                    allRows.push(justRow);
                    if (just.hasSubJustifications && just.subJustifications) {
                        const subJustifications = Object.keys(just.subJustifications).map(subId => ({ id: subId, ...just.subJustifications[subId] })).sort((a,b) => { const numA = parseInt(a.tt.substring(1), 10); const numB = parseInt(b.tt.substring(1), 10); return numA - numB; });
                        subJustifications.forEach(subJust => {
                            const subJustRow = {
                                'TT': convertTTForDisplay(subJust.tt), 'Đầu việc/Dự án': subJust.noiDung || '',
                                'ĐV th.hiện': '', 'KH năm trước': '', 'Thực hiện năm trước': '', 'Tần suất TH': '',
                                'Đ.vị tính': subJust.donVi || '', 'Số lượng': subJust.soLuong === 0 ? 0 : (subJust.soLuong || ''),
                                'Đơn giá (GT)': subJust.donGia === 0 ? 0 : (subJust.donGia || ''), 'Chi phí KH': subJust.chiPhi === 0 ? 0 : (subJust.chiPhi || ''),
                                'Chi phí thực hiện': '', 'Kế hoạch còn lại': '', 'Năm phân bổ': '', 'CP phân bổ': '',
                                'Cấp độ': '', 'TG bắt đầu': '', 'TG hoàn thành': '', 'Ghi chú': '',
                                level: level + 6, isJustification: true
                            };
                            allRows.push(subJustRow);
                        });
                    }
                });
            }
        };

        const parents = Object.keys(parentsData).map(id => ({ id, ...parentsData[id] })).sort((a,b) => a.id.localeCompare(b.id));
        parents.forEach(p => processNode(p, `${getParentCollectionName()}/${p.id}`, '', 0));

        statusDiv.innerText = 'Đang tạo bảng HTML để xuất...';

        const baseHeadersFull = ['TT', 'Đầu việc/Dự án', 'ĐV th.hiện', 'KH năm trước', 'Thực hiện năm trước', 'Tần suất TH', 'Đ.vị tính', 'Số lượng', 'Đơn giá (GT)', 'Chi phí KH', 'Chi phí thực hiện', 'Kế hoạch còn lại', 'Năm phân bổ', 'CP phân bổ', 'Cấp độ', 'TG bắt đầu', 'TG hoàn thành', 'Ghi chú'];
        const baseHeadersSimplified = baseHeadersFull.filter(h => !['Đơn giá (GT)', 'KH năm trước', 'Thực hiện năm trước', 'TG bắt đầu', 'TG hoàn thành', 'Ghi chú'].includes(h));
        const executionHeadersOrdered = [];
        for (let i = 1; i <= maxLanThucHien; i++) {
            executionHeadersOrdered.push(`Ngày TH (${i})`);
            executionHeadersOrdered.push(`Số lượng (${i})`);
            executionHeadersOrdered.push(`Đơn giá (${i})`);
            executionHeadersOrdered.push(`Thành tiền (${i})`);
            if (activeExportType === 'full') {
                 executionHeadersOrdered.push(`Timestamp (${i})`);
                 executionHeadersOrdered.push(`Hồ sơ Link (${i})`);
            }
        }
        const headersToUse = activeExportType === 'full' ? [...baseHeadersFull, ...executionHeadersOrdered] : [...baseHeadersSimplified, ...executionHeadersOrdered];

        let tableHtml = `<table border="1"><thead><tr>${headersToUse.map(h => `<th>${h}</th>`).join('')}</tr></thead><tbody>`;

        allRows.forEach(row => {
            let baseStyle = '';
            const isJustificationRow = row.isJustification === true;

            if (isJustificationRow) {
                 baseStyle = 'background-color: #fffbe6; font-style: italic; color: red;';
                 if (row.level >= 6 ) baseStyle += ' padding-left: 20px;';
            } else {
                 if (row.level === 0) baseStyle = 'font-weight: bold; background-color: #e2e6ea;';
                 else if (row.level === 1) baseStyle = 'font-weight: bold; background-color: #e9ecef;';
                 else if (row.level === 2) baseStyle = 'font-weight: bold; background-color: #f2f4f6;';
                 else if (row.level === 3) baseStyle = 'font-weight: bold; background-color: #f8f9fa;';
            }

            tableHtml += '<tr>';
            headersToUse.forEach(h => {
                let currentStyle = baseStyle;
                if (h.startsWith('Ngày TH') || h.startsWith('Timestamp')) {
                    currentStyle += " mso-number-format:'\\@';";
                } else if (['Chi phí KH', 'Chi phí thực hiện', 'Kế hoạch còn lại', 'KH năm trước', 'Thực hiện năm trước', 'Thành tiền', 'Đơn giá', 'Đơn giá (GT)', 'Số lượng', 'CP phân bổ', 'Năm phân bổ'].some(numCol => h.startsWith(numCol))) {
                     currentStyle += " mso-number-format:'#,##0'; text-align: right;";
                }
                let value = row[h];
                if (h.startsWith('Timestamp')) value = String(value !== undefined && value !== null ? value : '');
                else value = value !== undefined && value !== null ? value : '';
                tableHtml += `<td style="${currentStyle}">${value}</td>`;
            });
            tableHtml += '</tr>';
        });
        tableHtml += '</tbody></table>';

        const excelTemplate = `<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40"><head><meta charset="UTF-8"><style>td { white-space: normal; vertical-align: top; }</style></head><body>${tableHtml}</body></html>`;
        const blob = new Blob([excelTemplate], { type: 'application/vnd.ms-excel;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `AT-CL-MT_${currentYear}_formatted.xls`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        statusDiv.innerText = 'Xuất file Excel định dạng thành công!';
    } catch (error) {
        console.error("Lỗi khi xuất Excel định dạng:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi khi xuất file: ${error.message}`;
    }
};
    


	window.openSummaryDetailModal = async function() {
        try {
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đang tải dữ liệu chi tiết...';

            const summaryRef = ref(db, `summary_data/${currentYear}`);
            const summarySnap = await get(summaryRef);

            if (!summarySnap.exists()) {
                throw new Error('Không tìm thấy dữ liệu tổng hợp. Vui lòng nhấn "Tải lại & Tính toán lại".');
            }
            const summaryData = summarySnap.val();

            const parentQuery = ref(db, getParentCollectionName());
            const parentSnapshot = await get(parentQuery);
            if (!parentSnapshot.exists()) {
                throw new Error('Không có dữ liệu cho năm này.');
            }

            const parentsData = parentSnapshot.val();
            const parents = Object.keys(parentsData).map(id => ({ id, ...parentsData[id] })).sort((a, b) => a.id.localeCompare(b.id));

            const modal = document.getElementById('summaryDetailModal');
            const contentContainer = document.getElementById('summaryDetailContent');
            document.getElementById('summaryDetailYear').textContent = currentYear;
            contentContainer.innerHTML = '';

            let htmlContent = '';
            for (const parent of parents) {
                const parentId = parent.id;
                const parentSummary = summaryData[parentId] || {};

                const name = parent.noiDung || 'Chưa có tên';
                const totalLeafNodes = parentSummary.totalLeafNodes || 0;
                const executedLeafNodes = parentSummary.totalExecutedLeafNodes || 0;
                const totalLeafNodesCap1 = parentSummary.totalLeafNodesCap1 || 0;
                const executedLeafNodesCap1 = parentSummary.totalExecutedLeafNodesCap1 || 0;

                // === BẮT ĐẦU SỬA LỖI ===
                // Lấy chi phí trực tiếp từ "công việc mẹ" (parent) thay vì từ summaryData
                const plannedCost = parent.chiPhi || 0;
                const executedCost = parent.chiPhiThucHien || 0;
                // === KẾT THÚC SỬA LỖI ===

                const leafPercentage = totalLeafNodes > 0 ? Math.round((executedLeafNodes / totalLeafNodes) * 100) : 0;
                const cap1Percentage = totalLeafNodesCap1 > 0 ? Math.round((executedLeafNodesCap1 / totalLeafNodesCap1) * 100) : 0;
                const costPercentage = plannedCost > 0 ? Math.round((executedCost / plannedCost) * 100) : 0;

                htmlContent += `
                    <div class="summary-parent-card">
                        <h3>${convertTTForDisplay(parentId)}. ${name}</h3>
                        <div class="summary-columns-container">
                            <div class="summary-info-column">
                                <h4>Kế hoạch</h4>
                                <p><strong>Số đầu việc KH:</strong> <span class="value">${totalLeafNodes}</span></p>
                                <p><strong>Số đầu việc cấp độ 1:</strong> <span class="value">${totalLeafNodesCap1}</span></p>
                                <p><strong>Chi phí KH:</strong> <span class="value">${formatNumber(plannedCost)}</span></p>
                            </div>
                            <div class="summary-info-column">
                                <h4>Thực hiện</h4>
                                <p><strong>Số đầu việc TH:</strong> <span class="value">${executedLeafNodes} <span class="percentage">(${leafPercentage}%)</span></span></p>
                                <p><strong>Số đầu việc cấp độ 1 TH:</strong> <span class="value">${executedLeafNodesCap1} <span class="percentage">(${cap1Percentage}%)</span></span></p>
                                <p><strong>Chi phí TH:</strong> <span class="value">${formatNumber(executedCost)} <span class="percentage">(${costPercentage}%)</span></span></p>
                            </div>
                        </div>
                        <div class="summary-charts-container">
                            <div class="chart-wrapper">
                                <canvas id="cap1Chart-${parentId}"></canvas>
                                <p>Tỷ lệ đầu việc cấp độ 1</p>
                            </div>
                            <div class="chart-wrapper">
                                <canvas id="costChart-${parentId}"></canvas>
                                <p>Tỷ lệ Chi phí</p>
                            </div>
                        </div>
                    </div>
                `;
            }

            contentContainer.innerHTML = htmlContent || '<p>Không có dữ liệu chi tiết để hiển thị.</p>';
            modal.style.display = 'block';

            activeCharts.forEach(chart => chart.destroy());
            activeCharts = [];

            for (const parent of parents) {
                const parentId = parent.id;
                const parentSummary = summaryData[parentId] || {};

                const totalLeafNodesCap1 = parentSummary.totalLeafNodesCap1 || 0;
                const executedLeafNodesCap1 = parentSummary.totalExecutedLeafNodesCap1 || 0;
                
                // === BẮT ĐẦU SỬA LỖI ===
                // Lấy chi phí trực tiếp từ "công việc mẹ" (parent) cho biểu đồ
                const plannedCost = parent.chiPhi || 0;
                const executedCost = parent.chiPhiThucHien || 0;
                // === KẾT THÚC SỬA LỖI ===

                const cap1Ctx = document.getElementById(`cap1Chart-${parentId}`).getContext('2d');
                const cap1Chart = new Chart(cap1Ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Đã thực hiện', 'Chưa thực hiện'],
                        datasets: [{
                            data: [executedLeafNodesCap1, totalLeafNodesCap1 - executedLeafNodesCap1],
                            backgroundColor: ['#28a745', '#e9ecef'],
                            borderColor: ['#28a745', '#e9ecef'],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed !== null) {
                                            label += context.parsed + ' đầu việc';
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
                activeCharts.push(cap1Chart);

                const costCtx = document.getElementById(`costChart-${parentId}`).getContext('2d');
                 const costChart = new Chart(costCtx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Đã thực hiện', 'Còn lại'],
                        datasets: [{
                            data: [executedCost, plannedCost > executedCost ? plannedCost - executedCost : 0],
                            backgroundColor: ['#007bff', '#e9ecef'],
                            borderColor: ['#007bff', '#e9ecef'],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed !== null) {
                                            label += formatNumber(context.parsed);
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
                activeCharts.push(costChart);
            }

            statusDiv.innerText = '';
        } catch (error) {
            console.error("Lỗi khi mở modal chi tiết:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi: ${error.message}`;
        }
    };

    window.toggleDropdown = function(event) {
        event.stopPropagation();
        document.querySelectorAll(".dropdown-content").forEach(content => {
            if (content !== event.target.nextElementSibling) content.classList.remove('show');
        });
        event.target.nextElementSibling.classList.toggle("show");
    };

    window.onclick = function(event) {
        if (!event.target.matches('.dropbtn')) {
            document.querySelectorAll(".dropdown-content").forEach(content => content.classList.remove('show'));
        }

        const linksDropdown = document.getElementById('links-dropdown-container');
        if (linksDropdown && !linksDropdown.contains(event.target) && !event.target.matches('[data-links]')) {
             linksDropdown.remove();
        }
    };

    // CÁC HÀM HỖ TRỢ KHÔNG CẦN GLOBAL
    function showAuthError() {
        statusDiv.className = 'error';
        statusDiv.innerText = 'Lỗi: Bạn cần xác thực để thực hiện hành động này. Vui lòng "Đăng nhập".';
        setTimeout(() => { if (statusDiv.innerText && statusDiv.innerText.includes('Bạn cần xác thực')) { statusDiv.innerText = ''; } }, 6000);
    }

    function updateButtonStates() {
        // --- 1. ĐỊNH NGHĨA QUYỀN HẠN ---

        // Quyền Sửa đổi cấu trúc (Thêm, Sửa, Xóa task, Sửa inline):
        // Giữ nguyên logic cũ: Phải đăng nhập VÀ Phải bật checkbox "Cho phép sửa đổi"
        const isCurrentYearEditable = editModeStatusByYear[currentYear] === true;
        const canEditStructure = isAuthenticated && isCurrentYearEditable;

        // Quyền Thực hiện công việc:
        // Logic MỚI: Chỉ cần Đăng nhập là được phép thực hiện
        const canExecute = isAuthenticated;

        const planningToggle = document.getElementById('planningModeToggle');
        if (planningToggle) planningToggle.disabled = false;

        // --- 2. CẬP NHẬT TRẠNG THÁI NÚT THỰC HIỆN ---

        const multiExecuteButton = document.getElementById('multiExecuteBtn');
        if (multiExecuteButton) {
            // Nút này bây giờ chỉ phụ thuộc vào việc đã chọn task và đã đăng nhập (canExecute)
            // Không còn bị khóa bởi checkbox sửa đổi nữa.
            multiExecuteButton.disabled = selectedTasks.size === 0 || !canExecute;
        }

        // --- 3. GIỮ NGUYÊN GIỚI HẠN CHO CÁC NÚT KHÁC (Dùng canEditStructure) ---

        const deleteSelectedButton = document.getElementById('deleteSelectedBtn');
        if (deleteSelectedButton) {
            // Nút Xóa vẫn phải tuân thủ quy tắc nghiêm ngặt cũ
            deleteSelectedButton.disabled = !canEditStructure || (selectedTasks.size === 0 && selectedJustifications.size === 0);
        }

        const actionButtons = document.querySelectorAll('#taskList .dropbtn, #taskList .btn-edit-leaf');
        actionButtons.forEach(btn => {
            // Các nút Thêm/Sửa nhỏ trong bảng vẫn tuân thủ quy tắc nghiêm ngặt cũ
            btn.disabled = !canEditStructure;
        });

        // Logic tắt Planning Mode khi mất quyền sửa đổi (giữ nguyên để đảm bảo an toàn giao diện)
        if (!canEditStructure) {
            if (planningToggle && planningToggle.checked && isAuthenticated) {
                planningToggle.checked = false;
                const taskList = document.getElementById('taskList');
                if (taskList) taskList.classList.remove('planning-mode');
                
                const btnExcel1 = document.getElementById('exportExcel1Btn');
                const btnExcel2 = document.getElementById('exportExcel2Btn');
                if (btnExcel1) btnExcel1.disabled = false;
                if (btnExcel2) btnExcel2.disabled = true;

                const allRows = document.querySelectorAll('#taskListBody tr');
                allRows.forEach(row => row.style.display = '');
            }
        }
    }

    const recalculateExecutionCost = async (leafNodePath) => {
        const execSnapshot = await get(ref(db, `${leafNodePath}/executions`));
        let newChiPhiThucHien = 0;
        if (execSnapshot.exists()) {
            const execData = execSnapshot.val();
            for (const execId in execData) {
                newChiPhiThucHien += (execData[execId].thanhTien || 0);
            }
        }
        const leafNodeSnap = await get(ref(db, leafNodePath));
        if (leafNodeSnap.exists()) {
            const leafNodeData = leafNodeSnap.val();
            const chiPhi = leafNodeData.chiPhi || 0;
            await update(ref(db, leafNodePath), { chiPhiThucHien: newChiPhiThucHien, keHoachConLai: chiPhi - newChiPhiThucHien });
        }
    };

    const writeTreeToRealtimeDatabase = async (tree) => {
    const updates = {};

    const processNode = (node, path) => {
        // Thay đổi logic: cập nhật từng trường riêng lẻ thay vì cả đối tượng
        if (node.data && Object.keys(node.data).length > 1) {
            for (const key in node.data) {
                if (Object.prototype.hasOwnProperty.call(node.data, key)) {
                    // Tạo đường dẫn đầy đủ cho từng trường dữ liệu, ví dụ: .../A/noiDung
                    updates[`${path}/${key}`] = node.data[key];
                }
            }
        }

        if (node.justifications) {
            node.justifications.forEach(just => {
                const justPath = `${path}/justifications/${just.id}`;
                // Áp dụng logic tương tự cho các giải trình
                for (const key in just.data) {
                    if (Object.prototype.hasOwnProperty.call(just.data, key)) {
                        updates[`${justPath}/${key}`] = just.data[key];
                    }
                }
  // THÊM PHẦN NÀY: Xử lý giải trình cấp 2
                if (just.subJustifications) {
                    just.subJustifications.forEach(subJust => {
                        const subJustPath = `${justPath}/subJustifications/${subJust.id}`;
                        for (const key in subJust.data) {
                            if (Object.prototype.hasOwnProperty.call(subJust.data, key)) {
                                updates[`${subJustPath}/${key}`] = subJust.data[key];
                            }
                        }
                    });
                }
            });
        }



        // Các lời gọi đệ quy để xử lý các cấp con được giữ nguyên
        if (node.children) {
            node.children.forEach(child => processNode(child, `${path}/children/${child.id}`));
        }
        if (node.grandchildren) {
            node.grandchildren.forEach(grandchild => processNode(grandchild, `${path}/grandchildren/${grandchild.id}`));
        }
        if (node.greatGrandchildren) {
            node.greatGrandchildren.forEach(ggc => {
                const ggcPath = `${path}/greatGrandchildren/${ggc.id}`;
                processNode(ggc, ggcPath);

                if ((!ggc.greatGreatGrandchildren || ggc.greatGreatGrandchildren.length === 0) && ggc.executions && ggc.executions.length > 0) {
                    ggc.executions.forEach(exec => {
                        const execKey = push(child(ref(db), `${ggcPath}/executions`)).key;
                        updates[`${ggcPath}/executions/${execKey}`] = exec;
                    });
                }
            });
        }
        if (node.greatGreatGrandchildren) {
             node.greatGreatGrandchildren.forEach(gggc => {
                const gggcPath = `${path}/greatGreatGrandchildren/${gggc.id}`;
                processNode(gggc, gggcPath);
                if (gggc.executions && gggc.executions.length > 0) {
                    gggc.executions.forEach(exec => {
                        const execKey = push(child(ref(db), `${gggcPath}/executions`)).key;
                        updates[`${gggcPath}/executions/${execKey}`] = exec;
                    });
                }
            });
        }
    };

    tree.forEach(p => processNode(p, `${getParentCollectionName()}/${p.id}`));

    // Lệnh update cuối cùng không thay đổi, nhưng đối tượng 'updates' đã an toàn
    await update(ref(db), updates);
};

    const formatNumber = (num) => num?.toLocaleString('vi-VN') || '0';

// === BẮT ĐẦU: HÀM HELPER MỚI ĐỂ TĂNG TT ===
    function incrementTT(displayTT) {
        try {
            // Case: "a", "b", "c" (Giải trình cấp 1)
            if (/^[a-z]$/.test(displayTT)) {
                return String.fromCharCode(displayTT.charCodeAt(0) + 1);
            }
            // Case: "a1", "a10" (Giải trình cấp 2)
            if (/^([a-z])(\d+)$/.test(displayTT)) {
                const letter = displayTT.match(/^([a-z])/)[1];
                const num = parseInt(displayTT.match(/(\d+)$/)[1], 10);
                return `${letter}${num + 1}`;
            }
            // Case: "A.1", "1.1", "1.1.1" (Công việc dùng dấu chấm)
            if (displayTT.includes('.')) {
                const parts = displayTT.split('.');
                const lastPart = parts.pop();
                const num = parseInt(lastPart, 10);
                if (!isNaN(num)) {
                    parts.push(num + 1);
                    return parts.join('.');
                }
            }
            // Case: "1", "10" (Công việc cấp 3 - grandchild)
            const num = parseInt(displayTT, 10);
            if (!isNaN(num)) {
                return String(num + 1);
            }
        } catch (e) {
            console.error("Lỗi khi tăng TT:", displayTT, e);
        }
        // Fallback an toàn
        return displayTT + "+1";
    }
    // === KẾT THÚC: HÀM HELPER MỚI ĐỂ TĂNG TT ===

    function initializeGoogleClients() {
        // Khởi tạo GAPI Client (Drive API)
        gapi.load('client', async () => {
            try {
                await gapi.client.init({
                   // apiKey: API_KEY, // Không cần thiết khi dùng OAuth
                   discoveryDocs: DISCOVERY_DOCS,
                });
                gapiReady = true;
                console.log('GAPI client initialized.');
            } catch (error) {
                 console.error('Lỗi khởi tạo GAPI client:', error);
                 statusDiv.className = 'error';
                 statusDiv.innerText = 'Lỗi kết nối tới Google Drive API.';
            }
        });

        // Khởi tạo Google Identity Services (GIS) Client (OAuth)
        try {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: tokenResponseCallback, // Callback mặc định (có thể bị ghi đè tạm thời)
            });
            gisInited = true;
            console.log('GIS token client initialized.');
        } catch (error) {
            console.error('Lỗi khởi tạo GIS token client:', error);
            statusDiv.className = 'error';
            statusDiv.innerText = 'Lỗi kết nối tới dịch vụ xác thực Google.';
        }
    }

    function ensureGapiAuthenticated() {
        return new Promise((resolve, reject) => {
            if (gapi.client.getToken()) return resolve(gapi.client.getToken());
            tokenClient.requestAccessToken({ prompt: '' });
            tokenClient.callback = (resp) => {
                if (resp.error) reject(resp.error);
                else resolve(resp);
                tokenClient.callback = () => {};
            };
        });
    }



    const calculateCosts = (tree) => {
    tree.forEach(parent => {
        let parentChiPhi = 0, parentChiPhiThucHien = 0, parentKhNamTruoc = 0;
        (parent.children || []).forEach(child => {
            let childChiPhi = 0, childChiPhiThucHien = 0, childKhNamTruoc = 0;
            (child.grandchildren || []).forEach(grandchild => {
                let grandchildChiPhi = 0, grandchildChiPhiThucHien = 0, grandchildKhNamTruoc = 0;
                (grandchild.greatGrandchildren || []).forEach(ggc => {
                    if ((ggc.greatGreatGrandchildren || []).length > 0) {
                        ggc.data.hasChildren = true;
                        
                        // THÊM MỚI: Tính chi phí cho lá cấp 5 (ggggc) từ giải trình của nó
                        ggc.greatGreatGrandchildren.forEach(ggggc => {
                            // Tính tổng chi phí từ giải trình (cả cấp 1 và cấp 2) của lá cấp 5
                            let justificationChiPhi = 0;
                            if (ggggc.justifications && ggggc.justifications.length > 0) {
                                ggggc.justifications.forEach(just => {
                                    // NẾU CÓ GIẢI TRÌNH CẤP 2: tính tổng chi phí của các giải trình cấp 2
                                    if (just.subJustifications && just.subJustifications.length > 0) {
                                        justificationChiPhi += just.subJustifications.reduce(
                                            (sum, subJust) => sum + (subJust.data.chiPhi || 0), 0
                                        );
                                    } else {
                                        // NẾU KHÔNG CÓ GIẢI TRÌNH CẤP 2: lấy chi phí của giải trình cấp 1
                                        justificationChiPhi += just.data.chiPhi || 0;
                                    }
                                });
                                ggggc.data.chiPhi = justificationChiPhi; // Ghi đè chiPhi của lá cấp 5
                            }
                        });

                        const ggcChiPhi = ggc.greatGreatGrandchildren.reduce((s, gggc) => s + (gggc.data.chiPhi || 0), 0);
                        const ggcChiPhiThucHien = ggc.greatGreatGrandchildren.reduce((s, gggc) => s + (gggc.data.chiPhiThucHien || 0), 0);
                        const ggcKhNamTruoc = ggc.greatGreatGrandchildren.reduce((s, gggc) => s + (gggc.data.khNamTruoc || 0), 0);
                        ggc.data.chiPhi = ggcChiPhi;
                        ggc.data.chiPhiThucHien = ggcChiPhiThucHien;
                        ggc.data.khNamTruoc = ggcKhNamTruoc;
                    } else {
                        // Đây là lá cấp 4. Tính chi phí từ giải trình của nó (cả cấp 1 và cấp 2)
                        let justificationChiPhi = 0;
                        if (ggc.justifications && ggc.justifications.length > 0) {
                            ggc.justifications.forEach(just => {
                                // NẾU CÓ GIẢI TRÌNH CẤP 2: tính tổng chi phí của các giải trình cấp 2
                                if (just.subJustifications && just.subJustifications.length > 0) {
                                    justificationChiPhi += just.subJustifications.reduce(
                                        (sum, subJust) => sum + (subJust.data.chiPhi || 0), 0
                                    );
                                } else {
                                    // NẾU KHÔNG CÓ GIẢI TRÌNH CẤP 2: lấy chi phí của giải trình cấp 1
                                    justificationChiPhi += just.data.chiPhi || 0;
                                }
                            });
                            ggc.data.chiPhi = justificationChiPhi; // Ghi đè chiPhi của lá cấp 4
                        }
                        ggc.data.hasChildren = false;
                    }
                    if (ggc.data) {
                        ggc.data.keHoachConLai = (ggc.data.chiPhi || 0) - (ggc.data.chiPhiThucHien || 0);
                        grandchildChiPhi += ggc.data.chiPhi || 0;
                        grandchildChiPhiThucHien += ggc.data.chiPhiThucHien || 0;
                        grandchildKhNamTruoc += ggc.data.khNamTruoc || 0;
                    }
                });
                if (grandchild.data) {
                    grandchild.data.chiPhi = grandchildChiPhi;
                    grandchild.data.chiPhiThucHien = grandchildChiPhiThucHien;
                    grandchild.data.khNamTruoc = grandchildKhNamTruoc;
                    grandchild.data.keHoachConLai = grandchildChiPhi - grandchildChiPhiThucHien;
                }
                childChiPhi += grandchildChiPhi;
                childChiPhiThucHien += grandchildChiPhiThucHien;
                childKhNamTruoc += grandchildKhNamTruoc;
            });
            if (child.data) {
                child.data.chiPhi = childChiPhi;
                child.data.chiPhiThucHien = childChiPhiThucHien;
                child.data.khNamTruoc = childKhNamTruoc;
                child.data.keHoachConLai = childChiPhi - childChiPhiThucHien;
            }
            parentChiPhi += childChiPhi;
            parentChiPhiThucHien += childChiPhiThucHien;
            parentKhNamTruoc += childKhNamTruoc;
        });
        if (parent.data) {
            parent.data.chiPhi = parentChiPhi;
            parent.data.chiPhiThucHien = parentChiPhiThucHien;
            parent.data.khNamTruoc = parentKhNamTruoc;
            parent.data.keHoachConLai = parentChiPhi - parentChiPhiThucHien;
        }
    });
};

   const childSort = (a, b) => {
        // (CẬP NHẬT) a.id và b.id bây giờ chỉ là 'I', 'V', 'X'.
        // Không cần split hay so sánh parent.
        const numA = romanToNumber(a.id);
        const numB = romanToNumber(b.id);
        return numA - numB;
    };

    const numericSort = (a, b) => {
        const partsA = String(a.id).split(',').map(v => parseInt(v, 10));
        const partsB = String(b.id).split(',').map(v => parseInt(v, 10));
        const len = Math.max(partsA.length, partsB.length);
        for (let i = 0; i < len; i++) {
            const valA = partsA[i] || 0, valB = partsB[i] || 0;
            if (valA !== valB) return valA - valB;
        }
        return 0;
    };

    const createModalTable = (headers) => {
        let table = '<table class="modal-table"><thead><tr>';
        headers.forEach(h => {
            const style = h.width ? ` style="width: ${h.width};"` : '';
            const className = h.class ? ` class="${h.class}"` : '';
            const text = typeof h === 'object' ? h.text : h;
            table += `<th${style}${className}>${text}</th>`;
        });
        table += '</tr></thead><tbody>';
        return table;
    };

const createInputRow = (path, data, level, context = {}) => {
        const isJustification = level === 'justification';
        const isSubJustification = level === 'subJustification';
        
        const displayTT = convertTTForDisplay(data.tt);
        
        if (isJustification || isSubJustification) {
            const isParentJustification = isJustification && data.hasSubJustifications === true;
           return `<tr data-path="${path}">
                <td><input type="text" value="${displayTT}" data-field="tt" disabled></td>
                <td><input type="text" value="${data.noiDung || ''}" data-field="noiDung"></td>
                <td><input type="text" value="${data.donVi || ''}" data-field="donVi" ${isParentJustification ? 'disabled' : ''}></td>
                <td><input type="number" value="${data.soLuong || ''}" data-field="soLuong" oninput="calculateModalChiPhi(this)" onfocus="this.select()" ${isParentJustification ? 'disabled' : ''}></td>
                <td><input type="number" value="${data.donGia || 0}" data-field="donGia" oninput="calculateModalChiPhi(this)" onfocus="this.select()" ${isParentJustification ? 'disabled' : ''}></td>
                <td><input type="text" value="${formatNumber(data.chiPhi || (data.soLuong * data.donGia) || 0)}" data-field="chiPhi" ${isParentJustification ? 'disabled' : ''} oninput="this.value=formatNumber(parseNumber(this.value))"></td>
            </tr>`;
        }

        const isParent = ['parent', 'child', 'grandchild'].includes(level);
        const isContainerLeaf = level === 'greatGrandchild' && data.hasChildren;
        const isEditableLeaf = level === 'greatGreatGrandchild' || (level === 'greatGrandchild' && !data.hasChildren);
        const chiPhiDisabled = isEditableLeaf && context.hasJustifications;

        const isDisabled = (field) => {
            if (field === 'tt') return true;
            if (field === 'namPhanBo') {
                return isParent; 
            }
            if (isParent) return !['noiDung', 'ghiChu', 'dvThucHien', 'capDo', 'khNamTruoc', 'thucHienNamTruoc', 'tgBatDau', 'tgHoanThanh', 'namPhanBo'].includes(field); 
            if (isContainerLeaf) return !['noiDung', 'ghiChu', 'capDo', 'dvThucHien', 'tgBatDau', 'tgHoanThanh', 'namPhanBo'].includes(field); 
            
            if (field === 'chiPhi') return chiPhiDisabled;
            
            if (isParent || isContainerLeaf) {
                if (['tgBatDau', 'tgHoanThanh'].includes(field)) return false; 
            }

            return false;
        };

        const triggerCalc = isEditableLeaf ? 'oninput="calculateModalChiPhi(this)"' : '';
        const chiPhiEvent = isEditableLeaf ? 'onfocus="this.select()"' : '';

        // === CẬP NHẬT LOGIC HIỂN THỊ TẦN SUẤT TRONG MODAL ===
        // Nếu có giá trị (kể cả 0) thì lấy giá trị đó.
        // Nếu null/undefined/rỗng thì lấy mặc định là 1.
        let displayTanSuatModal = 1; 
        if (data.tanSuatTH !== undefined && data.tanSuatTH !== null && data.tanSuatTH !== '') {
            displayTanSuatModal = data.tanSuatTH;
        }
        // =====================================================

        return `<tr data-path="${path}" data-is-leaf="${isEditableLeaf}">
            <td><input type="text" value="${displayTT}" data-field="tt" disabled></td>
            <td><input type="text" value="${data.noiDung || ''}" data-field="noiDung" ${isDisabled('noiDung') ? 'disabled' : ''}></td>
            <td><input type="text" value="${data.dvThucHien || ''}" data-field="dvThucHien" ${isDisabled('dvThucHien') ? 'disabled' : ''}></td>
            
            <td><input type="text" value="${formatNumber(data.khNamTruoc || 0)}" data-field="khNamTruoc" oninput="this.value=formatNumber(parseNumber(this.value))" ${chiPhiEvent} ${isDisabled('khNamTruoc') ? 'disabled' : ''}></td>
            <td><input type="text" value="${formatNumber(data.thucHienNamTruoc || 0)}" data-field="thucHienNamTruoc" oninput="this.value=formatNumber(parseNumber(this.value))" ${chiPhiEvent} ${isDisabled('thucHienNamTruoc') ? 'disabled' : ''}></td>

            <td><input type="text" value="${data.donVi || ''}" data-field="donVi" ${isDisabled('donVi') ? 'disabled' : ''}></td>
            <td><input type="text" value="${data.soLuong || ''}" data-field="soLuong" ${isDisabled('soLuong') ? 'disabled' : ''}></td>
            
            <td><input type="number" value="${displayTanSuatModal}" data-field="tanSuatTH" ${isDisabled('tanSuatTH') ? 'disabled' : ''}></td>
            
            <td><input type="text" value="${formatNumber(data.chiPhi || 0)}" data-field="chiPhi" oninput="this.value=formatNumber(parseNumber(this.value)); ${isEditableLeaf ? 'calculateModalChiPhi(this)' : ''}" ${chiPhiEvent} ${isDisabled('chiPhi') ? 'disabled' : ''}></td>
            
            <td><input type="number" value="${data.namPhanBo || ''}" data-field="namPhanBo" ${triggerCalc} ${isDisabled('namPhanBo') ? 'disabled' : ''}></td>
            <td><input type="text" value="${formatNumber(data.chiPhiPhanBo || 0)}" data-field="chiPhiPhanBo" disabled></td>

            <td><input type="text" value="${data.capDo || ''}" data-field="capDo" ${isDisabled('capDo') ? 'disabled' : ''}></td>

            <td><input type="text" value="${data.tgBatDau || ''}" data-field="tgBatDau" ${isDisabled('tgBatDau') ? 'disabled' : ''}></td>
            <td><input type="text" value="${data.tgHoanThanh || ''}" data-field="tgHoanThanh" ${isDisabled('tgHoanThanh') ? 'disabled' : ''}></td>

            <td><input type="text" value="${data.ghiChu || ''}" data-field="ghiChu" ${isDisabled('ghiChu') ? 'disabled' : ''}></td>
        </tr>`;
    };

   const generateNextTT = async (parentPath, level) => {
        console.log(`[generateNextTT] Called for parentPath: ${parentPath}, level: ${level}`);
        const parentRef = ref(db, parentPath);
        const parentSnap = await get(parentRef);

        // Trường hợp cha không tồn tại hoặc khi thêm mục cấp 1 (A, B, C...)
        if (!parentSnap.exists()) {
            console.warn(`[generateNextTT] Parent snapshot not found at ${parentPath}.`);
            if (level === 'parent') {
                const rootSnapshot = await get(ref(db, getParentCollectionName()));
                let maxCharCode = 64; // Before 'A'
                if (rootSnapshot.exists()) {
                    const rootData = rootSnapshot.val();
                    for (const key in rootData) {
                        if (rootData[key]?.tt?.match(/^[A-Z]$/)) {
                            const charCode = rootData[key].tt.charCodeAt(0);
                            if (charCode > maxCharCode) maxCharCode = charCode;
                        }
                    }
                }
                const nextChar = String.fromCharCode(maxCharCode + 1);
                console.log(`[generateNextTT] Parent not found, level=parent. Returning: ${nextChar}`);
                return nextChar;
            } else {
                console.log(`[generateNextTT] Parent not found, level=${level}. Returning default '1'.`);
                return '1';
            }
        }

        // Nếu cha tồn tại
        let maxNumPart = 0; // Lưu phần SỐ lớn nhất hoặc mã ASCII lớn nhất
        const data = parentSnap.val();
        const parentTT = data.tt || ''; // TT của cha (Vd: 'A', 'A,1', '1', '1,1', 'a')
        console.log(`[generateNextTT] Parent TT found: ${parentTT}`);

        let subCollectionName;
        // Xác định collection con
        if (level === 'child') subCollectionName = 'children';
        else if (level === 'grandchild') subCollectionName = 'grandchildren';
        else if (level === 'greatGrandchild') subCollectionName = 'greatGrandchildren';
        else if (level === 'greatGreatGrandchild') subCollectionName = 'greatGreatGrandchildren';
        else if (level === 'justification') subCollectionName = 'justifications';
        else if (level === 'subJustification') subCollectionName = 'subJustifications';
        else {
             console.error(`[generateNextTT] Invalid level: ${level}`);
             return 'error_invalid_level';
        }

        const subCollection = data[subCollectionName] || {};
        console.log(`[generateNextTT] Checking subCollection "${subCollectionName}":`, subCollection); // DEBUG

        // Vòng lặp tìm phần số/ký tự lớn nhất (maxNumPart)
        for (const key in subCollection) {
            const currentItem = subCollection[key];
            if (!currentItem?.tt) continue; // Bỏ qua nếu không có tt

            const tt = currentItem.tt; // TT của item con đang xét (Vd: 'A,1', '1', '1.1', 'a', 'a1')
            console.log(`[generateNextTT]   Checking item TT: "${tt}"`); // DEBUG INSIDE LOOP

            try {
                let currentNum = NaN;
                let updateMax = false;

                if (level === 'justification') {
                    const charCode = tt.charCodeAt(0);
                    currentNum = charCode;
                    if (maxNumPart === 0) maxNumPart = 96; // Initialize before 'a'
                    updateMax = currentNum > maxNumPart;
                } else if (level === 'subJustification') {
                    if (tt.startsWith(parentTT) && tt.length > parentTT.length) {
                        const numPartStr = tt.substring(parentTT.length);
                        currentNum = parseInt(numPartStr, 10);
                        updateMax = !isNaN(currentNum) && currentNum > maxNumPart;
                    }
                } else if (level === 'child') {
                    // (CẬP NHẬT) tt bây giờ chỉ là 'I', 'V', 'X'. Không cần kiểm tra parentTT.
                    currentNum = romanToNumber(tt); 
                    updateMax = !isNaN(currentNum) && currentNum > 0 && currentNum > maxNumPart;
                } else if (level === 'grandchild') {
                    currentNum = parseInt(tt, 10); // Cấp 3 là số đơn giản
                    updateMax = !isNaN(currentNum) && currentNum > maxNumPart;
                } else if (level === 'greatGrandchild' || level === 'greatGreatGrandchild') {
                    // **SỬA LỖI LINH HOẠT DẤU PHÂN CÁCH**
                    let prefixFound = false;
                    let numPartStr = null;

                    // Kiểm tra tiền tố với dấu phẩy
                    if (tt.startsWith(parentTT + ',')) {
                         prefixFound = true;
                         numPartStr = tt.substring(parentTT.length + 1);
                         console.log(`[generateNextTT]     TT "${tt}" matches prefix with COMMA.`);
                    }
                    // Nếu không khớp dấu phẩy, kiểm tra tiền tố với dấu chấm
                    else if (tt.startsWith(parentTT + '.')) {
                         prefixFound = true;
                         numPartStr = tt.substring(parentTT.length + 1);
                         console.log(`[generateNextTT]     TT "${tt}" matches prefix with PERIOD.`);
                    }

                    if (prefixFound && numPartStr !== null) {
                        // Tách phần còn lại bằng cả dấu phẩy hoặc dấu chấm
                        const parts = numPartStr.split(/[,\.]/);
                        if (parts.length > 0) {
                            const firstNumStr = parts[0]; // Chỉ lấy số đầu tiên sau tiền tố cha
                            currentNum = parseInt(firstNumStr, 10);
                            updateMax = !isNaN(currentNum) && currentNum > maxNumPart;
                             console.log(`[generateNextTT]     Extracted first number part: "${firstNumStr}". Parsed num: ${currentNum}. Current max: ${maxNumPart}. Update max? ${updateMax}`);
                        } else {
                            console.log(`[generateNextTT]     Could not extract number part from "${numPartStr}".`);
                        }
                    } else if (!prefixFound) {
                        console.log(`[generateNextTT]     TT "${tt}" does NOT start with parentTT "${parentTT}" + separator. Skipping.`);
                    }
                }

                if (updateMax) {
                    console.log(`[generateNextTT]     Updating maxNumPart from ${maxNumPart} to ${currentNum}`); // DEBUG UPDATE
                    maxNumPart = currentNum;
                }

            } catch (parseError) {
                 console.error(`[generateNextTT]   Error parsing TT "${tt}"`, parseError);
            }
        } // End loop

        console.log(`[generateNextTT] Loop finished. Final maxNumPart: ${maxNumPart}`);

        // Tạo TT mới - **LUÔN DÙNG DẤU PHẨY CHO NHẤT QUÁN**
        let nextTT = 'error_generation_failed';
        if (level === 'justification') {
            const nextCharCode = (maxNumPart === 0 || maxNumPart === 96) ? 97 : maxNumPart + 1; // 97 is 'a'
            nextTT = String.fromCharCode(nextCharCode);
        } else if (level === 'subJustification') {
             nextTT = `${parentTT}${maxNumPart + 1}`; // e.g., a1, a2
        } else if (level === 'child') {
            const nextRoman = numberToRoman(maxNumPart + 1); // Chuyển 1 -> 'I', 10 -> 'X'
            // (CẬP NHẬT) Mã hiệu mới chỉ là chữ số La Mã.
            nextTT = nextRoman; // e.g., I, II
        } else if (level === 'grandchild') {
            nextTT = String(maxNumPart + 1); // e.g., 1, 2
        } else if (level === 'greatGrandchild' || level === 'greatGreatGrandchild') {
             // **NHẤT QUÁN DÙNG DẤU PHẨY KHI TẠO MỚI**
            nextTT = `${parentTT},${maxNumPart + 1}`; // e.g., 6 -> 6,1 or 6,1 -> 6,1,1
        }

        console.log(`[generateNextTT] Calculated next TT: ${nextTT}`);
        return nextTT;
    };

    /**
     * Hàm nội bộ để bỏ chọn con (dùng cho nút "Chọn tất cả" ở đầu bảng)
     * Giữ nguyên dạng function cục bộ như mã nguồn gốc
     */
    function clearChildrenCheckboxes(parentCheckbox) {
        // Đảm bảo cha đã bỏ chọn trước khi gọi logic lan truyền
        if (parentCheckbox.checked) {
            parentCheckbox.checked = false;
        }
        // Tái sử dụng logic của toggleSelection để bỏ chọn toàn bộ con cháu
        window.toggleSelection(parentCheckbox);
    }

    window.onscroll = function() {
        const btn = document.getElementById("scrollToTopBtn");
        if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
            btn.style.display = "block";
        } else {
            btn.style.display = "none";
        }
    };

// Ensure checkAndUpdateDaThucHien is robust
     

   const recalculateCostsForParents = async (paths) => {
        const pathsToRecalculate = new Set();
        const pathsToCheckDaThucHien = new Set(); // Keep track of child paths for 'daThucHien' check

        // 1. Gather all unique ancestor paths
        for (const path of paths) {
            let currentPath = path;
            while (currentPath.includes('/')) {
                const parentPath = currentPath.substring(0, currentPath.lastIndexOf('/'));
                // Ensure we don't add collection names like 'children', 'grandchildren' etc.
                if (parentPath.split('/').length > 1 && !['children', 'grandchildren', 'greatGrandchildren', 'greatGreatGrandchildren'].includes(parentPath.substring(parentPath.lastIndexOf('/') + 1))) {
                    pathsToRecalculate.add(parentPath);
                     // If it's a direct child of the root (e.g., congViecMeYYYY/A/children/A,1), add for 'daThucHien' check
                     if (parentPath.split('/').length === 4 && parentPath.includes('/children/')) {
                         pathsToCheckDaThucHien.add(parentPath);
                     }
                }
                 // If the original path was a direct child, add it for checking 'daThucHien' status
                 if (path.split('/').length === 4 && path.includes('/children/')) {
                      pathsToCheckDaThucHien.add(path);
                 }

                currentPath = parentPath;
            }
        }

        // 2. Sort paths by depth (deepest first) to ensure bottom-up calculation
        const sortedPaths = Array.from(pathsToRecalculate).sort((a, b) => {
            const depthA = a.split('/').length;
            const depthB = b.split('/').length;
            return depthB - depthA; // Sort descending by depth
        });

        // 3. Recalculate sequentially from deepest to shallowest
        for (const path of sortedPaths) {
            // Determine the correct children field based on the path structure
            let childrenField = null;
            if (path.includes('/greatGrandchildren/')) childrenField = 'greatGreatGrandchildren';
            else if (path.includes('/grandchildren/')) childrenField = 'greatGrandchildren';
            else if (path.includes('/children/')) childrenField = 'grandchildren';
            else if (path.startsWith('congViecMe')) childrenField = 'children'; // Root level

            await recalculateSingleParentCost(path, childrenField); // Pass the determined children field
        }

        // 4. Update 'daThucHien' status for relevant child nodes after costs are updated
        for (const childPath of pathsToCheckDaThucHien) {
             // Check based on the direct children first (grandchildren level)
             const childSnap = await get(ref(db, childPath));
             if (childSnap.exists() && childSnap.val().grandchildren) {
                await checkAndUpdateDaThucHien(childPath);
             } else {
                 // If no grandchildren, check if the child itself has executions (shouldn't happen with current structure, but safe check)
                  const execSnapshot = await get(ref(db, `${childPath}/executions`));
                  await update(ref(db), { [`${childPath}/daThucHien`]: execSnapshot.exists() && Object.keys(execSnapshot.val()).length > 0 });
             }

        }
    };

  /**
 * HÀM CẬP NHẬT: recalculateSingleParentCost
 * Đã bổ sung logic cộng dồn 'chiPhiPhanBo' từ con lên cha.
 */
const recalculateSingleParentCost = async (parentPath, childrenField = null, fieldsToRecalculate = ['chiPhi', 'chiPhiThucHien', 'keHoachConLai', 'khNamTruoc', 'thucHienNamTruoc', 'chiPhiPhanBo']) => {
    const parentRef = ref(db, parentPath);
    const parentSnap = await get(parentRef);
    if (!parentSnap.exists()) {
         console.warn(`[recalcSingle] Parent path ${parentPath} not found.`);
         return;
    }

    const parentData = parentSnap.val();
    let isLeafNode = false;
    let childrenData = {};

    // --- Xác định rõ ràng nút lá ---
    const pathSegments = parentPath.split('/');
    const nodeLevelName = pathSegments[pathSegments.length - 2];
    const parentId = pathSegments[pathSegments.length - 1];

    if (nodeLevelName === 'greatGreatGrandchildren') {
        isLeafNode = true; // Cấp 5 luôn là lá
    } else if (nodeLevelName === 'greatGrandchildren' && parentData.hasChildren !== true) {
        isLeafNode = true; // Cấp 4 là lá nếu không có hasChildren: true
    } else {
         // Nếu không phải lá, cố gắng lấy dữ liệu con để tính tổng
        if (childrenField && parentData[childrenField]) {
            childrenData = parentData[childrenField];
        } else {
             childrenData = {}; // Không tìm thấy con hợp lệ
        }
    }

    const updates = {};
    let shouldUpdate = false;

    // --- Tính toán giá trị ---
    if (isLeafNode) {
        // **XỬ LÝ NÚT LÁ:**
        const currentChiPhi = parentData.chiPhi || 0;
        const currentChiPhiThucHien = parentData.chiPhiThucHien || 0;
        
        // 1. Tính lại Kế hoạch còn lại
        const newKeHoachConLai = currentChiPhi - currentChiPhiThucHien;
        if (parentData.keHoachConLai !== newKeHoachConLai) {
            updates[`${parentPath}/keHoachConLai`] = newKeHoachConLai;
            shouldUpdate = true;
        }
        
        // 2. Tính lại CP Phân Bổ (Dựa trên Năm phân bổ của chính nó)
        const nam = parentData.namPhanBo || 0;
        const newCpPb = (nam > 0) ? Math.round(currentChiPhi / nam) : 0;
        if (parentData.chiPhiPhanBo !== newCpPb) {
            updates[`${parentPath}/chiPhiPhanBo`] = newCpPb;
            shouldUpdate = true;
        }

    } else {
        // **XỬ LÝ NÚT CHA:**
        // Khởi tạo biến tổng bao gồm cả chiPhiPhanBo
        const total = { 
            chiPhi: 0, 
            chiPhiThucHien: 0, 
            khNamTruoc: 0, 
            thucHienNamTruoc: 0,
            chiPhiPhanBo: 0 // <--- MỚI
        };

        if (typeof childrenData === 'object' && childrenData !== null) {
            for (const childId in childrenData) {
                if (typeof childrenData[childId] === 'object' && childrenData[childId] !== null) {
                    const child = childrenData[childId];
                    total.chiPhi += child.chiPhi || 0;
                    total.chiPhiThucHien += child.chiPhiThucHien || 0;
                    total.khNamTruoc += child.khNamTruoc || 0;
                    total.thucHienNamTruoc += child.thucHienNamTruoc || 0;
                    // === CỘNG DỒN CP PHÂN BỔ ===
                    total.chiPhiPhanBo += (parseFloat(child.chiPhiPhanBo) || 0);
                }
            }
        }
        
        // Cập nhật các trường nếu tổng tính được khác với giá trị hiện tại
        fieldsToRecalculate.forEach(field => {
            if (field === 'keHoachConLai') return; // Tính riêng

            if (parentData[field] !== total[field]) {
                updates[`${parentPath}/${field}`] = total[field];
                shouldUpdate = true;
            }
        });

        // Luôn tính lại keHoachConLai cho nút cha
        const newChiPhi = updates[`${parentPath}/chiPhi`] !== undefined ? updates[`${parentPath}/chiPhi`] : (parentData.chiPhi || 0);
        const newChiPhiThucHien = updates[`${parentPath}/chiPhiThucHien`] !== undefined ? updates[`${parentPath}/chiPhiThucHien`] : (parentData.chiPhiThucHien || 0);
        const newKeHoachConLai = newChiPhi - newChiPhiThucHien;

        if (parentData.keHoachConLai !== newKeHoachConLai) {
            updates[`${parentPath}/keHoachConLai`] = newKeHoachConLai;
            shouldUpdate = true;
        }
    }

    // Chỉ ghi vào DB nếu có thay đổi
    if (shouldUpdate) {
        await update(ref(db), updates);
    }
};
    // kết thúc recalculateCostsForParents ở đây


    const recalculateCostsAfterJustificationChange = async (leafNodePaths) => {
    console.log("Entering recalculateCostsAfterJustificationChange with:", leafNodePaths);

    const pathsToProcess = Array.isArray(leafNodePaths) ? leafNodePaths : [leafNodePaths];
    if (pathsToProcess.length === 0) {
         console.log("No paths to process in recalculateCostsAfterJustificationChange. Exiting.");
         return;
    }

    const pathsForParentRecalc = new Set();

    try {
        for (const leafNodePath of pathsToProcess) {
            console.log(`Processing justification parent task: ${leafNodePath}`);
            pathsForParentRecalc.add(leafNodePath);

            const justSnapshot = await get(ref(db, `${leafNodePath}/justifications`));
            const leafNodeSnap = await get(ref(db, leafNodePath)); // Lấy dữ liệu nút lá hiện tại

            let calculatedTotalChiPhiForLeaf = 0; // Tổng chi phí TÍNH TOÁN ĐƯỢC từ giải trình
            const updatesForThisLeaf = {}; // Các cập nhật cần thực hiện cho nút lá và giải trình con
            let leafChiPhiNeedsUpdate = false; // Cờ báo hiệu chiPhi của nút lá có cần cập nhật không

            if (leafNodeSnap.exists()) {
                const leafNodeData = leafNodeSnap.val();
                let currentLeafChiPhi = leafNodeData.chiPhi || 0; // Lấy chiPhi hiện tại của nút lá

                if (justSnapshot.exists()) {
                    // --- CHỈ THỰC HIỆN KHI CÓ GIẢI TRÌNH ---
                    leafChiPhiNeedsUpdate = true; // Đánh dấu cần cập nhật chiPhi của lá
                    const justificationsData = justSnapshot.val();

                    // Duyệt qua giải trình Cấp 1 (a, b, c...)
                    for (const justId in justificationsData) {
                        const justificationL1 = justificationsData[justId];
                        const justificationL1Path = `${leafNodePath}/justifications/${justId}`;
                        let costForThisL1 = 0;

                        if (justificationL1.hasSubJustifications === true && justificationL1.subJustifications) {
                            let totalSubCost = 0;
                            for (const subId in justificationL1.subJustifications) {
                                totalSubCost += justificationL1.subJustifications[subId].chiPhi || 0;
                            }
                            costForThisL1 = totalSubCost;

                            if (justificationL1.chiPhi !== costForThisL1) {
                                console.log(`Updating L1 justification chiPhi at ${justificationL1Path} to ${costForThisL1}`);
                                updatesForThisLeaf[`${justificationL1Path}/chiPhi`] = costForThisL1;
                            }
                        } else {
                            costForThisL1 = justificationL1.chiPhi || 0;
                        }
                        calculatedTotalChiPhiForLeaf += costForThisL1;
                    } // Kết thúc duyệt giải trình Cấp 1

                    // Cập nhật chiPhi của nút lá BẰNG tổng chi phí giải trình
                    console.log(`Updating chiPhi for leaf task ${leafNodePath} FROM justifications to ${calculatedTotalChiPhiForLeaf}`);
                    updatesForThisLeaf[`${leafNodePath}/chiPhi`] = calculatedTotalChiPhiForLeaf;
                    currentLeafChiPhi = calculatedTotalChiPhiForLeaf; // Cập nhật giá trị để tính keHoachConLai

                } else {
                    // --- KHÔNG CÓ GIẢI TRÌNH ---
                     console.log(`No justifications found for leaf task ${leafNodePath}. chiPhi remains ${currentLeafChiPhi}.`);
                     // Không cập nhật chiPhi, giữ nguyên giá trị hiện có (currentLeafChiPhi)
                     // leafChiPhiNeedsUpdate vẫn là false
                }

                // Luôn tính lại KẾ HOẠCH CÒN LẠI dựa trên chiPhi (dù được cập nhật hay giữ nguyên)
                const chiPhiThucHien = leafNodeData.chiPhiThucHien || 0;
                const newKeHoachConLai = currentLeafChiPhi - chiPhiThucHien;
                 if (leafNodeData.keHoachConLai !== newKeHoachConLai || updatesForThisLeaf[`${leafNodePath}/chiPhi`] !== undefined) {
                      // Cập nhật keHoachConLai nếu nó thay đổi HOẶC nếu chiPhi đã thay đổi
                      updatesForThisLeaf[`${leafNodePath}/keHoachConLai`] = newKeHoachConLai;
                      console.log(`Updating keHoachConLai for leaf task ${leafNodePath} to ${newKeHoachConLai}`);
                 }

            } else {
                 console.warn(`Leaf node ${leafNodePath} not found during justification recalc.`);
            }


            // Ghi tất cả các thay đổi (chỉ ghi nếu updatesForThisLeaf không rỗng)
            if (Object.keys(updatesForThisLeaf).length > 0) {
                console.log(`Applying updates for ${leafNodePath}:`, updatesForThisLeaf);
                await update(ref(db), updatesForThisLeaf);
                console.log(`Firebase update successful for justifications under ${leafNodePath}`);
            } else {
                 console.log(`No updates needed for ${leafNodePath} or its justifications.`);
            }

        } // Kết thúc vòng lặp qua pathsToProcess

        // Gọi lan truyền lên cha
        const finalPathsArray = Array.from(pathsForParentRecalc);
        if (finalPathsArray.length > 0) {
             console.log("Calling recalculateCostsForParents with paths:", finalPathsArray);
             await recalculateCostsForParents(finalPathsArray);
             console.log("recalculateCostsForParents finished successfully inside recalculateCostsAfterJustificationChange.");
        } else {
            console.log("No paths require parent recalculation from justifications.");
        }

    } catch (innerError) {
         console.error(`Error INSIDE recalculateCostsAfterJustificationChange processing paths ${leafNodePaths}:`, innerError);
         throw innerError; // Ném lỗi ra ngoài
    }
    console.log("Exiting recalculateCostsAfterJustificationChange successfully.");
};
    
// Ensure checkAndUpdateDaThucHien is robust
     const checkAndUpdateDaThucHien = async (childPath) => {
        const childRef = ref(db, childPath);
        const childSnap = await get(childRef);
        if (!childSnap.exists()) return;

        const childData = childSnap.val();
        let hasExecutions = false;

        // Recursive function to check for executions down the tree
        const findExecutions = async (node, currentPath) => {
            if (hasExecutions) return; // Stop searching if already found

            // Check current node for executions if it's a leaf node type
            // Sửa lại điều kiện kiểm tra lá: dựa vào hasChildren hoặc sự tồn tại của các collection con
            const isPotentiallyLeaf = !(node.hasChildren === true || node.children || node.grandchildren || node.greatGrandchildren || node.greatGreatGrandchildren);

            if (isPotentiallyLeaf) {
                 const execRef = ref(db, `${currentPath}/executions`);
                 const execSnapshot = await get(execRef);
                 if (execSnapshot.exists() && Object.keys(execSnapshot.val()).length > 0) {
                    hasExecutions = true;
                    //console.log(`Executions found at leaf: ${currentPath}`);
                    return;
                 }
            }

            // Recursively check children collections (sử dụng for...in vì cấu trúc là object)
            if (node.grandchildren) {
                for (const id in node.grandchildren) {
                    // Cần lấy dữ liệu con đầy đủ để kiểm tra tiếp
                    const grandchildNodeSnap = await get(ref(db, `${currentPath}/grandchildren/${id}`));
                    if(grandchildNodeSnap.exists()) await findExecutions(grandchildNodeSnap.val(), `${currentPath}/grandchildren/${id}`);
                    if (hasExecutions) return;
                }
            }
            if (node.greatGrandchildren) {
                 for (const id in node.greatGrandchildren) {
                    const greatGrandchildNodeSnap = await get(ref(db, `${currentPath}/greatGrandchildren/${id}`));
                    if(greatGrandchildNodeSnap.exists()) await findExecutions(greatGrandchildNodeSnap.val(), `${currentPath}/greatGrandchildren/${id}`);
                    if (hasExecutions) return;
                }
            }
             if (node.greatGreatGrandchildren) {
                 for (const id in node.greatGreatGrandchildren) {
                    // Cấp 5 là lá, kiểm tra trực tiếp executions
                     const execRef = ref(db, `${currentPath}/greatGreatGrandchildren/${id}/executions`);
                     const execSnapshot = await get(execRef);
                     if (execSnapshot.exists() && Object.keys(execSnapshot.val()).length > 0) {
                        hasExecutions = true;
                        //console.log(`Executions found at greatGreatGrandchild: ${currentPath}/greatGreatGrandchildren/${id}`);
                        return;
                     }
                 }
             }
        };

        // Start the recursive check from the child node
        await findExecutions(childData, childPath);

        // Update the daThucHien status only if it changed
        if (childData.daThucHien !== hasExecutions) {
             //console.log(`Updating ${childPath}/daThucHien to ${hasExecutions}`);
            await update(ref(db), { [`${childPath}/daThucHien`]: hasExecutions });
        }
     }; // <-- Đóng hàm checkAndUpdateDaThucHien ở đây

  const calculateSummaryData = async () => {
        try {
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đang tính toán dữ liệu tổng hợp...';
            const parentQuery = ref(db, getParentCollectionName());
            const parentSnapshot = await get(parentQuery);
            if (!parentSnapshot.exists()) {
                // If no data exists for the year, clear summary and exit
                const summaryRef = ref(db, `summary_data/${currentYear}`);
                await set(summaryRef, null); 
                statusDiv.innerText = ''; 
                document.getElementById('summarySection').innerHTML = '<p>Không có dữ liệu tổng hợp cho năm này.</p>';
                return; 
            }

            const parentsData = parentSnapshot.val();
            const summaryData = {};

            // Initialize summary data structure for all parents first
            for (const parentId in parentsData) {
                 summaryData[parentId] = {
                     totalLeafNodes: 0,
                     totalExecutedLeafNodes: 0,
                     totalLeafNodesCap1: 0,
                     totalExecutedLeafNodesCap1: 0,
                     totalPlannedCost: parentsData[parentId].chiPhi || 0, 
                     totalExecutedCost: parentsData[parentId].chiPhiThucHien || 0 
                 };
            }


            const processNode = (node, path) => {
                if (node && node.tt) { 
                    const parentId = path.split('/')[1];
                    const parentSummary = summaryData[parentId]; 
                    if (!parentSummary) return; 

                    // --- Logic xác định lá và tính toán ---
                    const hasL5Children = node.greatGreatGrandchildren && Object.keys(node.greatGreatGrandchildren).length > 0;
                    const hasL4Children = node.greatGrandchildren && Object.keys(node.greatGrandchildren).length > 0;
                    const hasL3Children = node.grandchildren && Object.keys(node.grandchildren).length > 0;
                    const hasL2Children = node.children && Object.keys(node.children).length > 0;

                    let isContainer = false;
                    if (node.hasChildren === true) {
                        isContainer = true; 
                    } else if (node.hasChildren === false) {
                        isContainer = false; 
                    } else {
                        isContainer = hasL2Children || hasL3Children || hasL4Children || hasL5Children;
                    }

                    const pathLength = path.split('/').length;

                    // --- BẮT ĐẦU LOGIC TÍNH TOÁN (CẬP NHẬT) ---
                    if (!isContainer && pathLength > 2) { 
                        
                        // 1. Tính plannedCount (Số lượng kế hoạch)
                        let plannedCount;
                        const tanSuat = node.tanSuatTH; 

                        if (tanSuat === 0) {
                             plannedCount = 0; 
                        } else {
                             plannedCount = parseInt(tanSuat, 10);
                             if (isNaN(plannedCount) || tanSuat === null || tanSuat === undefined || tanSuat === '') {
                                 plannedCount = 1;
                             }
                        }
                        
                        parentSummary.totalLeafNodes += plannedCount;

                        // 2. Tính executedCount (Số lượng đã thực hiện)
                        let executedCount = 0;

                        // === LOGIC MỚI: XỬ LÝ RIÊNG CHO CHI PHÍ = 0 ===
                        if ((node.chiPhi || 0) === 0) {
                             // Nếu chi phí = 0, chỉ tính là thực hiện nếu có Link Hồ sơ
                             let validExecutionsWithLink = 0;
                             if (node.executions) {
                                 for (const key in node.executions) {
                                     const exec = node.executions[key];
                                     // Kiểm tra hoSoLink có tồn tại và không rỗng
                                     if (exec.hoSoLink && exec.hoSoLink.trim() !== '') {
                                         validExecutionsWithLink++;
                                     }
                                 }
                             }

                             if (plannedCount > 1) {
                                 executedCount = Math.min(plannedCount, validExecutionsWithLink);
                             } else if (plannedCount === 1) {
                                 executedCount = validExecutionsWithLink > 0 ? 1 : 0;
                             }
                        } 
                        // === LOGIC CŨ: DÀNH CHO CHI PHÍ > 0 ===
                        else {
                            if (plannedCount > 1) {
                                const actualExecutionCount = node.executions ? Object.keys(node.executions).length : 0;
                                executedCount = Math.min(plannedCount, actualExecutionCount);
                            } else if (plannedCount === 1) {
                                executedCount = node.chiPhiThucHien > 0 ? 1 : 0;
                            } 
                        }
                        // ===============================================

                        parentSummary.totalExecutedLeafNodes += executedCount;

                        // 3. Xử lý cho cấp độ 1
                        if (node.capDo == 1) {
                            parentSummary.totalLeafNodesCap1 += plannedCount;
                            parentSummary.totalExecutedLeafNodesCap1 += executedCount;
                        }
                    }
                } 

                // --- Đệ quy xuống các cấp con ---
                if (node.children) {
                    for (const childId in node.children) processNode(node.children[childId], `${path}/children/${childId}`);
                }
                if (node.grandchildren) {
                    for (const grandchildId in node.grandchildren) processNode(node.grandchildren[grandchildId], `${path}/grandchildren/${grandchildId}`);
                }
                if (node.greatGrandchildren) {
                    for (const greatGrandchildId in node.greatGrandchildren) processNode(node.greatGrandchildren[greatGrandchildId], `${path}/greatGrandchildren/${greatGrandchildId}`);
                }
                if (node.greatGreatGrandchildren) {
                    for (const gggcId in node.greatGreatGrandchildren) processNode(node.greatGreatGrandchildren[gggcId], `${path}/greatGreatGrandchildren/${gggcId}`);
                }
            };
            
            for (const parentId in parentsData) {
                processNode(parentsData[parentId], `${getParentCollectionName()}/${parentId}`);
            }

            const summaryRef = ref(db, `summary_data/${currentYear}`);
            await set(summaryRef, summaryData);
            statusDiv.innerText = ''; 
            
            fetchData(); 

        } catch (error) {
            console.error("Lỗi khi tính toán dữ liệu tổng hợp:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi khi tính toán summary: ${error.message}`;
        }
    };



    async function ensureYearCollectionExists(year) {
        const collectionName = `congViecMe${year}`;
        try {
            const testQuery = ref(db, collectionName);
            const testSnapshot = await get(testQuery);
            if (!testSnapshot.exists()) {
                console.log(`Collection cho năm ${year} chưa tồn tại, sẽ được tạo khi có dữ liệu`);
            }
        } catch (error) {
            console.log(`Collection cho năm ${year} chưa tồn tại, sẽ được tạo khi có dữ liệu`);
        }
    }

    const planningPasswords = {
        'all': '2662', 'A': '8726', 'B': '8646', 'C': '8734',
        'D': '8663', 'E': '8853', 'F': '3822'
    };

    function openPlanningModeModal() {
        const modal = document.getElementById('planningModeModal');
        const optionsContainer = document.getElementById('planningModeOptions');
        optionsContainer.innerHTML = '';

        const allButton = document.createElement('button');
        allButton.className = 'btn-primary';
        allButton.textContent = 'Tất cả dữ liệu';
        allButton.style.cssText = 'width: 100%; margin-bottom: 10px; text-align: left; padding: 12px;';
        allButton.onclick = () => promptForPlanningPassword('all', 'Tất cả dữ liệu');
        optionsContainer.appendChild(allButton);

        const parentRows = document.querySelectorAll('.task-parent');
        parentRows.forEach(row => {
            const tt = row.querySelector('.col-tt').textContent;
            const noiDung = row.querySelector('.col-noidung').textContent;
            const parentButton = document.createElement('button');
            parentButton.className = 'btn-secondary';
            parentButton.textContent = `${tt}. ${noiDung}`;
            parentButton.style.cssText = 'width: 100%; margin-bottom: 10px; text-align: left; padding: 12px;';
            parentButton.onclick = () => promptForPlanningPassword(tt, `${tt}. ${noiDung}`);
            optionsContainer.appendChild(parentButton);
        });

        modal.style.display = 'block';
    }

    window.promptForPlanningPassword = function(selectionId, selectionText) {
        const correctPassword = planningPasswords[selectionId];
        if (!correctPassword) {
            activatePlanningModeForSelection(selectionId);
            return;
        }

        const enteredPassword = prompt(`Vui lòng nhập mật khẩu để xem phạm vi:\n"${selectionText}"`);

        if (enteredPassword === null) {
            return;
        }

        if (enteredPassword === correctPassword) {
            activatePlanningModeForSelection(selectionId);
        } else {
            alert('Mật khẩu không chính xác.');
        }
    };

    window.closePlanningModal = function() {
        document.getElementById('planningModeToggle').checked = false;
        document.getElementById('planningModeModal').style.display = 'none';
    }

    function activatePlanningModeForSelection(selectionId) {
        const taskList = document.getElementById('taskList');
        planningModeByYear[currentYear] = true;

        taskList.classList.add('planning-mode');
        document.getElementById('exportExcel1Btn').disabled = true;
        document.getElementById('exportExcel2Btn').disabled = false;

        const allRows = document.querySelectorAll('#taskListBody tr');
        allRows.forEach(row => {
            if (selectionId === 'all' || row.dataset.mainParent === selectionId) {
                row.style.display = '';
            } else {
                row.style.display = 'none';
            }
        });

        document.getElementById('planningModeModal').style.display = 'none';
    }

   // XỬ LÝ AUTH STATE
    onAuthStateChanged(auth, async (user) => {
        const authButton = document.getElementById('authButton');
        const logoutButton = document.getElementById('logoutButton');

        if (user) {
            // --- TRƯỜNG HỢP ĐÃ ĐĂNG NHẬP ---
            isAuthenticated = true;
            if (authButton) authButton.style.display = 'none';
            if (logoutButton) logoutButton.style.display = 'inline-block';

            loginContainer.style.display = 'none';
            mainContainer.style.display = 'block';

            // Logic lắng nghe trạng thái khóa/mở (Giữ nguyên)
            const settingsRef = ref(db, 'settings/global');
            onValue(settingsRef, (snapshot) => {
                if (snapshot.exists()) {
                    editModeStatusByYear = snapshot.val().editModeStatus || {};
                } else {
                    editModeStatusByYear = {};
                }
                
                const modal = document.getElementById('dataManagementModal');
                if (modal.style.display === 'block') {
                     const isUnlocked = editModeStatusByYear[currentYear] === true;
                     if (isUnlocked) {
                         document.getElementById('unlockButton').style.display = 'none';
                         document.getElementById('editModeToggle').style.display = 'block';
                         document.getElementById('editModeCheckbox').checked = true;
                     }
                }
                updateButtonStates();
            });

            // === CẬP NHẬT QUAN TRỌNG TẠI ĐÂY ===
            // Thay vì gọi fetchData(), ta gọi recalculateAllCostsAndReload(false)
            // Tham số 'false' nghĩa là chạy ngay lập tức KHÔNG hiện bảng hỏi "Confirm"
            // Hàm này đã bao gồm bước fetchData() ở cuối cùng nên không cần gọi lại.
            
            // Hiển thị thông báo đang xử lý để người dùng biết
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đăng nhập thành công. Đang rà soát và tính toán lại dữ liệu...';
            
            await recalculateAllCostsAndReload(false); 
            // ====================================

        } else {
            // --- TRƯỜNG HỢP CHƯA ĐĂNG NHẬP / ĐĂNG XUẤT ---
            isAuthenticated = false;
            if (authButton) authButton.style.display = 'inline-block';
            if (logoutButton) logoutButton.style.display = 'none';
            mainContainer.style.display = 'block';
            loginContainer.style.display = 'none';
            
            // Người xem bình thường chỉ cần tải dữ liệu hiển thị (nhanh hơn)
            fetchData();
        }
    });

    // XỬ LÝ LOGIN FORM
    loginForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = document.getElementById('email').dataset.realEmail;
        const password = document.getElementById('password').value;
        const loginButton = loginForm.querySelector('button');
        loginError.style.display = 'none';
        loginButton.disabled = true;
        loginButton.textContent = 'Đang xử lý...';
        try {
            await signInWithEmailAndPassword(auth, email, password);
        } catch (error) {
            console.error("Lỗi đăng nhập:", error);
            let errorMessage = "Đã xảy ra lỗi. Vui lòng thử lại.";
            if (error.code === 'auth/invalid-credential') errorMessage = "Mật khẩu không chính xác.";
            loginError.textContent = errorMessage;
            loginError.style.display = 'block';
        } finally {
            loginButton.disabled = false;
            loginButton.textContent = 'Đăng nhập';
        }
    });

    // KHỞI TẠO ỨNG DỤNG
  // KHỞI TẠO ỨNG DỤNG
    window.addEventListener('DOMContentLoaded', async function() { // Thêm async ở đây
        // === THÊM ĐOẠN NÀY ĐỂ ĐĂNG XUẤT KHI TẢI TRANG ===
        try {
            await signOut(auth); // Thực hiện đăng xuất
            console.log('Đã tự động đăng xuất người dùng cũ (nếu có).');
        } catch (error) {
            console.error('Lỗi khi tự động đăng xuất:', error);
            // Bạn có thể thêm thông báo lỗi cho người dùng ở đây nếu cần
            // statusDiv.className = 'error';
            // statusDiv.innerText = 'Lỗi khi đăng xuất phiên cũ: ' + error.message;
        }
        // ===============================================

        // Các hàm khởi tạo khác
        initializeYearDropdown();
        // fetchData(); // Không gọi trực tiếp ở đây nữa, onAuthStateChanged sẽ xử lý
        initializeGoogleClients();

        // Gán sự kiện double click cho bảng (cho sửa nội tuyến)
        const taskListBody = document.getElementById('taskListBody');
        if (taskListBody) {
            taskListBody.addEventListener('dblclick', makeCellEditable);
        }

        // --- Quản lý việc chạy calculateSummaryData ---
        let summaryIntervalId = null; // Biến để lưu ID của interval

        // Hàm để bắt đầu tính summary và đặt lịch chạy định kỳ
        function startSummaryInterval() {
             if (summaryIntervalId) clearInterval(summaryIntervalId); // Xóa interval cũ nếu đang chạy
             // Chạy tính toán lần đầu (nên đợi fetchData xong)
             // calculateSummaryData(); // Chạy ngay có thể gây lỗi nếu fetchData chưa xong
             // Đặt lịch chạy định kỳ 5 phút một lần
             summaryIntervalId = setInterval(calculateSummaryData, 300000);
        }

        // Hàm dừng tính summary định kỳ (ví dụ khi đăng xuất)
        function stopSummaryInterval() {
            if (summaryIntervalId) {
                clearInterval(summaryIntervalId);
                summaryIntervalId = null;
            }
        }
        // --- Kết thúc quản lý calculateSummaryData ---


        // Gọi startSummaryInterval hoặc các xử lý khác sau khi dữ liệu được tải
        // (thông qua onAuthStateChanged)

    }); // Kết thúc DOMContentLoaded


    // XỬ LÝ AUTH STATE (Vẫn giữ nguyên hàm này để xử lý sau khi signOut chạy xong)
    onAuthStateChanged(auth, user => {
        const authButton = document.getElementById('authButton');
        const logoutButton = document.getElementById('logoutButton');

        if (user) {
            // Người dùng đăng nhập (Trường hợp này sẽ không xảy ra ngay sau khi tải trang vì đã signOut)
            isAuthenticated = true;
            if (authButton) authButton.style.display = 'none';
            if (logoutButton) logoutButton.style.display = 'inline-block';

            loginContainer.style.display = 'none';
            mainContainer.style.display = 'block';

            const settingsRef = ref(db, 'settings/global');
            onValue(settingsRef, (snapshot) => {
                if (snapshot.exists()) {
                    editModeStatusByYear = snapshot.val().editModeStatus || {};
                } else {
                    editModeStatusByYear = {};
                }
                updateButtonStates();
            });
            // Tải dữ liệu và sau đó bắt đầu tính summary
            fetchData().then(() => {
                // Có thể gọi calculateSummaryData() lần đầu ở đây nếu muốn
                // calculateSummaryData();
                // startSummaryInterval(); // Bắt đầu chạy định kỳ
            });
        } else {
            // Người dùng đã đăng xuất (Đây là trạng thái sau khi signOut trong DOMContentLoaded chạy)
            isAuthenticated = false;
            if (authButton) authButton.style.display = 'inline-block';
            if (logoutButton) logoutButton.style.display = 'none';

            mainContainer.style.display = 'block';
            loginContainer.style.display = 'none';
            // Vẫn tải dữ liệu ở chế độ chỉ xem
            fetchData().then(() => {
                 // Có thể gọi calculateSummaryData() lần đầu ở đây nếu muốn
                 // calculateSummaryData();
                 // startSummaryInterval(); // Bắt đầu chạy định kỳ (nếu cần xem summary khi chưa đăng nhập)
            });
            updateButtonStates(); // Cập nhật trạng thái nút (sẽ vô hiệu hóa các nút sửa/xóa)
            // stopSummaryInterval(); // Dừng tính summary định kỳ nếu không cần khi đăng xuất
        }
    });

 

/**
 * Biến một ô <td> thành <input> để chỉnh sửa nội tuyến.
 */
/**
 * Xử lý sự kiện nhấn phím Enter (lưu) và Escape (hủy)
 */
function handleInputKeydown(event) {
    // Sử dụng event.key thay vì keyCode
    if (event.key === 'Enter') {
        event.preventDefault(); // Ngăn hành vi mặc định của Enter
        event.target.blur();    // Kích hoạt sự kiện 'blur' (làm mất focus)
    } else if (event.key === 'Escape') {
        event.preventDefault(); // Ngăn hành vi mặc định của Escape
        // Đặt lại giá trị gốc *trước khi* làm mất focus
        event.target.value = event.target.dataset.originalValue; 
        event.target.blur();    // Kích hoạt 'blur'
    }
}

function makeCellEditable(event) {
    const td = event.target.closest('.editable-cell');
    if (!td) return; // Không phải ô có thể sửa

    // Ngăn người dùng sửa khi không có quyền
    if (!isAuthenticated || editModeStatusByYear[currentYear] !== true) {
        showAuthError();
        return;
    }

    // Ngăn nhấp đúp nếu ô đang ở chế độ chỉnh sửa
    if (td.querySelector('.editable-input')) {
        return;
    }

    const tr = td.closest('tr');
    const path = tr.dataset.path;
    const field = td.dataset.field;
    
    if (!path || !field) {
        console.error("Thiếu data-path trên <tr> hoặc data-field trên <td>");
        return;
    }

    const originalValue = td.textContent;
    
    // Tạo input
    const input = document.createElement('input');
    input.type = 'text';
    input.className = 'editable-input';
    input.value = originalValue;
    
    // Gán dữ liệu vào input để hàm saveInlineEdit có thể truy cập
    input.dataset.path = path;
    input.dataset.field = field;
    input.dataset.originalValue = originalValue;

    // Gán sự kiện
    input.onblur = saveInlineEdit; // Lưu khi mất focus (click ra ngoài)
    input.onkeydown = handleInputKeydown; // Chỉ xử lý phím

    // Thay thế nội dung <td> bằng <input>
    td.innerHTML = '';
    td.appendChild(input);
    input.focus();
    input.select();
}



/**
 * Lưu hoặc hủy bỏ chỉnh sửa nội tuyến (CHỈ CHẠY KHI BLUR).
 * Đã nâng cấp để xử lý Năm phân bổ và Thực hiện năm trước.
 */
/**
 * Lưu hoặc hủy bỏ chỉnh sửa nội tuyến (CHỈ CHẠY KHI BLUR).
 * Đã nâng cấp để xử lý Năm phân bổ mặc định = 1.
 */
async function saveInlineEdit(event) {
    const input = event.target;
    if (!input.parentNode) return; 

    const td = input.closest('td');
    if (!td) return;

    const path = input.dataset.path;
    const field = input.dataset.field;
    const originalValue = input.dataset.originalValue;
    const newValue = input.value;

    if (newValue === originalValue) {
        td.innerHTML = originalValue; 
        return;
    }

    try {
        td.innerHTML = '<i>Đang lưu...</i>';
        const updates = {};
        let valueToSave = newValue;
        let formattedDisplay = newValue;

        if (['namPhanBo', 'thucHienNamTruoc', 'soLuong', 'donGia'].includes(field)) {
            valueToSave = parseFormattedNumber(newValue); 
            
            // === CẬP NHẬT: Mặc định namPhanBo = 1 ===
            if (field === 'namPhanBo') {
                if (newValue.trim() === '' || valueToSave == 0) valueToSave = 1;
                formattedDisplay = valueToSave;
            } else {
                formattedDisplay = formatNumber(valueToSave);
            }
            // =========================================
        }

        updates[`${path}/${field}`] = valueToSave;

        if (field === 'namPhanBo') {
            const nodeSnap = await get(ref(db, path));
            if (nodeSnap.exists()) {
                const nodeData = nodeSnap.val();
                const chiPhi = nodeData.chiPhi || 0;
                const nam = valueToSave; 
                
                const cpPb = (nam > 0) ? Math.round(chiPhi / nam) : 0;
                updates[`${path}/chiPhiPhanBo`] = cpPb;

                const tr = td.closest('tr');
                const cpPbCell = tr.querySelector('.col-chiphi-phanbo');
                if (cpPbCell) {
                    cpPbCell.textContent = formatNumber(cpPb);
                    cpPbCell.style.backgroundColor = '#ffffcc';
                    setTimeout(() => cpPbCell.style.backgroundColor = '', 1000);
                }
            }
        }

        await update(ref(db), updates);
        td.innerHTML = formattedDisplay;

    } catch (error) {
        console.error("Lỗi khi cập nhật nội tuyến:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi: ${error.message}`;
        try { td.innerHTML = originalValue; } catch (e) {}
    }
}

// ============================================================
    // BỘ HÀM TRA CỨU - SỬA - XÓA - UPLOAD (ĐÃ ĐỒNG BỘ CẤU TRÚC MAP)
    // ============================================================

    // 1. Modal Tra Cứu (Hiển thị phân cấp L2 -> L4 -> L5)
    window.openSearchModal = async function() {
        const modal = document.getElementById('dataModal');
        const title = 'Tra cứu thực hiện công việc';
        document.getElementById('modalTitle').innerHTML = `<h2>${title}</h2>`;

        const headers = [
            {text: 'Ngày thực hiện', width: '12%'},
            {text: 'Nội dung công việc', width: '48%'},
            {text: 'ĐV thực hiện', width: '10%'},
            {text: 'Thành tiền', width: '15%'},
            {text: 'Hành động', width: '15%'}
        ];
        let table = createModalTable(headers);
        table += '</tbody></table>';
        document.getElementById('modalBody').innerHTML = table;
        document.getElementById('modalSaveButton').style.display = 'none';
        document.getElementById('modalDeleteButton').style.display = 'none';
        document.getElementById('modal-footer-left').innerHTML = '<button class="btn-success" onclick="exportExecutionSearchExcel()">Xuất Excel</button>';
        modal.style.display = 'block';

        try {
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đang tải dữ liệu thực hiện...';
            
            // Reset biến toàn cục
            executionGroups = new Map(); 

            const parentQuery = ref(db, getParentCollectionName());
            const parentSnapshot = await get(parentQuery);
            if (!parentSnapshot.exists()) {
                document.getElementById('modalBody').innerHTML = '<p>Không có dữ liệu thực hiện.</p>';
                statusDiv.innerText = '';
                return;
            }

            const parentsData = parentSnapshot.val();
            const allExecutions = [];

            // Helper đệ quy để lấy toàn bộ executions
            const processNodeForExecutions = (node, path) => {
                if (node.executions) {
                    const pathParts = path.split('/');
                    const isDeepLevel = pathParts.includes('greatGreatGrandchildren');
                    
                    // Lấy path Cấp 2 (Children)
                    const level2Path = pathParts.slice(0, 4).join('/');

                    // Lấy path Cha trực tiếp (Group Header)
                    let groupParentPath = '';
                    if (isDeepLevel) {
                        const parentIndex = pathParts.indexOf('greatGrandchildren') + 2; 
                        groupParentPath = pathParts.slice(0, parentIndex).join('/');
                    } else {
                        const parentIndex = pathParts.indexOf('grandchildren') + 2;
                        groupParentPath = pathParts.slice(0, parentIndex).join('/');
                    }

                    for (const execId in node.executions) {
                        const exec = node.executions[execId];
                        allExecutions.push({
                            ...exec,
                            path: `${path}/executions/${execId}`,
                            taskPath: path,
                            level2Path: level2Path,
                            groupParentPath: groupParentPath,
                            noiDung: node.noiDung || 'Không có tên',
                            dvThucHien: node.dvThucHien || ''
                        });
                    }
                }
                if (node.children) for (const k in node.children) processNodeForExecutions(node.children[k], `${path}/children/${k}`);
                if (node.grandchildren) for (const k in node.grandchildren) processNodeForExecutions(node.grandchildren[k], `${path}/grandchildren/${k}`);
                if (node.greatGrandchildren) for (const k in node.greatGrandchildren) processNodeForExecutions(node.greatGrandchildren[k], `${path}/greatGrandchildren/${k}`);
                if (node.greatGreatGrandchildren) for (const k in node.greatGreatGrandchildren) processNodeForExecutions(node.greatGreatGrandchildren[k], `${path}/greatGreatGrandchildren/${k}`);
            };

            for (const parentId in parentsData) {
                processNodeForExecutions(parentsData[parentId], `${getParentCollectionName()}/${parentId}`);
            }

            // Sắp xếp theo ngày giảm dần
            allExecutions.sort((a, b) => {
                const dateA = new Date(a.ngayThucHien || 0);
                const dateB = new Date(b.ngayThucHien || 0);
                if (dateB - dateA !== 0) return dateB - dateA;
                return (b.timestamp || 0) - (a.timestamp || 0);
            });

            // Gom nhóm vào Map
            allExecutions.forEach(exec => {
                const tsKey = String(exec.timestamp || exec.ngayThucHien);
                if (!executionGroups.has(tsKey)) executionGroups.set(tsKey, new Map());
                
                const l2Map = executionGroups.get(tsKey);
                if (!l2Map.has(exec.level2Path)) l2Map.set(exec.level2Path, new Map());
                
                const parentMap = l2Map.get(exec.level2Path);
                if (!parentMap.has(exec.groupParentPath)) parentMap.set(exec.groupParentPath, []);
                
                parentMap.get(exec.groupParentPath).push(exec);
            });

            // Render HTML
            let tbody = '';
            const sortedTimestamps = Array.from(executionGroups.keys()).sort((a, b) => {
                 const getFirst = (key) => {
                     const l2Map = executionGroups.get(key);
                     for(let pMap of l2Map.values()) for(let execs of pMap.values()) return execs[0];
                 };
                 const firstA = getFirst(a), firstB = getFirst(b);
                 const dateA = new Date(firstA?.ngayThucHien || 0), dateB = new Date(firstB?.ngayThucHien || 0);
                 if (dateB - dateA !== 0) return dateB - dateA;
                 return (firstB?.timestamp || 0) - (firstA?.timestamp || 0);
            });

            for (const tsKey of sortedTimestamps) {
                const l2Map = executionGroups.get(tsKey);
                const allExecsInTs = []; 
                for (const pMap of l2Map.values()) {
                    for (const execs of pMap.values()) allExecsInTs.push(...execs);
                }
                
                if (allExecsInTs.length === 0) continue;
                const firstExec = allExecsInTs[0];
                const totalThanhTien = allExecsInTs.reduce((sum, e) => sum + (e.thanhTien || 0), 0);
                
                let contentHtml = '';
                const sortedL2Paths = Array.from(l2Map.keys()).sort((a,b) => romanToNumber(a.split('/').pop()) - romanToNumber(b.split('/').pop()));

                for (const l2Path of sortedL2Paths) {
                    const parentMap = l2Map.get(l2Path);
                    let l2Name = 'Không xác định';
                    const l2Data = docDataMap.get(l2Path);
                    if (l2Data) l2Name = `${convertTTForDisplay(l2Data.tt)}. ${l2Data.noiDung}`;
                    else l2Name = l2Path.split('/').pop();

                    contentHtml += `<div style="color: #0056b3; font-weight: bold; margin-top: 5px;">${l2Name}</div>`;

                    const sortedParentPaths = Array.from(parentMap.keys()).sort();
                    for (const parentPath of sortedParentPaths) {
                        const execs = parentMap.get(parentPath);
                        let parentName = 'Không xác định';
                        const parentData = docDataMap.get(parentPath);
                        if (parentData) parentName = `${convertTTForDisplay(parentData.tt)}. ${parentData.noiDung}`;
                        else parentName = parentPath.split('/').pop();

                        contentHtml += `<div style="color: #333; font-weight: bold; padding-left: 15px;">${parentName}</div>`;
                        execs.forEach(exec => {
                             contentHtml += `<div style="padding-left: 30px; font-style: italic;">- ${exec.noiDung}</div>`;
                        });
                    }
                }

                const hasHoSoLink = allExecsInTs.some(e => e.hoSoLink && e.hoSoLink.trim() !== '');
                const hoSoButtonClass = hasHoSoLink ? 'btn-danger' : 'btn-info';
                const hoSoButtonText = hasHoSoLink ? 'Thay HS' : 'Hồ sơ';

                tbody += `<tr>
                    <td style="vertical-align: top;">${firstExec.ngayThucHien}</td>
                    <td style="vertical-align: top;">${contentHtml}</td>
                    <td style="vertical-align: top;">${firstExec.dvThucHien}</td>
                    <td class="text-right" style="vertical-align: top;">${formatNumber(totalThanhTien)}</td>
                    <td style="vertical-align: top;">
                        <button class="${hoSoButtonClass} btn-action btn-profile-exec" onclick="openExecutionProfile('${tsKey}')">${hoSoButtonText}</button>
                        <button class="btn-warning btn-action btn-edit-exec" onclick="openExecutionEdit('${tsKey}')">Sửa</button>
                    </td>
                </tr>`;
            }

            document.querySelector('#dataModal .modal-table tbody').innerHTML = tbody || '<tr><td colspan="5" class="text-center">Không tìm thấy dữ liệu.</td></tr>';
            statusDiv.innerText = '';
        } catch (error) {
            console.error("Lỗi tải dữ liệu thực hiện:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi: ${error.message}`;
        }
    };

    // 2. Modal Sửa (Safe Flattening & Null Check)
    window.openExecutionEdit = function(timestampKey) {
        if (!isAuthenticated) return showAuthError();
        const modal = document.getElementById('dataModal');
        const tsKey = String(timestampKey);

        // Kiểm tra biến toàn cục
        if (!executionGroups || !(executionGroups instanceof Map)) {
            alert("Dữ liệu chưa sẵn sàng. Vui lòng tải lại Modal Tra cứu.");
            return;
        }

        let group = [];
        if (executionGroups.has(tsKey)) {
            const l2Map = executionGroups.get(tsKey);
            if (l2Map) {
                for (const pMap of l2Map.values()) {
                    for (const execs of pMap.values()) {
                        if (Array.isArray(execs)) group.push(...execs);
                    }
                }
            }
        }

        // Check an toàn: Nếu group rỗng hoặc phần tử đầu tiên undefined
        if (group.length === 0 || !group[0]) {
            alert("Không tìm thấy dữ liệu để sửa. Vui lòng tải lại trang.");
            return;
        }

        const firstExec = group[0];
        // Check an toàn khi truy cập thuộc tính
        const ngayHienThi = firstExec.ngayThucHien || 'N/A';
        
        const title = `Sửa lần thực hiện ngày ${ngayHienThi}`;
        document.getElementById('modalTitle').innerHTML = `<h2>${title}</h2>`;

        const headers = [
            {text: 'TT', width: '5%'},
            {text: 'Nội dung công việc', width: '40%'},
            {text: 'Số lượng', width: '12%'},
            {text: 'Đơn giá', width: '15%'},
            {text: 'Thành tiền', width: '18%'}
        ];
        let table = createModalTable(headers);

        group.forEach((exec, index) => {
            table += `<tr data-exec-path="${exec.path}">
                <td><input type="text" value="${index + 1}" disabled></td>
                <td><input type="text" value="${exec.noiDung}" disabled></td>
                <td><input type="number" value="${exec.dvt}" data-field="dvt" oninput="calculateThanhTien(this)" onfocus="this.select()"></td>
                <td><input type="number" value="${exec.donGia}" data-field="donGia" oninput="calculateThanhTien(this)" onfocus="this.select()"></td>
                <td><input type="text" value="${formatNumber(exec.thanhTien)}" data-field="thanhTien" disabled></td>
            </tr>`;
        });

        table += '</tbody></table>';
        document.getElementById('modalBody').innerHTML = table;

        document.getElementById('modalSaveButton').onclick = saveExecutionEdits;
        document.getElementById('modalSaveButton').style.display = 'block';

        const keyParam = `'${tsKey}'`;
        document.getElementById('modal-footer-left').innerHTML = `
            <button class="btn-danger" onclick="handleDeleteExecution(${keyParam})">Xóa lần thực hiện này</button>
            <button class="btn-info" onclick="uploadPdfForExecution(${keyParam})">Tải lên Hồ sơ</button>
        `;

        document.getElementById('modalDeleteButton').style.display = 'none';
        modal.style.display = 'block';
    };

    // 3. Hàm Xóa (Recursive Map traversal)
    window.handleDeleteExecution = async function(timestampKey) {
        if (!isAuthenticated) return showAuthError();
        if (!confirm("Bạn có chắc chắn muốn xóa lần thực hiện này không? Hành động này không thể hoàn tác.")) return;
        
        try {
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đang xóa dữ liệu...';

            let group = [];
            const tsKey = String(timestampKey);
            
            if (executionGroups.has(tsKey)) {
                const l2Map = executionGroups.get(tsKey);
                for (const pMap of l2Map.values()) {
                    for (const execs of pMap.values()) group.push(...execs);
                }
            }

            if (group.length === 0) {
                alert("Không tìm thấy dữ liệu để xóa.");
                return;
            }
            
            const updates = {};
            const pathsToRecalculate = new Set();
            const parentPathsToCheck = new Set();

            group.forEach(exec => {
                updates[exec.path] = null;
                const taskPath = exec.path.substring(0, exec.path.lastIndexOf('/executions/'));
                pathsToRecalculate.add(taskPath);
                // Lưu lại Group Parent Path (Cấp 4) để check lại cờ daThucHien
                if (exec.groupParentPath) parentPathsToCheck.add(exec.groupParentPath);
            });

            await update(ref(db), updates);
            statusDiv.innerText = "Đang cập nhật lại chi phí...";
            
            const recalcPromises = Array.from(pathsToRecalculate).map(path => recalculateExecutionCost(path));
            await Promise.all(recalcPromises);

            await recalculateCostsForParents(Array.from(pathsToRecalculate));

            for (const pPath of parentPathsToCheck) {
                await checkAndUpdateDaThucHien(pPath);
            }

            closeAllModals();
            await fetchData();
            statusDiv.innerText = "Đã xóa thành công.";

        } catch (error) {
             console.error("Lỗi khi xóa:", error);
             statusDiv.className = 'error';
             statusDiv.innerText = `Lỗi khi xóa: ${error.message}`;
        }
    };

    // 4. Hàm Upload PDF (Recursive Map traversal)
    window.performPdfUpload = async function(timestampKey) {
        if (!isAuthenticated) return showAuthError(); 
        
        const googleToken = gapi.client.getToken();
        if (!googleToken || !googleToken.access_token) {
            statusDiv.className = 'error';
            statusDiv.innerText = 'Phiên đăng nhập Google đã hết hạn. Vui lòng tải lại trang.';
            closeAllModals(); 
            return;
        }

        const uploadButton = document.getElementById('uploadPdfButton');
        const fileInput = document.getElementById('pdf_file_input');
        const file = fileInput.files[0];
        if (!file) { alert('Vui lòng chọn một tệp PDF.'); return; }
        
        try {
            uploadButton.disabled = true; 
            uploadButton.textContent = 'Đang tải...';
            statusDiv.className = 'success'; 
            statusDiv.innerText = 'Đang tải tệp lên Google Drive...';
            
            const metadata = { name: file.name, mimeType: 'application/pdf', parents: [FOLDER_ID] };
            const formData = new FormData();
            formData.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
            formData.append('file', file);
            
            const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${googleToken.access_token}` }, 
                body: formData
            });
            if (!response.ok) throw new Error(`Lỗi API Drive`); 
            
            const fileData = await response.json();
            const fileLink = `https://drive.google.com/file/d/${fileData.id}/view`;
            
            statusDiv.innerText = 'Đang cập nhật CSDL...';

            const tsKey = String(timestampKey);
            const updates = {};
            let updatedCount = 0;

            if (executionGroups.has(tsKey)) {
                const l2Map = executionGroups.get(tsKey);
                for (const pMap of l2Map.values()) {
                    for (const execs of pMap.values()) {
                        execs.forEach(exec => {
                            updates[`${exec.path}/hoSoLink`] = fileLink;
                            updatedCount++;
                        });
                    }
                }
            }

            if (updatedCount > 0) {
                 await update(ref(db), updates);
            }

            closeAllModals(); 
            await openSearchModal(); 
            statusDiv.className = 'success';
            statusDiv.innerText = `Cập nhật hồ sơ thành công!`;

        } catch (error) {
            console.error('Lỗi upload:', error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi: ${error.message}`;
        } finally {
            uploadButton.disabled = false;
            uploadButton.textContent = 'Tải Lên';
            fileInput.value = ''; 
        }
    };

    // 5. Các hàm hỗ trợ nút bấm
    window.openExecutionProfile = function(timestampKey) {
        if (!isAuthenticated) return showAuthError();
        const tsKey = String(timestampKey);
        document.getElementById('uploadPdfModalTitle').textContent = 'Tải lên/Cập nhật Hồ sơ PDF';
        document.getElementById('uploadPdfButton').onclick = () => performPdfUpload(tsKey);
        document.getElementById('pdf_file_input').value = '';
        document.getElementById('uploadPdfModal').style.display = 'block';
    };

    window.uploadPdfForExecution = function(timestampKey) {
        window.openExecutionProfile(timestampKey);
    };

// HÀM FETCHDATA CHÍNH (cần được định nghĩa sau cùng vì phụ thuộc vào nhiều hàm khác)
      // HÀM FETCHDATA CHÍNH (ĐẦY ĐỦ CHỨC NĂNG & CHỈNH SỬA NỘI TUYẾN)
  // HÀM FETCHDATA CHÍNH (ĐÃ CẬP NHẬT HIỂN THỊ TẦN SUẤT)
    // HÀM FETCHDATA CHÍNH (CẬP NHẬT: SỐ LƯỢNG CẤP 1 TỰ ĐỘNG LẤY TỪ SUMMARY)
    window.fetchData = async function() {
        const tableBody = document.getElementById('taskListBody');
        tableBody.innerHTML = `<tr><td colspan="17" style="text-align: center;">Đang tải dữ liệu...</td></tr>`;
        docDataMap.clear(); 
        
        try {
            await ensureYearCollectionExists(currentYear);

            // 1. Tải Link Hồ sơ
            const hoSoLinksMap = new Map();
            const executionQuery = ref(db, `${getParentCollectionName()}`);
            const executionSnapshot = await get(executionQuery);
            
            if (executionSnapshot.exists()) {
                const processNodeForLinks = (node, path) => {
                    if (node.executions) {
                        for (const execId in node.executions) {
                            const exec = node.executions[execId];
                            if (exec.hoSoLink) {
                                if (!hoSoLinksMap.has(path)) {
                                    hoSoLinksMap.set(path, new Set());
                                }
                                hoSoLinksMap.get(path).add(exec.hoSoLink);
                            }
                        }
                    }
                    if (node.children) for (const k in node.children) processNodeForLinks(node.children[k], `${path}/children/${k}`);
                    if (node.grandchildren) for (const k in node.grandchildren) processNodeForLinks(node.grandchildren[k], `${path}/grandchildren/${k}`);
                    if (node.greatGrandchildren) for (const k in node.greatGrandchildren) processNodeForLinks(node.greatGrandchildren[k], `${path}/greatGrandchildren/${k}`);
                    if (node.greatGreatGrandchildren) for (const k in node.greatGreatGrandchildren) processNodeForLinks(node.greatGreatGrandchildren[k], `${path}/greatGreatGrandchildren/${k}`);
                };
                
                const data = executionSnapshot.val();
                for (const parentId in data) {
                    processNodeForLinks(data[parentId], `${getParentCollectionName()}/${parentId}`);
                }
            }

            // 2. Tải dữ liệu Summary (ĐỂ LẤY SỐ LƯỢNG CẤP 1)
            const summaryRef = ref(db, `summary_data/${currentYear}`);
            const summarySnap = await get(summaryRef);
            const summaryData = summarySnap.exists() ? summarySnap.val() : {};

            // 3. Tải dữ liệu chính
            let html = '';
            let totalPlannedCost = 0, totalExecutedCost = 0;

            const parentSnapshot = await get(ref(db, getParentCollectionName()));
            if (!parentSnapshot.exists()) {
                tableBody.innerHTML = `<tr><td colspan="17" style="text-align: center;">Không có dữ liệu cho năm ${currentYear}.</td></tr>`;
                document.getElementById('summarySection').innerHTML = '';
                return;
            }
            
            parentNoiDungMap.clear();
            const parentsData = parentSnapshot.val();
            const parents = Object.keys(parentsData).map(id => ({ id, ...parentsData[id] }));
            parents.sort((a, b) => a.id.localeCompare(b.id));

            const createRowHtml = (itemClass, path, data) => {
                const isParentLeaf = itemClass.includes('is-parent-leaf');
                const isCheckbox = !itemClass.includes('task-parent');
                
                let hoSoBtn = '';
                const links = hoSoLinksMap.get(path);
                if (links && links.size > 0) {
                    const linksJson = JSON.stringify(Array.from(links));
                    hoSoBtn = `<button class="btn-info btn-action" data-links='${linksJson}' onclick="showLinks(event)">Có</button>`;
                }

                const noiDungStyle = data.chiPhiThucHien > 0 ? 'style="color: #5B77A8;"' : '';

                let levelName = 'child';
                if (itemClass.includes('task-parent')) levelName = 'parent';
                else if (itemClass.includes('task-child')) levelName = 'child';
                else if (itemClass.includes('task-grandchild')) levelName = 'grandchild';
                else if (itemClass.includes('task-great-grandchild')) levelName = 'greatGrandchild';
                else if (itemClass.includes('task-great-great-grandchild')) levelName = 'greatGreatGrandchild';

                const displayTanSuat = (data.tanSuatTH === 0) ? '-' : (data.tanSuatTH || '');

                return `<tr class="${itemClass}" data-main-parent="${mainParentId}" data-path="${path}">
                    <td>${isCheckbox ? `<input type="checkbox" class="${isParentLeaf ? 'parent-checkbox' : 'task-checkbox'}" data-path="${path}" onchange="${isParentLeaf ? 'toggleChildrenCheckboxes(this)' : 'toggleSelection(this)'}">` : ''}</td>
                    <td class="col-tt">${convertTTForDisplay(data.tt)}</td>
                    <td class="col-noidung" ${noiDungStyle}>${data.noiDung}</td>
                    <td class="col-dv-thuchien editable-cell" data-field="dvThucHien">${data.dvThucHien || ''}</td>
                    <td class="text-right col-kh-nam-truoc">${formatNumber(data.khNamTruoc)}</td>
                    <td class="text-right col-th-nam-truoc editable-cell" data-field="thucHienNamTruoc">${formatNumber(data.thucHienNamTruoc)}</td>
                    <td class="col-donvi editable-cell" data-field="donVi">${data.donVi || ''}</td>
                    
                    <td class="col-soluong">${data.soLuong || ''}</td>
                    
                    <td class="col-tansuat-th" style="text-align: center;">${displayTanSuat}</td>
                    <td class="text-right col-chiphi">${formatNumber(data.chiPhi)}</td>
                    <td class="text-right col-chiphi-thuchien">${formatNumber(data.chiPhiThucHien)}</td>
                    <td class="text-right col-kehoach-conlai">${formatNumber(data.keHoachConLai)}</td>
                    <td class="col-nam-phanbo editable-cell" data-field="namPhanBo">${data.namPhanBo || ''}</td>
                    <td class="col-chiphi-phanbo">${formatNumber(data.chiPhiPhanBo)}</td>
                    <td class="col-capdo editable-cell" data-field="capDo">${data.capDo || ''}</td>
                    <td class="col-tg-batdau editable-cell" data-field="tgBatDau">${data.tgBatDau || ''}</td>
                    <td class="col-tg-hoanthanh editable-cell" data-field="tgHoanThanh">${data.tgHoanThanh || ''}</td>
                    <td class="col-ghichu editable-cell" data-field="ghiChu">${data.ghiChu || ''}</td>
                    <td class="col-hoso">${hoSoBtn}</td>
                    <td class="col-action">
                        <div class="dropdown">
                            <button onclick="toggleDropdown(event)" class="btn-secondary btn-action dropbtn">Thêm/sửa</button>
                            <div class="dropdown-content">
                                ${getLevelSpecificActions(levelName, path)}
                                <a href="#" onclick="handleEditClick('${path}', '${levelName}')">Sửa Nội dung</a>
                            </div>
                        </div>
                    </td>
                </tr>`;
            };

            const getLevelSpecificActions = (level, path) => {
                if (level === 'parent') return `<a href="#" onclick="openAddModal('${path}', 'child')">Thêm lĩnh vực ATCLMT</a>`;
                if (level === 'child') return `<a href="#" onclick="openAddModal('${path}', 'grandchild')">Thêm mục công việc</a>`;
                if (level === 'grandchild') return `<a href="#" onclick="openAddModal('${path}', 'greatGrandchild')">Thêm đầu công việc</a>`;
                if (level === 'greatGrandchild') return `<a href="#" onclick="openAddModal('${path}', 'greatGreatGrandchild')">Thêm công việc chi tiết</a><a href="#" onclick="openAddModal('${path}', 'justification')">Thêm giải trình</a>`;
                if (level === 'greatGreatGrandchild') return `<a href="#" onclick="openAddModal('${path}', 'justification')">Thêm giải trình</a>`;
                return '';
            };

            for (const parentData of parents) {
                parentNoiDungMap.set(parentData.id, parentData.noiDung);
                var mainParentId = parentData.tt; 

                // === GÁN SỐ LƯỢNG CẤP 1 TỪ SUMMARY ===
                const parentSummary = summaryData[parentData.id] || {};
                parentData.soLuong = parentSummary.totalLeafNodesCap1 || 0;
                // ======================================

                totalPlannedCost += parentData.chiPhi || 0;
                totalExecutedCost += parentData.chiPhiThucHien || 0;
                const parentPath = `${getParentCollectionName()}/${parentData.id}`;
                
                html += createRowHtml('task-parent', parentPath, parentData);

                if (parentData.children) {
                    const children = Object.keys(parentData.children).map(id => ({ id, ...parentData.children[id] })).sort(childSort);
                    for (const childData of children) {
                        const childPath = `${parentPath}/children/${childData.id}`;
                        docDataMap.set(childPath, childData);
                        
                        if (!childData.isHidden) {
                            html += createRowHtml('task-child', childPath, childData);
                        }

                        if (childData.grandchildren) {
                            const grandchildren = Object.keys(childData.grandchildren).map(id => ({ id, ...childData.grandchildren[id] })).sort((a, b) => parseInt(a.id, 10) - parseInt(b.id, 10));
                            for (const grandchildData of grandchildren) {
                                const grandchildPath = `${childPath}/grandchildren/${grandchildData.id}`;
                                docDataMap.set(grandchildPath, grandchildData);
                                html += createRowHtml('task-grandchild', grandchildPath, grandchildData);

                                if (grandchildData.greatGrandchildren) {
                                    const greatGrandchildren = Object.keys(grandchildData.greatGrandchildren).map(id => ({ id, ...grandchildData.greatGrandchildren[id] })).sort(numericSort);
                                    for (const greatGrandchildData of greatGrandchildren) {
                                        const greatGrandchildPath = `${grandchildPath}/greatGrandchildren/${greatGrandchildData.id}`;
                                        docDataMap.set(greatGrandchildPath, greatGrandchildData);
                                        
                                        const isParentLeaf = greatGrandchildData.hasChildren;
                                        const rowClass = `task-great-grandchild ${isParentLeaf ? 'is-parent-leaf' : ''}`;
                                        
                                        html += createRowHtml(rowClass, greatGrandchildPath, greatGrandchildData);

                                        if (greatGrandchildData.justifications) {
                                            const justifications = Object.keys(greatGrandchildData.justifications).map(id => ({ 
                                                id, 
                                                path: `${greatGrandchildPath}/justifications/${id}`, 
                                                ...greatGrandchildData.justifications[id] 
                                            })).sort((a, b) => a.id.localeCompare(b.id));
                                            
                                            for (const justData of justifications) {
                                                 html += `<tr class="task-justification task-justification-parent" data-main-parent="${mainParentId}" data-path="${justData.path}">
                                                    <td><input type="checkbox" class="justification-checkbox ${justData.hasSubJustifications ? 'parent-checkbox' : ''}" data-path="${justData.path}" data-parent-path="${greatGrandchildPath}" onchange="${justData.hasSubJustifications ? 'toggleChildrenCheckboxes(this)' : 'toggleSelection(this)'}"></td>
                                                    <td class="col-tt">${convertTTForDisplay(justData.tt)}</td>
                                                    <td class="col-noidung">${justData.noiDung}</td>
                                                    <td class="col-dv-thuchien"></td><td class="text-right col-kh-nam-truoc"></td><td class="text-right col-th-nam-truoc"></td>
                                                    <td class="col-donvi editable-cell" data-field="donVi">${justData.donVi || ''}</td>
                                                    <td class="col-soluong">${justData.soLuong || ''}</td>
                                                    <td class="col-tansuat-th"></td>
                                                    <td class="text-right col-chiphi">${formatNumber(justData.chiPhi || 0)}</td>
                                                    <td class="text-right col-chiphi-thuchien"></td><td class="text-right col-kehoach-conlai"></td>
                                                    <td class="col-nam-phanbo"></td><td class="col-chiphi-phanbo"></td>
                                                    <td class="col-capdo"></td><td class="col-tg-batdau"></td><td class="col-tg-hoanthanh"></td>
                                                    <td class="col-ghichu editable-cell" data-field="ghiChu">${justData.ghiChu || ''}</td>
                                                    <td class="col-hoso"></td>
                                                    <td class="col-action"><div class="dropdown"><button onclick="toggleDropdown(event)" class="btn-secondary btn-action dropbtn">Thêm/sửa</button><div class="dropdown-content"><a href="#" onclick="openAddModal('${justData.path}', 'subJustification')">Thêm GT con</a><a href="#" onclick="handleEditClick('${justData.path}', 'justification')">Sửa giải trình</a></div></div></td>
                                                </tr>`;
                                                
                                                if (justData.hasSubJustifications && justData.subJustifications) {
                                                     const subJustifications = Object.keys(justData.subJustifications).map(subId => ({ id: subId, path: `${justData.path}/subJustifications/${subId}`, ...justData.subJustifications[subId] })).sort((a, b) => a.tt.localeCompare(b.tt));
                                                     for (const subJust of subJustifications) {
                                                         html += `<tr class="task-justification task-justification-child" data-main-parent="${mainParentId}" data-path="${subJust.path}">
                                                            <td><input type="checkbox" class="justification-checkbox" data-path="${subJust.path}" data-parent-path="${justData.path}" onchange="toggleSelection(this)"></td>
                                                            <td class="col-tt">${convertTTForDisplay(subJust.tt)}</td>
                                                            <td class="col-noidung" style="padding-left: 40px; font-style: italic;">${subJust.noiDung}</td>
                                                            <td class="col-dv-thuchien"></td><td class="text-right col-kh-nam-truoc"></td><td class="text-right col-th-nam-truoc"></td>
                                                            <td class="col-donvi editable-cell" data-field="donVi">${subJust.donVi || ''}</td>
                                                            <td class="col-soluong">${subJust.soLuong || ''}</td>
                                                            <td class="col-tansuat-th"></td>
                                                            <td class="text-right col-chiphi">${formatNumber(subJust.chiPhi || 0)}</td>
                                                            <td class="text-right col-chiphi-thuchien"></td><td class="text-right col-kehoach-conlai"></td>
                                                            <td class="col-nam-phanbo"></td><td class="col-chiphi-phanbo"></td>
                                                            <td class="col-capdo"></td><td class="col-tg-batdau"></td><td class="col-tg-hoanthanh"></td>
                                                            <td class="col-ghichu editable-cell" data-field="ghiChu">${subJust.ghiChu || ''}</td>
                                                            <td class="col-hoso"></td>
                                                            <td class="col-action"><button class="btn-secondary btn-action btn-edit-leaf" onclick="handleEditClick('${subJust.path}', 'subJustification')">Sửa</button></td>
                                                        </tr>`;
                                                     }
                                                }
                                            }
                                        }

                                        if (isParentLeaf && greatGrandchildData.greatGreatGrandchildren) {
                                            const greatGreatGrandchildren = Object.keys(greatGrandchildData.greatGreatGrandchildren).map(id => ({ id, ...greatGrandchildData.greatGreatGrandchildren[id] })).sort(numericSort);
                                            for (const gggcData of greatGreatGrandchildren) {
                                                const gggcPath = `${greatGrandchildPath}/greatGreatGrandchildren/${gggcData.id}`;
                                                docDataMap.set(gggcPath, gggcData);
                                                html += createRowHtml('task-great-great-grandchild', gggcPath, gggcData);

                                                if (gggcData.justifications) {
                                                    const justifications = Object.keys(gggcData.justifications).map(id => ({ id, path: `${gggcPath}/justifications/${id}`, ...gggcData.justifications[id] })).sort((a, b) => a.id.localeCompare(b.id));
                                                    for (const justData of justifications) {
                                                        html += `<tr class="task-justification task-justification-parent" data-main-parent="${mainParentId}" data-path="${justData.path}">
                                                            <td><input type="checkbox" class="justification-checkbox ${justData.hasSubJustifications ? 'parent-checkbox' : ''}" data-path="${justData.path}" data-parent-path="${gggcPath}" onchange="${justData.hasSubJustifications ? 'toggleChildrenCheckboxes(this)' : 'toggleSelection(this)'}"></td>
                                                            <td class="col-tt">${convertTTForDisplay(justData.tt)}</td>
                                                            <td class="col-noidung">${justData.noiDung}</td>
                                                            <td class="col-dv-thuchien"></td><td class="text-right col-kh-nam-truoc"></td><td class="text-right col-th-nam-truoc"></td>
                                                            <td class="col-donvi editable-cell" data-field="donVi">${justData.donVi || ''}</td>
                                                            <td class="col-soluong">${justData.soLuong || ''}</td>
                                                            <td class="col-tansuat-th"></td>
                                                            <td class="text-right col-chiphi">${formatNumber(justData.chiPhi || 0)}</td>
                                                            <td class="text-right col-chiphi-thuchien"></td><td class="text-right col-kehoach-conlai"></td>
                                                            <td class="col-nam-phanbo"></td><td class="col-chiphi-phanbo"></td>
                                                            <td class="col-capdo"></td><td class="col-tg-batdau"></td><td class="col-tg-hoanthanh"></td>
                                                            <td class="col-ghichu editable-cell" data-field="ghiChu">${justData.ghiChu || ''}</td>
                                                            <td class="col-hoso"></td>
                                                            <td class="col-action"><div class="dropdown"><button onclick="toggleDropdown(event)" class="btn-secondary btn-action dropbtn">Thêm/sửa</button><div class="dropdown-content"><a href="#" onclick="openAddModal('${justData.path}', 'subJustification')">Thêm GT con</a><a href="#" onclick="handleEditClick('${justData.path}', 'justification')">Sửa giải trình</a></div></div></td>
                                                        </tr>`;
                                                        if (justData.hasSubJustifications && justData.subJustifications) {
                                                             const subJustifications = Object.keys(justData.subJustifications).map(subId => ({ id: subId, path: `${justData.path}/subJustifications/${subId}`, ...justData.subJustifications[subId] })).sort((a, b) => a.tt.localeCompare(b.tt));
                                                             for (const subJust of subJustifications) {
                                                                 html += `<tr class="task-justification task-justification-child" data-main-parent="${mainParentId}" data-path="${subJust.path}">
                                                                    <td><input type="checkbox" class="justification-checkbox" data-path="${subJust.path}" data-parent-path="${justData.path}" onchange="toggleSelection(this)"></td>
                                                                    <td class="col-tt">${convertTTForDisplay(subJust.tt)}</td>
                                                                    <td class="col-noidung" style="padding-left: 40px; font-style: italic;">${subJust.noiDung}</td>
                                                                    <td class="col-dv-thuchien"></td><td class="text-right col-kh-nam-truoc"></td><td class="text-right col-th-nam-truoc"></td>
                                                                    <td class="col-donvi editable-cell" data-field="donVi">${subJust.donVi || ''}</td>
                                                                    <td class="col-soluong">${subJust.soLuong || ''}</td>
                                                                    <td class="col-tansuat-th"></td>
                                                                    <td class="text-right col-chiphi">${formatNumber(subJust.chiPhi || 0)}</td>
                                                                    <td class="text-right col-chiphi-thuchien"></td><td class="text-right col-kehoach-conlai"></td>
                                                                    <td class="col-nam-phanbo"></td><td class="col-chiphi-phanbo"></td>
                                                                    <td class="col-capdo"></td><td class="col-tg-batdau"></td><td class="col-tg-hoanthanh"></td>
                                                                    <td class="col-ghichu editable-cell" data-field="ghiChu">${subJust.ghiChu || ''}</td>
                                                                    <td class="col-hoso"></td>
                                                                    <td class="col-action"><button class="btn-secondary btn-action btn-edit-leaf" onclick="handleEditClick('${subJust.path}', 'subJustification')">Sửa</button></td>
                                                                </tr>`;
                                                             }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            tableBody.innerHTML = html || `<tr><td colspan="17" style="text-align: center;">Không có dữ liệu cho năm ${currentYear}.</td></tr>`;

            // --- HIỂN THỊ SUMMARY ---
            let summaryTotalLeafNodes = 0;
            let summaryTotalExecutedLeafNodes = 0;
            let summaryTotalLeafNodesCap1 = 0;
            let summaryTotalExecutedLeafNodesCap1 = 0;

            for (const parentId in summaryData) {
                const parentSummary = summaryData[parentId];
                summaryTotalLeafNodes += parentSummary.totalLeafNodes || 0;
                summaryTotalExecutedLeafNodes += parentSummary.totalExecutedLeafNodes || 0;
                summaryTotalLeafNodesCap1 += parentSummary.totalLeafNodesCap1 || 0;
                summaryTotalExecutedLeafNodesCap1 += parentSummary.totalExecutedLeafNodesCap1 || 0;
            }

            const leafNodePercentage = summaryTotalLeafNodes > 0 ? Math.round((summaryTotalExecutedLeafNodes / summaryTotalLeafNodes) * 100) : 0;
            const costPercentage = totalPlannedCost > 0 ? Math.round((totalExecutedCost / totalPlannedCost) * 100) : 0;
            const cap1Percentage = summaryTotalLeafNodesCap1 > 0 ? Math.round((summaryTotalExecutedLeafNodesCap1 / summaryTotalLeafNodesCap1) * 100) : 0;

            const summaryHtml = `
                <button class="btn-info" style="position: absolute; top: 10px; right: 10px; padding: 5px 10px; font-size: 14px;" onclick="openSummaryDetailModal()">Xem chi tiết các đơn vị</button>
                <div class="summary-column">
                    <p><strong>Tổng số đầu việc chi tiết trong kế hoạch:</strong> ${summaryTotalLeafNodes}</p>
                    <p><strong>Tổng số đầu việc cấp độ 1 cần thực hiện:</strong> ${summaryTotalLeafNodesCap1}</p>
                    <p><strong>Tổng chi phí theo kế hoạch:</strong> ${formatNumber(totalPlannedCost)}</p>
                </div>
                <div class="summary-column">
                    <p><strong>Số đầu việc chi tiết đã thực hiện:</strong> ${summaryTotalExecutedLeafNodes} <span class=\"percentage\">(${leafNodePercentage}%)</span></p>
                    <p><strong>Số đầu việc cấp độ 1 đã thực hiện:</strong> ${summaryTotalExecutedLeafNodesCap1} <span class=\"percentage\">(${cap1Percentage}%)</span></p>
                    <p><strong>Tổng chi phí đã thực hiện:</strong> ${formatNumber(totalExecutedCost)} <span class=\"percentage\">(${costPercentage}%)</span></p>
                </div>`;

            document.getElementById('summarySection').innerHTML = summaryHtml;
            
            selectedTasks.clear();
            selectedJustifications.clear();
            updateButtonStates();
            statusDiv.innerText = '';

        } catch (error) { 
            console.error("Lỗi tải dữ liệu: ", error); 
            tableBody.innerHTML = `<tr><td colspan="17" style="text-align: center; color: red;">Lỗi tải dữ liệu: ${error.message}</td></tr>`; 
        }
    };
    

</script>



</body>
</html>
