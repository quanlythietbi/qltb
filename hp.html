<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lập và theo dõi Kế hoạch BDSC</title>
    <style>
        /* CSS giữ nguyên như file gốc */
        .links-dropdown {
            display: block; position: absolute; background-color: #fff; min-width: 300px; max-width: 500px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 20; border-radius: 4px; border: 1px solid #ddd; padding: 5px;
        }
        .links-dropdown a {
            color: #0056b3; padding: 8px 12px; text-decoration: none; display: block; font-size: 14px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .links-dropdown a:hover { background-color: #f1f1f1; text-decoration: underline; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0; background-color: #f4f4f9; line-height: 1.6;
        }
        #container {
            max-width: 1400px; margin: auto; background-color: white;
            padding: 25px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: block;
        }
        #login-container {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            animation: fadeIn 0.3s;
        }
        #login-box {
            max-width: 400px;
            margin: 10% auto;
            padding: 30px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            text-align: center;
            position: relative;
            animation: slideIn 0.3s;
        }
        #login-box h2 { margin-top: 0; color: #333; }
        #login-box input {
            width: 100%; padding: 12px; margin-bottom: 15px; border: 1px solid #ccc;
            border-radius: 4px; box-sizing: border-box; font-size: 16px;
        }
        #login-box button { width: 100%; padding: 12px; font-size: 16px; }
        #login-container h2 { margin-top: 0; color: #333; }
        #login-container input {
            width: 100%; padding: 12px; margin-bottom: 15px; border: 1px solid #ccc;
            border-radius: 4px; box-sizing: border-box; font-size: 16px;
        }
        #login-container button { width: 100%; padding: 12px; font-size: 16px; }
        #login-error { color: #dc3545; margin-top: 15px; font-weight: bold; }

        h1, h2 { color: #333; }
        h3 { color: #555; font-weight: normal; border-bottom: 1px solid #eee; padding-bottom: 10px; }
        .button-group {
            display: flex; justify-content: space-between; align-items: center;
            margin-top: 10px; flex-wrap: wrap;
        }
        .button-group > div { display: flex; gap: 10px; flex-wrap: wrap; }
        button {
            border: none; padding: 10px 18px; border-radius: 5px;
            cursor: pointer; font-size: 16px; transition: background-color: 0.3s, transform: 0.1s;
        }
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        button:active { transform: scale(0.98); }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-primary:hover { background-color: #0056b3; }
        .btn-danger { background-color: #dc3545; color: white; }
        .btn-danger:hover { background-color: #c82333; }
        .btn-secondary { background-color: #6c757d; color: white; }
        .btn-secondary:hover { background-color: #5a6268; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-success:hover { background-color: #218838; }
        .btn-info { background-color: #17a2b8; color: white; }
        .btn-info:hover { background-color: #138496; }
        .btn-warning { background-color: #ffc107; color: #212529; }
        .btn-warning:hover { background-color: #e0a800; }
        .btn-action { padding: 5px 10px; font-size: 14px; margin-right: 5px;}

        input[type="file"] { border: 1px solid #ccc; padding: 8px; border-radius: 4px; }
        #taskList { margin-top: 20px; border-collapse: collapse; width: 100%; table-layout: fixed; }
        #taskList th, #taskList td {
            border: 1px solid #ddd; padding: 10px; text-align: left;
            vertical-align: middle; word-wrap: break-word;
            font-size: 80%;
        }
        #taskList th:first-child, #taskList td:first-child,
        #taskList th:nth-child(2), #taskList td:nth-child(2) {
             padding-left: 4px;
             text-align: left;
        }

        #taskList .btn-action { font-size: 14px; }
        #taskList th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
            z-index: 10;
        }
       /* Cấp 1 (A, B...): Luôn đậm, nền tối nhất, CHỮ MÀU XANH NƯỚC BIỂN */
        .task-parent td { 
            font-weight: bold; 
            background-color: #e2e6ea; 
            color: #0056b3; /* Thêm dòng này để đổi màu chữ */
        }
        
        /* Cấp 2 (I, II...): Luôn đậm, nền sáng hơn chút */
        .task-child td { font-weight: bold; background-color: #e9ecef; }
        
        /* Cấp 3 (1, 2...): Mặc định đậm (nếu là cha), nền sáng hơn nữa */
        .task-grandchild td { font-weight: bold; background-color: #f2f4f6; }
        
        /* Cấp 3 (1, 2...) NHƯNG LÀ LÁ (Không có con): Chữ thường */
        .task-grandchild.is-parent-leaf td { font-weight: normal; }

        /* Cấp 4 (1.1, 1.2...): Luôn là lá -> Chữ thường, nền sáng nhất */
        .task-great-grandchild td { font-weight: normal; background-color: #f8f9fa; }
        
        /* Đảm bảo khi là lá thì đè font-weight kể cả có class khác */
        tr.is-parent-leaf td { font-weight: normal !important; }
        .task-great-great-grandchild td:nth-child(3) { font-style: italic; padding-left: 18px !important; }
        .task-justification { display: none; }
        .task-justification td { background-color: #fffbe6; color: red; }
        .task-justification td:nth-child(3) { padding-left: 30px !important; font-style: italic; }
        /* --- SỬA ĐỔI: Căn lề cho dòng Giải trình --- */
        
        /* Cột Nội dung (Cột 3): Giữ nguyên thụt đầu dòng và in nghiêng */
        .task-justification td:nth-child(3) { 
            padding-left: 30px !important; 
            font-style: italic; 
        }

        /* Cột TT (Cột 2): Bắt buộc căn sát lề phải, xóa padding trái để không bị đẩy */
        .task-justification td.col-tt {
            text-align: left !important;   /* Bắt buộc căn phải */
            padding-right: 0px !important;  
            padding-left: 1px !important;   
            font-style: italic;             /* Chữ nghiêng cho đồng bộ */
        }

        /* Xóa bỏ rule cũ gây xung đột (đã được thay thế bởi rule .col-tt ở trên) */
        /* .task-justification td:nth-child(2) { ... } -> ĐÃ XÓA */

        #taskList th.text-right, #taskList td.text-right { text-align: right; padding-right: 4px; }
        #taskList th.col-donvi, #taskList td.col-donvi,
        #taskList th.col-soluong, #taskList td.col-soluong {
            text-align: center;
        }

        #status { margin-top: 15px; font-weight: bold; }
        #status.success { color: #28a745; }
        #status.error { color: #dc3545; }

        #summarySection {
            background-color: #e9ecef; padding: 15px; border-radius: 5px; margin-top: 20px;
            display: flex; justify-content: space-between; flex-wrap: wrap;
            position: relative;
        }
        .summary-column { width: 48%; }
        #summarySection p { margin: 5px 0; font-size: 16px; }
        #summarySection p strong { color: #333; }
        .percentage { color: #007bff; font-weight: bold; }

        .modal {
            display: none; position: fixed; z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.5);
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn { from {opacity: 0;} to {opacity: 1;} }
        .modal-content {
            background-color: #fefefe; margin: 5% auto; padding: 25px;
            border: 1px solid #888; width: 90%; max-width: 1200px; border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2); animation: slideIn 0.3s;
        }
        @keyframes slideIn { from {transform: translateY(-50px);} to {transform: translateY(0);} }
        .modal-table { width: 100%; border-collapse: collapse; margin-top: 15px; table-layout: fixed; }
        .modal-table th, .modal-table td { border: 1px solid #ddd; padding: 8px; }
        .modal-table th { background-color: #f2f2f2; font-size: 80%; }
        .modal-table input { width: 95%; padding: 6px; border: 1px solid #ccc; border-radius: 4px; }
        .modal-table input:disabled { background-color: #e9ecef; cursor: not-allowed;}

        .col-noidung { width: 20%; }
		.col-tagname { width: 5%; text-align: center; }
        .col-dv-thuchien { width: 8%; }
        .col-tt, .col-donvi, .col-soluong, .col-tansuat-th, .col-capdo, .col-hoso { width: 3%; }
		.col-soluong { width: 4%; }
        .col-ghichu { width: 10%; }
        .col-chiphi, .col-thanhtien, .col-kh-nam-truoc, .col-th-nam-truoc { width: 8%; }
        .col-tg-batdau, .col-tg-hoanthanh { width: 3%; }
        .col-dvt, .col-dongia { width: 6%; }

        .modal-table th:nth-child(1), .modal-table td:nth-child(1) { width: 3%; }
        .modal-table th:nth-child(2), .modal-table td:nth-child(2) { width: 25%; }
        .modal-table th:nth-child(3), .modal-table td:nth-child(3) { width: 6%; }
        .modal-table th:nth-child(4), .modal-table td:nth-child(4) { width: 7%; }
        .modal-table th:nth-child(6), .modal-table td:nth-child(6) { width: 3%; }
        .modal-table th:nth-child(8), .modal-table td:nth-child(8) { width: 3%; }
        .modal-table th:nth-child(9), .modal-table td:nth-child(9) { width: 7%; }
        .modal-table th:nth-child(10), .modal-table td:nth-child(10) { width: 3%; }
        .modal-table th:nth-child(11), .modal-table td:nth-child(11) { width: 3%; }

        .execution-modal-table th:nth-child(1), .execution-modal-table td:nth-child(1) { width: 8%; }
        .execution-modal-table th:nth-child(2), .execution-modal-table td:nth-child(2) { width: 54%; }
        .execution-modal-table th:nth-child(3), .execution-modal-table td:nth-child(3) { width: 12%; }
        .execution-modal-table th:nth-child(4), .execution-modal-table td:nth-child(4) { width: 13%; }
        .execution-modal-table th:nth-child(5), .execution-modal-table td:nth-child(5) { width: 13%; }

        .modal-footer { text-align: right; margin-top: 20px; }
        .close-button { color: #aaa; float: right; font-size: 28px; font-weight: bold; cursor: pointer; }

        #scrollToTopBtn {
            display: none; position: fixed; bottom: 25px; right: 25px; z-index: 999;
            border: none; outline: none; background-color: #007bff; color: white; cursor: pointer;
            padding: 0; border-radius: 50%; font-size: 24px; width: 50px; height: 50px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3); transition: background-color: 0.3s, transform 0.2s;
        }
        #scrollToTopBtn:hover { background-color: #0056b3; transform: translateY(-2px); }

        .dropdown { position: relative; display: inline-block; }
        .dropdown-content {
            display: none; position: absolute; background-color: #f9f9f9; min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 1; right: 0; border-radius: 4px;
        }
        .dropdown-content a { color: black; padding: 12px 16px; text-decoration: none; display: block; font-size: 14px; }
        .dropdown-content a:hover { background-color: #f1f1f2; }
        .show { display: block; }

        .modal-note {
            background-color: #f8f9fa; border-left: 4px solid #007bff; padding: 10px 15px;
            margin: 15px 0; font-size: 14px; color: #495057;
        }

        #yearSelect {
            padding: 8px 12px; border: 1px solid #ccc; border-radius: 4px;
            font-size: 14px; background-color: white; cursor: pointer;
        }
        #yearSelect:focus {
            outline: none; border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
        }

            

        .delete-confirm-modal, .export-options-modal { max-width: 500px; }
        .delete-confirm-modal input {
            width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #ccc;
            border-radius: 4px; box-sizing: border-box;
        }

        .planning-mode .col-hoso,
        .planning-mode .col-kehoach-conlai { display: none; }
		.planning-mode .col-tagname { display: none; }
		/* --- CSS MỚI CHO 2 CỘT PHÂN BỔ --- */
        /* Mặc định ẩn */
        .col-nam-phanbo, .col-chiphi-phanbo { display: none; }
      .col-cp-cap1 { display: none; }  
        /* Hiển thị khi ở chế độ Planning */
		#taskList.planning-mode .col-cp-cap1 { display: table-cell; width: 8%; text-align: right; }
        .planning-mode .col-nam-phanbo, 
        .planning-mode .col-chiphi-phanbo { display: table-cell; }

        /* Độ rộng cột */
        .planning-mode .col-nam-phanbo { width: 3%; text-align: center; }
        #taskList.planning-mode .col-chiphi-phanbo { width: 8%; text-align: right; }
        /* --------------------------------- */
        .col-tansuat-th, .col-ghichu, .col-kh-nam-truoc, .col-th-nam-truoc, .col-tg-batdau, .col-tg-hoanthanh, .col-action { display: none; }
        .planning-mode .col-tansuat-th,
.planning-mode .col-ghichu,
.planning-mode .col-kh-nam-truoc,
.planning-mode .col-th-nam-truoc,
.planning-mode .col-tg-batdau,

.planning-mode .col-action { display: table-cell; }
        .planning-mode .task-justification { display: table-row !important; }

        .planning-mode .col-dv-thuchien { width: 4% !important; }
        .planning-mode .col-chiphi { width: 8%; }
        .planning-mode .col-chiphi-thuchien { width: 8% !important; }
        .planning-mode .col-kh-nam-truoc { width: 8% !important; }
		.planning-mode .col-th-nam-truoc { width: 8% !important; }
        .planning-mode .col-ghichu { width: 15%; }
        .planning-mode .col-action { width: 4% !important; }
		
		/* --- CSS ĐIỀU CHỈNH CỠ CHỮ CHO PLANNING MODE --- */
        /* Mặc định cỡ chữ của bảng là 80%.
           Yêu cầu giảm 15% (còn 85% của hiện tại).
           Tính toán: 80% * 0.85 = 70%.
        */
        #taskList.planning-mode th, 
        #taskList.planning-mode td {
            font-size: 70%; /* Giảm xuống còn 70% kích thước chuẩn */
            padding: 5px;   /* Giảm nhẹ padding (khoảng cách) để hàng gọn hơn */
        }
        
        /* Điều chỉnh cả các ô input/select nằm trong bảng khi ở chế độ này (nếu có) */
        #taskList.planning-mode input,
        #taskList.planning-mode select,
        #taskList.planning-mode textarea {
            font-size: 100%; /* Kế thừa 70% từ td cha */
        }

/* --- CSS MỚI: GIẢM CỠ CHỮ CHO MODAL THÊM/SỬA --- */
        
        /* 1. Giảm cỡ chữ cho tiêu đề (th) và nội dung (td) trong bảng Modal */
        #dataModal .modal-table th,
        #dataModal .modal-table td {
            font-size: 70%; /* Giảm cỡ chữ xuống còn 70% */
            padding: 4px;   /* Giảm khoảng cách đệm (padding) từ 8px xuống 5px cho gọn */
            line-height: 1.4; /* Điều chỉnh khoảng cách dòng */
        }

        /* 2. Điều chỉnh các ô Input bên trong Modal để khớp với cỡ chữ mới */
        #dataModal .modal-table input {
            font-size: 100%; /* Kế thừa cỡ chữ 70% từ thẻ td cha */
            padding: 3px;    /* Giảm padding trong ô nhập liệu */
            height: auto;    /* Để chiều cao tự động điều chỉnh theo cỡ chữ */
        }
        
        /* 3. (Tùy chọn) Nếu tiêu đề bảng (Header) bị nhỏ quá, bạn có thể giữ nguyên nó */
        /* Bỏ comment dòng dưới nếu bạn muốn tiêu đề to hơn nội dung một chút */
        /* #dataModal .modal-table th { font-size: 90%; } */

        #summaryDetailModal .modal-content { max-width: 95%; }
        .summary-details-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .summary-parent-card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background-color: #f8f9fa;
        }
        .summary-parent-card h3 {
            margin-top: 0;
            color: #007bff;
            border-bottom: 2px solid #007bff;
            padding-bottom: 8px;
            font-size: 1.1rem;
        }
        .summary-columns-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }
        .summary-info-column {
            width: 50%;
            font-size: 14px;
        }
        .summary-info-column h4 {
            margin-top: 0;
            margin-bottom: 8px;
            color: #495057;
            border-bottom: 1px solid #ccc;
            padding-bottom: 4px;
            font-size: 15px;
        }
        .summary-info-column p {
            margin: 4px 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            justify-content: space-between;
        }
        .summary-info-column p strong {
            color: #495057;
        }
        .summary-parent-card .value {
            font-weight: bold;
            color: #333;
        }
        .summary-charts-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }
        .chart-wrapper {
            width: 45%;
            max-width: 150px;
            text-align: center;
        }
        .chart-wrapper p {
            font-size: 12px;
            margin-top: 5px;
            font-weight: bold;
            color: #333;
        }

        @media screen and (max-width: 768px) {
            .responsive-modal-table thead { display: none; }
            .responsive-modal-table, .responsive-modal-table tbody, .responsive-modal-table tr, .responsive-modal-table td {
                display: block; width: 100%;
            }
            .responsive-modal-table tr { margin-bottom: 15px; border: 1px solid #ddd; border-radius: 5px; padding: 10px; }
            .responsive-modal-table td {
                display: flex; justify-content: space-between; padding-left: 50%;
                position: relative; text-align: right; border: none; padding-bottom: 5px;
            }
            .responsive-modal-table td:before {
                content: attr(data-label); position: absolute; left: 10px; width: 45%;
                padding-right: 10px; font-weight: bold; text-align: left;
            }
            .search-modal-mobile td { font-size: 12px; }
            .search-modal-mobile .btn-edit-exec { display: none; }
            .search-modal-mobile .btn-profile-exec {
                flex: 1; padding: 10px 0; font-size: 16px; margin-top: 5px;
            }
            .summary-details-grid {
                grid-template-columns: 1fr;
            }
        }

.task-justification-parent td:nth-child(3) { 
            font-weight: bold;
            padding-left: 25px !important; 
        }
        .task-justification-child td:nth-child(3) { 
            font-style: italic; 
            padding-left: 40px !important; 
        }
        /* SỬA ĐỔI: Ép buộc giải trình con cũng căn phải như cha */
        .task-justification-child td:nth-child(2) { 
            text-align: left !important;
            padding-right: 0px !important;
            padding-left: 1px !important; 
        }
    
/* CSS cho modal Kế hoạch đã duyệt */
    #approvedPlanLinks {
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 10px;
        background-color: #f9f9f9;
        min-height: 100px;
    }
    #approvedPlanLinks p.loading-text,
    #approvedPlanLinks p.empty-text {
        text-align: center;
        color: #777;
        margin-top: 20px;
        font-style: italic;
    }
    .plan-link-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px;
        border-bottom: 1px solid #eee;
    }
    .plan-link-item:last-child {
        border-bottom: none;
    }
    .plan-link-item a {
        color: #0056b3;
        text-decoration: none;
        font-weight: 500;
        font-size: 16px;
        word-break: break-all; /* Tự xuống dòng nếu link quá dài */
        margin-right: 15px;
    }
    .plan-link-item a:hover {
        text-decoration: underline;
    }
    .plan-link-delete-btn {
        padding: 4px 8px;
        font-size: 12px;
        margin-left: 15px;
        flex-shrink: 0; /* Ngăn nút bị co lại */
    }

    /* CSS cho modal Dán link */
    #pasteLinkModal input[type="text"],
    #pasteLinkModal input[type="url"] {
        width: 100%;
        padding: 12px;
        margin-bottom: 15px;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-sizing: border-box;
        font-size: 16px;
    }

    /* === KẾT THÚC MÃ MỚI === */


/* Thêm CSS này */
#taskList .editable-cell {
    cursor: pointer;
    transition: background-color 0.2s;
}
#taskList .editable-cell:hover {
    background-color: #f0f8ff; /* Màu xanh Alice blue nhạt */
}

/* Kiểu cho input khi đang chỉnh sửa */
.editable-input {
    width: 95%;
    padding: 6px;
    border: 1px solid #007bff;
    border-radius: 4px;
    box-sizing: border-box; /* Đảm bảo input vừa khít với ô */
}

/* --- CSS MỚI: ẨN NÚT ĐIỀU HƯỚNG (SPINNERS) TRONG Ô NHẬP SỐ --- */
        
        /* Dành cho Chrome, Safari, Edge, Opera */
        input[type=number]::-webkit-outer-spin-button,
        input[type=number]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Dành cho Firefox */
        input[type=number] {
            -moz-appearance: textfield;
        }

</style>


    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <script src="xlsx.full.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="chart.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

    <div id="login-container">
        <div id="login-box">
            <span class="close-button" onclick="closeLoginModal()">&times;</span>

            <img src="PVGLPG.gif" alt="Logo" style="width: 120px; height: auto; margin-bottom: 20px;">
            <h2>Đăng nhập Hệ thống</h2>
            <form id="login-form">
                <input type="text" id="email"
                       value="bdsc***@pvgaslpg*****"
                       data-real-email="bdsc-cnmb@pvgaslpg.com.vn"
                       readonly
                       style="background-color: #e9ecef; cursor: not-allowed; text-align: center; color: #495057;">
                <input type="password" id="password" placeholder="Mật khẩu" required autofocus>
                <button type="submit" class="btn-primary">Đăng nhập</button>
                <p id="login-error" style="display: none;"></p>
            </form>
        </div>
    </div>

    <div id="container">
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px;">
            <img src="PVGLPG.gif" alt="Logo" style="width: 100px; height: auto;">
            <h1 style="color: #008037; font-weight: bold; text-transform: uppercase; text-align: center; flex-grow: 1;">
                LẬP VÀ THEO DÕI KẾ HOẠCH<br>AN TOÀN - CHẤT LƯỢNG - MÔI TRƯỜNG
            </h1>
            <div style="width: 150px;"></div>
        </div>

        <div class="button-group" style="padding-bottom: 10px; border-bottom: 1px solid #eee;">
            <div>
                <button class="btn-secondary" onclick="recalculateAllCostsAndReload()">Tải lại & Tính toán lại</button>
                <button class="btn-primary" onclick="openDataManagementModal()">Quản lý Dữ liệu</button>

                <button id="authButton" class="btn-info" onclick="promptForAuthentication()">Đăng nhập</button>
                <button id="logoutButton" class="btn-warning" style="display: none;" onclick="logoutUser()">Đăng xuất</button>
                <button id="deleteSelectedBtn" class="btn-danger" onclick="deleteSelectedTasks()" disabled>Xoá mục đã chọn</button>
                <button id="exportExcel1Btn" class="btn-success" onclick="exportToExcel(1)">Xuất Excel 1</button>
                <button id="exportExcel2Btn" class="btn-success" onclick="exportToExcel(2)" disabled>Xuất Excel 2</button>
            </div>
        </div>
        <div id="status"></div>

       <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px;">
    <h2 id="mainHeaderTitle">CHƯA CÓ TÊN CƠ SỞ</h2>
     <div> <label for="yearSelect" style="margin-right: 10px; font-weight: bold;">Năm:</label>
                <select id="yearSelect" onchange="changeYear(this.value)"></select>
                
                <button id="approvedPlanBtn" class="btn-secondary" onclick="openApprovedPlanModal()" style="margin-left: 10px;">KH đã duyệt</button>
             </div>
        </div>

        <div class="button-group" style="margin-bottom: 15px; justify-content: space-between;">
             <div>
                <button id="multiExecuteBtn" class="btn-info" onclick="openMultiExecutionModal()" disabled>Thực hiện công việc đã chọn</button>
                <button id="searchExecutionBtn" class="btn-primary" onclick="openSearchModal()">Tra cứu thực hiện</button>
             </div>
             <div style="display: flex; align-items: center;">
                <label for="planningModeToggle" style="margin-right: 10px; font-weight: bold;">Mở giao diện xây dựng kế hoạch</label>
                <input type="checkbox" id="planningModeToggle" onchange="togglePlanningColumns(this.checked)" disabled>
             </div>
        </div>

        <div id="summarySection"></div>

        <table id="taskList">
            <thead>
                <tr>
                    <th style="width: 2%;"><input type="checkbox" onchange="toggleAllCheckboxes(this)"></th>
                    <th class="col-tt" style="width: 3%;">TT</th>
                    <th class="col-noidung">Nội dung công việc</th>
					<th class="col-tagname">Tag Name</th>
                    <th class="col-dv-thuchien" style="width: 5%;">ĐV thực hiện</th>
                    
                    <th class="text-right col-kh-nam-truoc" style="width: 7%;">KH năm trước</th>
                    <th class="text-right col-th-nam-truoc" style="width: 7%;">Thực hiện năm trước</th>
                    
                    <th class="col-donvi">Đ.vị tính</th>
                    <th class="col-soluong">Số lượng</th>
                    <th class="col-tansuat-th">Tần suất TH</th>
                    <th class="text-right col-chiphi">Chi phí KH</th>
                    <th class="text-right col-chiphi-thuchien" style="width: 6%;">Chi phí thực hiện</th>
                    <th class="text-right col-kehoach-conlai" style="width: 6%;">Kế hoạch còn lại</th>
                    <th class="col-nam-phanbo">Năm PB</th>
                    <th class="col-chiphi-phanbo">CP phân bổ</th>
					
					<th class="col-capdo">Cấp độ</th>
<th class="col-cp-cap1">CP Cấp 1</th>
                    <th class="col-tg-batdau" style="width: 4%;">Thời điểm TH</th>
                    <th class="col-tg-hoanthanh" style="width: 4%;">TG hoàn thành</th>

                    <th class="col-ghichu">Ghi chú</th>
                    <th class="col-hoso" style="width: 3%;">Hồ sơ</th>
                    <th style="width: 5%;" class="col-action">Hành động</th>
                </tr>
            </thead>
            <tbody id="taskListBody"></tbody>
        </table>
    </div>

    <!-- Các modal giữ nguyên như file gốc -->
    <div id="dataModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <div id="modalTitle"></div>
            <div id="modalBody"></div>
            <div class="modal-footer">
                <div id="modal-footer-left" style="float: left;"></div>
                <button id="modalDeleteButton" class="btn-danger" style="display: none; float: left;">Xóa</button>
                <button id="modalSaveButton" class="btn-success">Lưu thay đổi</button>
            </div>
        </div>
    </div>

    <div id="dataManagementModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Quản lý Dữ liệu</h2>
            <div style="margin-top: 20px;">
                <h3>Nhập dữ liệu từ file Excel</h3>
                <input type="file" id="excelFile" accept=".xlsx, .xls">
                <p><small><i>Chú ý: để chương trình nhận đúng dữ liệu, hãy định dạng các dữ liệu số trong file Excel ở định dạng General.</i></small></p>
                <button class="btn-primary" onclick="importData()" style="margin-top: 10px;">Nhập dữ liệu</button>
            </div>
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ccc;">
                <h3>Xóa toàn bộ dữ liệu</h3>
                <p style="color: #dc3545;"><strong>Cảnh báo:</strong> Hành động này không thể hoàn tác.</p>
                <button class="btn-danger" onclick="openDeleteAllDataModal()">Xoá tất cả</button>
            </div>
            <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #ccc;">
                <h3>Quyền Admin</h3>
                <button id="unlockButton" class="btn-warning" onclick="openAdminAuthModal()">Admin/Cấp phép chỉnh sửa</button>
                
                <div id="adminControls" style="display: none; margin-top: 15px; text-align: left;">
                    
                    <div style="margin-bottom: 10px;">
                        <input type="checkbox" id="editModeCheckbox" onchange="toggleEditMode(this.checked)" style="width: auto;">
                        <label for="editModeCheckbox" style="font-weight: bold; color: #007bff;">Cho phép sửa đổi, thêm, xóa dữ liệu</label>
                    </div>

                    <div style="margin-bottom: 10px; padding: 10px; background-color: #fff3cd; border: 1px solid #ffeeba; border-radius: 4px;">
                        <input type="checkbox" id="lockYearCheckbox" onchange="toggleYearLock(this.checked)" style="width: auto;">
                        <label for="lockYearCheckbox" style="font-weight: bold; color: #dc3545;">KHÓA HOÀN TOÀN DỮ LIỆU NĂM <span id="lockYearLabel"></span></label>
                        <br>
                        <small style="margin-left: 20px; color: #856404;">(Khi khóa: Không thể thực hiện công việc, tự động tắt chế độ sửa đổi)</small>
                    </div>

                </div>
            </div>
        
		
		</div>
    </div>

    <div id="deleteAllDataModal" class="modal">
        <div class="modal-content delete-confirm-modal">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Xác nhận xóa toàn bộ dữ liệu</h2>
            <p style="color: #dc3545; font-weight: bold;">CẢNH BÁO: Bạn sắp xóa TOÀN BỘ dữ liệu. Hành động này không thể hoàn tác.</p>
            <p>Vui lòng nhập đầy đủ thông tin đăng nhập để xác nhận:</p>
            <div>
                <input type="text" id="deleteConfirmEmail" placeholder="Email đăng nhập">
                <input type="password" id="deleteConfirmPassword" placeholder="Mật khẩu">
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeAllModals()">Hủy</button>
                <button class="btn-danger" onclick="confirmDeleteAllData()">Xác nhận xóa toàn bộ</button>
            </div>
        </div>
    </div>

    <div id="uploadPdfModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2 id="uploadPdfModalTitle">Tải lên Hồ sơ PDF</h2>
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center mt-4">
                 <input type="file" id="pdf_file_input" accept=".pdf" class="block w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold
                    file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
            </div>
            <div class="modal-footer">
                <button id="uploadPdfButton" class="btn-primary">Tải Lên</button>
            </div>
        </div>
    </div>

    <div id="exportOptionsModal" class="modal">
        <div class="modal-content export-options-modal">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Tùy chọn Xuất file Excel</h2>
            <p>Vui lòng chọn định dạng file bạn muốn xuất:</p>
            
            <div style="display: flex; justify-content: space-around; margin-top: 20px; gap: 15px; flex-wrap: wrap;">
                
                <button class="btn-primary" style="flex: 1; min-width: 200px; padding: 15px;" onclick="exportPlainDataExcel()">
                    1. File Excel (.xlsx)
                    <br><small>(Có công thức, không định dạng màu)</small>
                </button>
                
                <button class="btn-success" style="flex: 1; min-width: 200px; padding: 15px;" onclick="exportFormattedExcel_HTML()">
                    2. File Excel 97 (.xls)
                    <br><small>(Có chữ đậm nhạt, có màu, không công thức)</small>
                </button>
                
                <button class="btn-info" style="flex: 1; min-width: 200px; padding: 15px;" onclick="exportToClipboard()">
                    3. Sao chép vào Clipboard
                    <br><small>(Dữ liệu có công thức, để dán thủ công vào Excel)</small>
                </button>
                </div>
        </div>
    </div>

    <div id="planningModeModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <span class="close-button" onclick="closePlanningModal()">&times;</span>
            <h2>Chọn phạm vi xem Kế hoạch</h2>
            <p>Vui lòng chọn dữ liệu bạn muốn hiển thị ở chế độ lập kế hoạch:</p>
            <div id="planningModeOptions" style="margin-top: 20px; max-height: 40vh; overflow-y: auto;">
            </div>
        </div>
    </div>

    <div id="summaryDetailModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Chi tiết thực hiện theo từng đơn vị năm <span id="summaryDetailYear"></span></h2>
            <div id="summaryDetailContent" class="summary-details-grid">
            </div>
        </div>
    </div>
<div id="approvedPlanModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Kế hoạch đã duyệt năm <span id="approvedPlanYear"></span></h2>
            <div id="approvedPlanLinks" style="margin-top: 20px; max-height: 60vh; overflow-y: auto;">
                </div>
            <div class="modal-footer">
                <button id="addPlanLinkBtn" class="btn-primary" onclick="openAddPlanLinkModal()">Nhập QĐ</button>
            </div>
        </div>
    </div>

    <div id="addPlanLinkModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Thêm Kế hoạch đã duyệt</h2>
            <p>Vui lòng chọn phương thức:</p>
            <div style="display: flex; justify-content: space-around; margin-top: 20px; gap: 15px;">
                <button class="btn-primary" style="flex: 1; padding: 15px;" onclick="openPasteLinkModal()">1. Dán link có sẵn</button>
                <button class="btn-success" style="flex: 1; padding: 15px;" onclick="startPlanUploadFlow()">2. Tải file từ máy tính</button>
            </div>
        </div>
    </div>

    <div id="pasteLinkModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h2>Dán link tài liệu</h2>
            <div style="margin-top: 20px;">
                <input type="text" id="pastedLinkName" placeholder="Tên hiển thị (ví dụ: Quyết định 123)" style="width: 100%; box-sizing: border-box;">
                <input type="url" id="pastedLinkUrl" placeholder="https://..." style="width: 100%; box-sizing: border-box;">
            </div>
            <div class="modal-footer">
                <button class="btn-success" onclick="savePastedLink()">Lưu link</button>
            </div>
        </div>
    </div>

      <div id="adminPasswordModal" class="modal">
        <div class="modal-content" style="max-width: 400px; text-align: center;">
            <span class="close-button" onclick="closeAllModals()">&times;</span>
            <h3>Xác thực quyền Admin</h3>
            <p>Vui lòng nhập mật khẩu quản trị:</p>
            <input type="password" id="adminPasswordInput" placeholder="Mật khẩu..." style="width: 100%; padding: 10px; margin-bottom: 15px; border: 1px solid #ccc; border-radius: 4px;">
            <div style="text-align: right;">
                <button class="btn-secondary" onclick="closeAllModals()">Hủy</button>
                <button class="btn-primary" onclick="submitAdminPassword()">Xác nhận</button>
            </div>
        </div>
    </div>
	

<button id="scrollToTopBtn" title="Lên đầu trang" onclick="scrollToTop()">&uarr;</button>

    <div style="text-align: center; padding: 20px; color: #888; font-size: 12px;">
      Contact: hai.nm@pvgaslpg.com.vn
    </div>

    <script type="module">
    // Thêm hai hàm chuyển đổi vào đầu script
    function convertTTForStorage(tt) {
        return String(tt).replace(/\./g, ',');
    }

    function convertTTForDisplay(tt) {
        return String(tt).replace(/,/g, '.');
    }

// === BẮT ĐẦU MÃ MỚI: HÀM HỖ TRỢ SỐ LA MÃ ===
    function numberToRoman(num) {
        const romanMap = [
            { value: 1000, numeral: 'M' },
            { value: 900, numeral: 'CM' },
            { value: 500, numeral: 'D' },
            { value: 400, numeral: 'CD' },
            { value: 100, numeral: 'C' },
            { value: 90, numeral: 'XC' },
            { value: 50, numeral: 'L' },
            { value: 40, numeral: 'XL' },
            { value: 10, numeral: 'X' },
            { value: 9, numeral: 'IX' },
            { value: 5, numeral: 'V' },
            { value: 4, numeral: 'IV' },
            { value: 1, numeral: 'I' }
        ];
        let result = '';
        if (num <= 0) return '';
        for (const { value, numeral } of romanMap) {
            while (num >= value) {
                result += numeral;
                num -= value;
            }
        }
        return result;
    }

    function romanToNumber(roman) {
        if (!roman) return 0;
        const romanMap = { 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000 };
        let result = 0;
        const r = roman.toUpperCase(); // Đảm bảo là chữ hoa
        for (let i = 0; i < r.length; i++) {
            const current = romanMap[r[i]];
            const next = romanMap[r[i + 1]];
            if (next && current < next) {
                result -= current;
            } else {
                result += current;
            }
        }
        return result;
    }
    // === KẾT THÚC MÃ MỚI ===
	
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";
    import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, EmailAuthProvider, reauthenticateWithCredential, signOut } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-auth.js";
    import { getDatabase, ref, set, get, update, remove, child, push, query, orderByChild, equalTo, onValue, off } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-database.js";

    const firebaseConfig = {
  apiKey: "AIzaSyApKOu598qpanbjPRYdDYBplMFiM402HNw",
  authDomain: "congtacbdsc2.firebaseapp.com",
  databaseURL: "https://congtacbdsc2-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "congtacbdsc2",
  storageBucket: "congtacbdsc2.firebasestorage.app",
  messagingSenderId: "528060092768",
  appId: "1:528060092768:web:472d6ece2344795dff4e05",
  measurementId: "G-2QYPT9MSX8"
    };
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);

    const CLIENT_ID = "588583798336-o4gjnfqaupmmdp8mi38o9m8r4n0bbghs.apps.googleusercontent.com";
    const DISCOVERY_DOCS = ["https://www.googleapis.com/discovery/v1/apis/drive/v3/rest"];
    const SCOPES = "https://www.googleapis.com/auth/drive.file";
    const FOLDER_ID = "1uyHJHfNFLIdPQbYu1uF4zliORCM6QK3P";

    const statusDiv = document.getElementById('status');
    let selectedTasks = new Set();
    let selectedJustifications = new Set();
    let executionGroups = new Map();
    let docDataMap = new Map();
let parentNoiDungMap = new Map();
    let tokenClient;
    let gapiReady = false;
let gisInited = false;
    let editModeStatusByYear = {};
	let lockedYears = {};
    let currentYear = new Date().getFullYear();
    let planningModeByYear = {};
    let isAuthenticated = false;
    let activeExportType = 'simplified';
    let activeCharts = [];

let cachedEquipmentList = null; // Khởi tạo là null

async function loadEquipmentList() {
    // Cơ chế Cache: Nếu đã có dữ liệu trong RAM thì dùng luôn, không tải lại
    if (cachedEquipmentList !== null) return;

    try {
        statusDiv.innerText = 'Đang tải danh sách thiết bị từ CSDL...'; 
        
        const refDb = ref(db, 'Quanlythietbi');
        const snapshot = await get(refDb);
        
        cachedEquipmentList = []; // Khởi tạo mảng rỗng
        
        if (snapshot.exists()) {
            const rootData = snapshot.val(); // Dữ liệu gốc Quanlythietbi
            
            // 1. Vòng lặp cấp 1: Duyệt qua các node La Mã (I, II, III...)
            for (const romanKey in rootData) {
                const romanNode = rootData[romanKey];
                
                // Kiểm tra an toàn: node La Mã phải là object chứa con
                if (romanNode && typeof romanNode === 'object') {
                    
                    // 2. Vòng lặp cấp 2: Duyệt qua các node Số đếm (1, 2, 3...) bên trong node La Mã
                    for (const numericKey in romanNode) {
                        const itemNode = romanNode[numericKey];

                        // Kiểm tra an toàn: node Số đếm phải là object chứa dữ liệu
                        if (itemNode && typeof itemNode === 'object') {
                            
                            // 3. Lấy dữ liệu Tagname và TenThietBi
                            // Kiểm tra các biến thể viết hoa/thường để đảm bảo không sót
                            const validTag = itemNode.Tagname || itemNode.TagName || itemNode.tagname;
                            const deviceName = itemNode.TenThietBi || itemNode.tenThietBi || '';

                            // Chỉ đưa vào danh sách nếu tìm thấy Tagname thực sự (khác rỗng)
                            if (validTag && String(validTag).trim() !== '') {
                                 cachedEquipmentList.push({
                                    tag: String(validTag).trim(), 
                                    name: String(deviceName).trim()
                                });
                            }
                        }
                    }
                }
            }
            
            // 4. Sắp xếp danh sách A-Z theo Tagname để dễ tìm kiếm
            cachedEquipmentList.sort((a, b) => a.tag.localeCompare(b.tag));
        }
        
        console.log(`Đã tải xong: ${cachedEquipmentList.length} thiết bị chuẩn từ cấu trúc phân cấp.`);
        statusDiv.innerText = ''; 
    } catch (error) {
        console.error("Lỗi tải danh sách thiết bị:", error);
        cachedEquipmentList = []; 
        statusDiv.innerText = '';
    }
}

    // =======================================================
// === CÁC HÀM HELPER CHO LOGIC NHẬP LIỆU MỚI (V4) =======
// =======================================================

/**
 * Tìm giá trị trong một hàng (row) dựa trên danh sách các khóa (keys) có thể có.
 * Ưu tiên các khóa xuất hiện trước trong danh sách.
 */
const findValue = (row, keys, headers) => {
    for (const key of keys) {
        // Tìm header gốc trong file Excel (không phân biệt hoa thường/khoảng trắng)
        const lowerKey = key.toLowerCase().trim();
        const originalHeader = headers.find(h => String(h).toLowerCase().trim() === lowerKey);

        // Nếu tìm thấy header và hàng đó có giá trị cho header này
        if (originalHeader && row[originalHeader] !== undefined && row[originalHeader] !== null && row[originalHeader] !== '') {
            // Kiểm tra xem giá trị có phải là chuỗi rỗng không
            if (String(row[originalHeader]).trim() === '') {
                 continue; // Bỏ qua chuỗi rỗng, thử key tiếp theo
            }
            return row[originalHeader]; // Trả về giá trị tìm thấy
        }
    }
    // Nếu không tìm thấy giá trị hợp lệ nào sau khi thử hết keys
    return undefined;
};


/**
 * Đọc dữ liệu các lần thực hiện từ một hàng Excel.
 */
const readExecutionsForRow = (row, headers) => {
    const executions = [];
    let i = 1;
    const headersSet = new Set(headers.map(h => String(h).toLowerCase().trim())); // Để kiểm tra nhanh

    while (true) {
        const ngayTHKey = `ngày th (${i})`;
        const soLuongKey = `số lượng (${i})`;
        const donGiaKey = `đơn giá (${i})`;
        const thanhTienKey = `thành tiền (${i})`;
        const timestampKey = `timestamp (${i})`;
        const hoSoLinkKey = `hồ sơ link (${i})`;

        // Tìm header gốc tương ứng trong file Excel
        const originalNgayTH = headers.find(h => String(h).toLowerCase().trim() === ngayTHKey);
        const originalSoLuong = headers.find(h => String(h).toLowerCase().trim() === soLuongKey);
        const originalDonGia = headers.find(h => String(h).toLowerCase().trim() === donGiaKey);
        const originalThanhTien = headers.find(h => String(h).toLowerCase().trim() === thanhTienKey);
        const originalTimestamp = headers.find(h => String(h).toLowerCase().trim() === timestampKey);
        const originalHoSoLink = headers.find(h => String(h).toLowerCase().trim() === hoSoLinkKey);

        // Chỉ dừng nếu không có BẤT KỲ cột nào của lần thực hiện thứ 'i' tồn tại
        if (!originalNgayTH && !originalSoLuong && !originalDonGia && !originalThanhTien && !originalTimestamp && !originalHoSoLink) {
            break; // Hết cột thực hiện
        }

        const ngayThucHien = originalNgayTH ? row[originalNgayTH] : '';
        const dvt = originalSoLuong ? parseNumber(row[originalSoLuong]) : 0;
        const donGia = originalDonGia ? parseNumber(row[originalDonGia]) : 0;
        const thanhTien = originalThanhTien ? parseNumber(row[originalThanhTien]) : 0;
        const timestamp = originalTimestamp ? row[originalTimestamp] : null;
        const hoSoLink = originalHoSoLink ? row[originalHoSoLink] : null;

        // Chỉ thêm vào nếu có ít nhất một giá trị hợp lệ
        if (ngayThucHien || dvt > 0 || donGia > 0 || thanhTien > 0 || timestamp || hoSoLink) {
            executions.push({
                ngayThucHien: ngayThucHien || '',
                dvt: dvt,
                donGia: donGia,
                thanhTien: thanhTien,
                timestamp: timestamp || null,
                lanThucHien: i, // Giữ lại số thứ tự lần thực hiện
                hoSoLink: hoSoLink || null
            });
        }
        i++;
    }
    return executions;
};

/**
 * Kiểm tra xem có bất kỳ header nào trong danh sách 'keys'
 * tồn tại trong Set các header của file Excel hay không.
 */
const hasHeaderForField = (keys, headersSet) => {
    for (const key of keys) {
        // Đảm bảo so sánh không phân biệt hoa thường
        if (headersSet.has(key.toLowerCase().trim())) return true;
    }
    return false;
};

// --- Đảm bảo các hàm helper khác này cũng tồn tại ở global scope ---
// (Bạn có thể đã có chúng từ mã nguồn gốc)
// function convertTTForStorage(tt) { ... }
// function convertTTForDisplay(tt) { ... }
// const parseNumber = (str) => { ... };
// const parseFormattedNumber = (str) => { ... };
// function getParentCollectionName() { ... }

// =======================================================
// === KẾT THÚC KHỐI HELPER =============================
// =======================================================

const parseNumber = (str) => {
        if (str === null || str === undefined) return 0;
        let s = String(str).trim();
        if (s === '') return 0;
        const lastDot = s.lastIndexOf('.');
        const lastComma = s.lastIndexOf(',');
        let numberStr;
        if (lastComma > lastDot) {
            numberStr = s.replace(/\./g, '').replace(',', '.');
        } else {
            numberStr = s.replace(/,/g, '');
        }
        const result = parseFloat(numberStr);
        return isNaN(result) ? 0 : result;
    };
    const parseFormattedNumber = (str) => {
        if (str === null || str === undefined) return 0;
        let s = String(str).trim();
        if (s === '') return 0;
        const numberStr = s.replace(/\./g, '').replace(',', '.');
        const result = parseFloat(numberStr);
        return isNaN(result) ? 0 : result;
    };

    function getParentCollectionName() {
        return `congViecMe${currentYear}`;
    }

// === CÁC HÀM HELPER CHO LOGIC IMPORT MỚI ===

/**
 * Hàm chuẩn hóa TT: Loại bỏ khoảng trắng thừa, chuyển dấu phẩy thành dấu chấm,
 * loại bỏ dấu chấm ở cuối câu (ví dụ "1." -> "1").
 */
function normalizeTT(rawTT) {
    if (!rawTT) return '';
    return String(rawTT)
        .trim()                  // Xóa khoảng trắng đầu cuối
        .replace(/\s+/g, '')     // Xóa khoảng trắng ở giữa (VD: "1. 1" -> "1.1")
        .replace(/,/g, '.')      // Chuyển phẩy thành chấm (VD: "1,1" -> "1.1")
        .replace(/\.$/, '')      // Xóa dấu chấm cuối cùng (VD: "A." -> "A")
        .replace(/^\./, '');     // Xóa dấu chấm đầu tiên (nếu có)
}

/**
 * Hàm xác định cấp độ của TT dựa trên Regex (I|II|III|IV|V|VI|VII|VIII|IX|X|XI|XII|XIII|XIV|XV|XVI|XVII|XVIII|XIX|XX|XXI|XXII|XXIII|XXIV|XXV|XXVI|XXVII|XXVIII|XXIX|XXX|XXXI|XXXII|XXXIII|XXXIV|XXXV|XXXVI|XXXVII|XXXVIII|XXXIX)
 */
/**
 * Hàm xác định cấp độ của TT dựa trên Regex - PHIÊN BẢN STRICT CASE (Phân biệt Hoa/Thường)
 */
/**
 * Hàm xác định cấp độ của TT - PHIÊN BẢN SỬ DỤNG DẤU SAO (*)
 */
function detectLevel(tt) {
    if (!tt) return 'unknown';

    // 1. Cấp 1 (Parent): A, B, C...
    const isLevel1_Alpha = /^[A-Z]$/;

    // 2. Cấp 2 (Child - Roman): I, II...
    const isLevel2_Roman = /^(I|II|III|IV|V|VI|VII|VIII|IX|X|XI|XII|XIII|XIV|XV|XVI|XVII|XVIII|XIX|XX)$/;

    // 3. Cấp 3 (Grandchild - Integer): 1, 2...
    const isLevel3_Integer = /^\d+$/;

    // 4. Cấp 4 (Nút Lá Task): 1.1, 2.3... (Không chứa dấu *)
    // Regex: Bắt đầu bằng số, chứa ít nhất một dấu chấm/phẩy, kết thúc bằng số
    const isLevel4_Decimal = /^\d+(?:[.,]\d+)+$/;

    // 5. Giải trình (Justification): [TaskTT]*[Số]
    // Ví dụ: 2*1, 3.2*1, A*1
    // Logic: Phần đầu không chứa *, theo sau là dấu *, kết thúc bằng số nguyên.
    const isJustification = /^[^*]+\*\d+$/; 

    // 6. Giải trình con (SubJustification): [TaskTT]*[Số].[Số]
    // Ví dụ: 2*1.1, 3.2*1.2
    // Logic: Phần đầu không chứa *, theo sau là *, số, dấu chấm/phẩy, số.
    const isSubJustification = /^[^*]+\*\d+[.,]\d+$/;

    // --- LOGIC PHÂN LOẠI ---
    
    if (isLevel2_Roman.test(tt)) return 'child';
    if (isLevel1_Alpha.test(tt)) return 'parent';
    
    // Ưu tiên kiểm tra giải trình trước
    if (isSubJustification.test(tt)) return 'subJustification';
    if (isJustification.test(tt)) return 'justification';

    if (isLevel4_Decimal.test(tt)) return 'greatGrandchild';
    if (isLevel3_Integer.test(tt)) return 'grandchild';

    return 'unknown';
}


function buildImportUpdates_Merge(jsonData, headers) {
    console.log('=== START Smart Import Logic (Format: Asterisk *) ===');
    const updates = {};
    const rootPath = getParentCollectionName();
    const headersSet = new Set(headers.map(h => String(h).toLowerCase().trim()));
    const hasExecutionColumns = headers.some(h => String(h).toLowerCase().trim().startsWith('ngày th'));

    let state = {
        parent: null, child: null, grandchild: null, greatGrandchild: null,
        lastLeaf: null, lastJustification: null 
    };

    const masterDataFieldMapping = {
         noiDung: ['đầu việc/dự án', 'đầu việc/ dự án', 'đầu việc', 'dự án', 'nội dung', 'nội dung công việc'],
         //tagName: ['tagname', 'tag name', 'mã tag', 'ký hiệu', 'tag'],
		 donVi: ['đơn vị tính', 'đ.vị tính', 'đơn vị', 'đvt'],
         soLuong: ['số lượng', 'số lượng vật tư'],
         donGia: ['đơn giá (gt)'],
         chiPhi: ['chi phí', 'chi phi', 'chi phí kế hoạch', 'chi phí kh'],
         tanSuatTH: ['tần suất th', 'tần suất thực hiện'],
         dvThucHien: ['đv th.hiện', 'đơn vị thực hiện', 'đơn vị th', 'đv thực hiện'],
         namPhanBo: ['năm phân bổ', 'năm pb', 'số năm phân bổ', 'nam phan bo'],
         capDo: ['cấp độ', 'cap do'],
         khNamTruoc: ['kh năm trước', 'kế hoạch năm trước'],
         thucHienNamTruoc: ['thực hiện năm trước', 'th nam truoc', 'th năm trước'],
         tgBatDau: ['thời điểm th', 'thời gian thực hiện', 'thời điểm thực hiện', 'thời gian th'],
         tgHoanThanh: ['tg hoàn thành', 'tg hoan thanh', 'thời gian hoàn thành'],
         ghiChu: ['ghi chú', 'ghi chu']
    };

    jsonData.forEach((row, index) => {
        const rawTT = String(row.TT || '');
        const tt = normalizeTT(rawTT); 
        if (!tt) return;

        let level = detectLevel(tt);
        
        if (tt === 'I') {
            if (state.parent) level = 'child'; else level = 'parent'; 
        }
        
        const storageTT = convertTTForStorage(tt); // Chuyển "." thành ","
        // Lưu ý: Dấu "*" không bị thay đổi bởi convertTTForStorage

        let currentPath = '';
        let isTask = false;
        let isLeaf = false;

        try {
            switch (level) {
                case 'parent': 
                    currentPath = `${rootPath}/${storageTT}`;
                    state.parent = currentPath;
                    state.child = null; state.grandchild = null; state.greatGrandchild = null; state.lastLeaf = null;
                    isTask = true;
                    break;

                case 'child': 
                    if (!state.parent) throw new Error(`Mục "${tt}" thiếu cấp cha (A, B...).`);
                    currentPath = `${state.parent}/children/${storageTT}`;
                    state.child = currentPath;
                    state.grandchild = null; state.greatGrandchild = null; state.lastLeaf = null;
                    isTask = true;
                    break;

                case 'grandchild': 
                    if (!state.child) throw new Error(`Mục "${tt}" thiếu cấp cha La Mã (I, II...).`);
                    currentPath = `${state.child}/grandchildren/${storageTT}`;
                    state.grandchild = currentPath;
                    state.greatGrandchild = null;
                    state.lastLeaf = currentPath; 
                    isTask = true;
                    isLeaf = true; 
                    const tagKeys = ['tag name', 'tagname', 'mã tag', 'tag'];
                    if (hasHeaderForField(tagKeys, headersSet)) {
                        const tagVal = findValue(row, tagKeys, headers);
                        if (tagVal !== undefined && tagVal !== null && String(tagVal).trim() !== '') {
                            updates[`${currentPath}/tagName`] = String(tagVal).trim();
                        }
                    }

					break;

                case 'greatGrandchild': 
                    const parentOfL4 = storageTT.substring(0, storageTT.lastIndexOf(',')); 
                    if (!state.grandchild || !state.grandchild.endsWith(`/${parentOfL4}`)) {
                        if (!state.grandchild) throw new Error(`Mục "${tt}" thiếu cấp cha (1, 2...).`);
                    }
                    currentPath = `${state.grandchild}/greatGrandchildren/${storageTT}`;
                    state.greatGrandchild = currentPath;
                    state.lastLeaf = currentPath;
                    isTask = true;
                    isLeaf = true;
                    if (state.grandchild) {
                        updates[`${state.grandchild}/hasChildren`] = true;
                        updates[`${state.grandchild}/executions`] = null; 
                    }
                    break;

                case 'justification': // [Task]*[Index] -> 3,2*1
                    // Logic tìm cha: Tách theo dấu sao (*).
                    // storageTT: "3,2*1" -> Cha là "3,2"
                    const starIndex = storageTT.lastIndexOf('*');
                    if (starIndex === -1) throw new Error(`Giải trình "${tt}" sai định dạng (thiếu dấu *).`);
                    
                    const parentTaskTT = storageTT.substring(0, starIndex); // "3,2"
                    
                    // Kiểm tra khớp với lastLeaf
                    if (!state.lastLeaf || !state.lastLeaf.endsWith(`/${parentTaskTT}`)) {
                        throw new Error(`Giải trình "${tt}" (Cha là ${parentTaskTT}) không khớp với công việc liền trước.`);
                    }
                    
                    currentPath = `${state.lastLeaf}/justifications/${storageTT}`;
                    state.lastJustification = currentPath;
                    break;

                case 'subJustification': // [ParentJust].[Index] -> 3,2*1,1 (storage)
                    // Logic tìm cha: Tách theo dấu phẩy cuối cùng
                    // storageTT: "3,2*1,1" -> Cha là "3,2*1"
                    const lastCommaIdx = storageTT.lastIndexOf(',');
                    if (lastCommaIdx === -1) throw new Error(`Giải trình con "${tt}" sai định dạng.`);
                    
                    const parentJustTT = storageTT.substring(0, lastCommaIdx); // "3,2*1"
                    
                    if (!state.lastJustification || !state.lastJustification.endsWith(`/${parentJustTT}`)) {
                         throw new Error(`Giải trình con "${tt}" (Cha là ${parentJustTT}) không khớp với giải trình liền trước.`);
                    }

                    currentPath = `${state.lastJustification}/subJustifications/${storageTT}`;
                    updates[`${state.lastJustification}/hasSubJustifications`] = true;
                    updates[`${state.lastJustification}/chiPhi`] = 0; 
                    break;

                default:
                    return;
            }

            const data = {};
            updates[`${currentPath}/tt`] = storageTT;

            for (const [field, keys] of Object.entries(masterDataFieldMapping)) {
                if (hasHeaderForField(keys, headersSet)) {
                    const value = findValue(row, keys, headers);
                    if (value !== undefined) {
                        if (['soLuong', 'donGia', 'khNamTruoc', 'chiPhi', 'thucHienNamTruoc', 'namPhanBo'].includes(field)) {
                            data[field] = parseNumber(value);
                        } else if (field === 'tanSuatTH') {
                            data[field] = (value === '' || value === null) ? 1 : (parseInt(value, 10) || 0);
                        } else {
                            data[field] = value;
                        }
                    } else {
                        data[field] = null; 
                    }
                }
            }

            if ((isLeaf && isTask) && data.namPhanBo && data.namPhanBo > 0) {
                 const cp = data.chiPhi || 0;
                 data.chiPhiPhanBo = Math.round(cp / data.namPhanBo);
            } else if (isLeaf && isTask) {
                 data.chiPhiPhanBo = 0;
            }

            if (isLeaf && isTask && hasExecutionColumns) {
                const executions = readExecutionsForRow(row, headers);
                if (executions.length > 0) {
                    data.executions = executions.reduce((obj, exec, i) => {
                        obj[exec.lanThucHien || (i + 1)] = exec;
                        return obj;
                    }, {});
                } else {
                    data.executions = null;
                }
            }

            for (const field in data) {
                updates[`${currentPath}/${field}`] = data[field];
            }

            if (isTask) {
                if (updates[`${currentPath}/chiPhiThucHien`] === undefined) updates[`${currentPath}/chiPhiThucHien`] = 0;
                if (updates[`${currentPath}/keHoachConLai`] === undefined) updates[`${currentPath}/keHoachConLai`] = 0;
            }

        } catch (e) {
            console.error(`Lỗi dòng ${index + 2} (TT: ${tt}): ${e.message}`);
        }
    });

    console.log(`=== END Smart Import (Asterisk). Total updates: ${Object.keys(updates).length} ===`);
    return updates;
}

// 1. Hàm mở Modal nhập mật khẩu (Thay thế prompt)
    window.openAdminAuthModal = function() {
        // Nếu đã là Admin thì hiện controls luôn
        const currentUser = auth.currentUser;
        if (currentUser && currentUser.email === "admin@pvgaslpg.com.vn") {
            showAdminControls();
            return;
        }
        
        // Nếu chưa thì mở modal nhập pass
        document.getElementById('adminPasswordInput').value = '';
        document.getElementById('adminPasswordModal').style.display = 'block';
        document.getElementById('adminPasswordInput').focus();
    };

    // 2. Hàm xử lý khi bấm xác nhận mật khẩu
    window.submitAdminPassword = async function() {
        const password = document.getElementById('adminPasswordInput').value;
        const adminEmail = "admin@pvgaslpg.com.vn";
        const confirmBtn = document.querySelector('#adminPasswordModal .btn-primary');

        if (!password) return;

        try {
            confirmBtn.disabled = true;
            confirmBtn.textContent = "Đang kiểm tra...";
            
            await signInWithEmailAndPassword(auth, adminEmail, password);
            
            closeAllModals(); // Đóng modal mật khẩu
            openDataManagementModal(); // Mở lại modal quản lý (để refresh giao diện)
            statusDiv.className = 'success';
            statusDiv.innerText = "Xác thực Admin thành công.";
            
        } catch (error) {
            console.error(error);
            alert("Mật khẩu không chính xác.");
        } finally {
            confirmBtn.disabled = false;
            confirmBtn.textContent = "Xác nhận";
        }
    };
    
    // Hỗ trợ ấn Enter trong ô mật khẩu
    document.getElementById('adminPasswordInput').addEventListener("keypress", function(event) {
        if (event.key === "Enter") {
            event.preventDefault();
            submitAdminPassword();
        }
    });

    // 3. Hàm hiển thị giao diện Admin (Controls)
    function showAdminControls() {
        document.getElementById('unlockButton').style.display = 'none';
        document.getElementById('adminControls').style.display = 'block';
        
        // Cập nhật trạng thái các checkbox
        document.getElementById('editModeCheckbox').checked = (editModeStatusByYear[currentYear] === true);
        document.getElementById('lockYearCheckbox').checked = (lockedYears[currentYear] === true);
        document.getElementById('lockYearLabel').innerText = currentYear;
        
        // Logic ràng buộc: Nếu đang KHÓA thì disable nút Edit Mode
        document.getElementById('editModeCheckbox').disabled = (lockedYears[currentYear] === true);
    }

    // 4. [MỚI] Hàm Toggle Khóa Năm
    window.toggleYearLock = async function(isLocked) {
        if (!isAuthenticated) return showAuthError();

        try {
            const updates = {};
            // Cập nhật trạng thái khóa
            updates[`settings/global/lockedYears/${currentYear}`] = isLocked;

            // Nếu KHÓA -> Tự động TẮT Edit Mode
            if (isLocked) {
                updates[`settings/global/editModeStatus/${currentYear}`] = false;
                document.getElementById('editModeCheckbox').checked = false;
                document.getElementById('editModeCheckbox').disabled = true;
            } else {
                // Nếu MỞ KHÓA -> Cho phép checkbox Edit hoạt động lại
                document.getElementById('editModeCheckbox').disabled = false;
            }

            await update(ref(db), updates);
            
        } catch (error) {
            console.error("Lỗi khi khóa/mở khóa năm:", error);
            alert("Lỗi hệ thống. Vui lòng thử lại.");
            // Revert checkbox UI nếu lỗi
            document.getElementById('lockYearCheckbox').checked = !isLocked;
        }
    };

    // === BẮT ĐẦU MÃ MỚI ===

    /**
     * Mở modal hiển thị danh sách Kế hoạch đã duyệt (KHĐD) cho năm hiện tại.
     * Hoạt động ngay cả khi chưa đăng nhập Firebase.
     */
    window.openApprovedPlanModal = async function() {
        const modal = document.getElementById('approvedPlanModal');
        const linksContainer = document.getElementById('approvedPlanLinks');
        const addBtn = document.getElementById('addPlanLinkBtn');
        
        document.getElementById('approvedPlanYear').textContent = currentYear;
        linksContainer.innerHTML = '<p class="loading-text">Đang tải danh sách...</p>';
        modal.style.display = 'block';

        // Hiển thị/ẩn nút "Nhập QĐ" dựa trên trạng thái đăng nhập Firebase
        addBtn.style.display = isAuthenticated ? 'block' : 'none';

        try {
            // Đường dẫn lưu trữ mới, độc lập với 'congViecMeYYYY'
            const dbPath = `approved_plans/${currentYear}`;
            const planRef = ref(db, dbPath);
            const snapshot = await get(planRef);

            if (snapshot.exists()) {
                const data = snapshot.val();
                let html = '';
                // Sắp xếp các link theo thời gian thêm (mới nhất trước)
                const sortedKeys = Object.keys(data).sort((a, b) => 
                    (data[b].timestamp || 0) - (data[a].timestamp || 0)
                );

                for (const key of sortedKeys) {
                    const link = data[key];
                    if (!link.url) continue; // Bỏ qua nếu dữ liệu không có url

                    // Chỉ hiển thị nút Xóa khi đã đăng nhập và cho phép chỉnh sửa
                    const canEdit = isAuthenticated && editModeStatusByYear[currentYear] === true;
const deleteBtnHtml = canEdit ? 
    `<button class="btn-danger btn-action plan-link-delete-btn" onclick="deleteApprovedPlanLink('${key}', '${link.name || link.url}')">Xóa</button>` : '';
                    
                    html += `<div class="plan-link-item">
                                <a href="${link.url}" target="_blank" title="${link.url}">${link.name || link.url}</a>
                                ${deleteBtnHtml}
                             </div>`;
                }
                linksContainer.innerHTML = html || '<p class="empty-text">Chưa có kế hoạch nào được duyệt cho năm này.</p>';
            } else {
                linksContainer.innerHTML = '<p class="empty-text">Chưa có kế hoạch nào được duyệt cho năm này.</p>';
            }
        } catch (error) {
            console.error("Lỗi khi tải Kế hoạch đã duyệt:", error);
            linksContainer.innerHTML = `<p class="empty-text" style="color: red;">Lỗi tải dữ liệu: ${error.message}</p>`;
        }
    }

    /**
     * Xóa một link Kế hoạch đã duyệt khỏi CSDL.
     * Yêu cầu xác thực Firebase.
     */
    window.deleteApprovedPlanLink = async function(linkKey, linkName) {
        if (!isAuthenticated) return showAuthError();
        if (!confirm(`Bạn có chắc chắn muốn xóa link này không?\n\n${linkName}`)) return;

        try {
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đang xóa link...';
            const dbPath = `approved_plans/${currentYear}/${linkKey}`;
            await remove(ref(db, dbPath)); // Sử dụng hàm 'remove' của Firebase
            statusDiv.innerText = 'Đã xóa link thành công.';
            await openApprovedPlanModal(); // Tải lại danh sách trong modal
        } catch (error) {
            console.error("Lỗi khi xóa link:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi: ${error.message}`;
        }
    }

    /**
     * Mở modal lựa chọn cách thêm link (dán/tải file).
     * Yêu cầu xác thực Firebase.
     */
    window.openAddPlanLinkModal = function() {
        if (!isAuthenticated) return showAuthError();
        // Đóng modal danh sách
        document.getElementById('approvedPlanModal').style.display = 'none';
        // Mở modal lựa chọn
        document.getElementById('addPlanLinkModal').style.display = 'block';
    }

    /**
     * Mở modal để dán link thủ công.
     */
    window.openPasteLinkModal = function() {
        // Đóng modal lựa chọn
        document.getElementById('addPlanLinkModal').style.display = 'none';
        // Xóa giá trị cũ và mở modal dán link
        document.getElementById('pastedLinkName').value = '';
        document.getElementById('pastedLinkUrl').value = '';
        document.getElementById('pasteLinkModal').style.display = 'block';
        document.getElementById('pastedLinkName').focus();
    }

    /**
     * Lưu link được dán thủ công vào CSDL.
     * Yêu cầu xác thực Firebase.
     */
    window.savePastedLink = async function() {
        if (!isAuthenticated) return showAuthError();
        
        const name = document.getElementById('pastedLinkName').value.trim();
        const url = document.getElementById('pastedLinkUrl').value.trim();

        if (!url) {
            alert("Vui lòng nhập đường link (URL).");
            return;
        }
        if (!name) {
            alert("Vui lòng nhập tên hiển thị cho link.");
            return;
        }
        
        const saveData = {
            url: url,
            name: name,
            timestamp: Date.now()
        };

        const saveButton = document.querySelector('#pasteLinkModal .btn-success');
        try {
            saveButton.disabled = true;
            saveButton.textContent = 'Đang lưu...';
            
            const listRef = ref(db, `approved_plans/${currentYear}`);
            await push(listRef, saveData); // Sử dụng 'push' để tạo ID duy nhất

            closeAllModals(); // Đóng modal dán link
            await openApprovedPlanModal(); // Mở lại modal danh sách (sẽ tự động tải lại)
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đã lưu link thành công.';

        } catch (error) {
            console.error("Lỗi khi lưu link:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi: ${error.message}`;
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = 'Lưu link';
        }
    }

    /**
     * Bắt đầu quy trình tải file Kế hoạch lên Google Drive.
     * Tái sử dụng hàm requestGoogleAuth() và modal #uploadPdfModal.
     * Yêu cầu xác thực Firebase.
     */
    window.startPlanUploadFlow = async function() {
        if (!isAuthenticated) return showAuthError();
        
        closeAllModals(); // Đóng modal lựa chọn
        statusDiv.innerText = 'Kiểm tra quyền truy cập Google Drive...';
        statusDiv.className = '';

        try {
            // 1. Yêu cầu/Kiểm tra xác thực Google (hàm này đã có sẵn)
            await requestGoogleAuth();
            
            // 2. Nếu xác thực thành công, mở modal upload
            statusDiv.innerText = '';
            document.getElementById('uploadPdfModalTitle').textContent = 'Tải lên Kế hoạch đã duyệt (PDF)';
            
            // 3. **QUAN TRỌNG:** Gán hàm 'onclick' MỚI cho nút tải lên
            document.getElementById('uploadPdfButton').onclick = window.performApprovedPlanUpload;
            
            document.getElementById('pdf_file_input').value = '';
            document.getElementById('uploadPdfModal').style.display = 'block';

        } catch (error) {
            // Lỗi đã được xử lý và hiển thị bởi requestGoogleAuth()
            console.error('Không thể tải lên do lỗi xác thực Google:', error);
        }
    }

    /**
     * Hàm xử lý việc tải file Kế hoạch (được gọi từ modal #uploadPdfModal).
     * Đây là bản sao của 'performPdfUpload' nhưng lưu vào CSDL 'approved_plans'.
     * Yêu cầu xác thực Firebase.
     */
    window.performApprovedPlanUpload = async function() {
        if (!isAuthenticated) return showAuthError();
        
        const googleToken = gapi.client.getToken();
        if (!googleToken || !googleToken.access_token) {
            statusDiv.className = 'error';
            statusDiv.innerText = 'Phiên đăng nhập Google đã hết hạn. Vui lòng thử lại thao tác "Tải file".';
            closeAllModals();
            return;
        }

        const uploadButton = document.getElementById('uploadPdfButton');
        const fileInput = document.getElementById('pdf_file_input');
        const file = fileInput.files[0];
        if (!file) { 
            alert('Vui lòng chọn một tệp PDF.'); 
            return; 
        }
        
        try {
            uploadButton.disabled = true; 
            uploadButton.textContent = 'Đang tải...';
            statusDiv.className = 'success'; 
            statusDiv.innerText = 'Đang tải tệp lên Google Drive...';
            
            // Sử dụng cùng FOLDER_ID với chức năng hồ sơ
            const metadata = { name: file.name, mimeType: 'application/pdf', parents: [FOLDER_ID] };
            const formData = new FormData();
            formData.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
            formData.append('file', file);
            
            const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${googleToken.access_token}` },
                body: formData
            });
            
            if (!response.ok) { 
                const error = await response.json(); 
                throw new Error(`Lỗi API Drive: ${error.error.message}`); 
            }
            
            const fileData = await response.json();
            const fileLink = `https://drive.google.com/file/d/${fileData.id}/view`;
            console.log('Tải lên Drive thành công:', fileLink);
            
            statusDiv.innerText = 'Đang cập nhật link vào cơ sở dữ liệu...';

            // **THAY ĐỔI:** Lưu dữ liệu vào path 'approved_plans'
            const saveData = {
                url: fileLink,
                name: file.name, // Lưu lại tên file
                timestamp: Date.now()
            };
            const listRef = ref(db, `approved_plans/${currentYear}`);
            await push(listRef, saveData); // Sử dụng 'push'
            // **KẾT THÚC THAY ĐỔI**

            closeAllModals(); // Đóng modal upload
            await openApprovedPlanModal(); // Mở lại modal danh sách (sẽ tự động tải lại)
            statusDiv.className = 'success';
            statusDiv.innerText = `Tải lên và cập nhật Kế hoạch thành công!`;

        } catch (error)
        {
            console.error('Lỗi khi tải tệp kế hoạch:', error);
            statusDiv.className = 'error';
            let errorMsg = error.message;
            if (errorMsg.includes('API Drive')) {
                errorMsg = `Lỗi tải lên Google Drive: ${error.message}.`;
            } else if (errorMsg.includes('token')) {
                errorMsg = `Lỗi xác thực Google: ${error.message}. Vui lòng thử lại.`;
            }
            statusDiv.innerText = `Đã xảy ra lỗi: ${errorMsg}`;
        } finally {
            uploadButton.disabled = false;
            uploadButton.textContent = 'Tải Lên';
            fileInput.value = '';
        }
    };
    
    // === KẾT THÚC MÃ MỚI ===

    const loginContainer = document.getElementById('login-container');
    const mainContainer = document.getElementById('container');
    const loginForm = document.getElementById('login-form');
    const loginError = document.getElementById('login-error');



// Hàm gọi lại sau khi nhận token
    // Hàm gọi lại sau khi nhận token
    function tokenResponseCallback(resp) {
        if (resp.error !== undefined) {
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi xác thực Google: ${resp.error}`;
            throw (resp);
        }
        console.log('Xác thực Google thành công (Callback).');
        // === THÊM DÒNG NÀY ===
        gapi.client.setToken(resp); // Lưu token vào thư viện GAPI client
        // ======================
        // Cập nhật giao diện (nếu chưa được cập nhật bởi luồng promise)
        // updateSigninStatus(true); // Có thể không cần nếu requestGoogleAuth xử lý
    }

    // Hàm xử lý việc yêu cầu xác thực
   // Hàm xử lý việc yêu cầu xác thực
    async function requestGoogleAuth() {
        return new Promise((resolve, reject) => {
             if (!gapiReady || !gisInited || !tokenClient) {
                 statusDiv.className = 'error';
                 statusDiv.innerText = 'Thư viện Google chưa sẵn sàng. Vui lòng thử lại sau giây lát.';
                 return reject(new Error('Google libraries not ready'));
             }

             // Kiểm tra xem đã có token chưa
             const currentToken = gapi.client.getToken();
             if (currentToken && currentToken.access_token) {
                 console.log('Đã có token Google hợp lệ.');
                 return resolve(true); 
             }

             console.log('Yêu cầu cấp quyền Google Drive...');

             // *** Đảm bảo callback được gán TRƯỚC khi gọi requestAccessToken ***
             tokenClient.callback = (resp) => { 
                 if (resp.error) {
                     statusDiv.className = 'error';
                     statusDiv.innerText = `Lỗi cấp quyền: ${resp.error_description || resp.error}`; 
                     console.error('Lỗi cấp quyền Google:', resp);
                     tokenClient.callback = tokenResponseCallback; // Khôi phục callback mặc định
                     return reject(resp.error);
                 }

                 // === [FIX QUAN TRỌNG]: LƯU TOKEN VÀO GAPI CLIENT ===
                 if (resp.access_token) {
                     gapi.client.setToken(resp);
                 }
                 // ===================================================

                 statusDiv.className = 'success';
                 statusDiv.innerText = 'Đã cấp quyền thành công. Bạn có thể tải tệp lên.';
                 console.log('Cấp quyền thành công (Promise resolved).');
                 
                 tokenClient.callback = tokenResponseCallback; 
                 resolve(true);
             };
             
             tokenClient.requestAccessToken({ prompt: 'consent' }); 
        });
    }
	
	

    // ĐỊNH NGHĨA TẤT CẢ CÁC HÀM CẦN THIẾT
    window.initializeYearDropdown = function() {
        const yearSelect = document.getElementById('yearSelect');
        const currentYearValue = new Date().getFullYear();
        const nextYear = currentYearValue + 1;
        yearSelect.innerHTML = '';
        const years = [currentYearValue, nextYear];
        for (let i = currentYearValue - 1; i >= currentYearValue - 3; i--) {
            years.unshift(i);
        }
        years.forEach(year => {
            const option = document.createElement('option');
            option.value = year;
            option.textContent = year;
            yearSelect.appendChild(option);
        });
        currentYear = currentYearValue;
        yearSelect.value = currentYearValue;
    };

   window.openDataManagementModal = function() {
        const modal = document.getElementById('dataManagementModal');
        modal.style.display = 'block';

        const unlockBtn = document.getElementById('unlockButton');
        const adminControls = document.getElementById('adminControls');
        const adminEmail = "admin@pvgaslpg.com.vn";

        // Reset
        unlockBtn.style.display = 'block';
        adminControls.style.display = 'none';

        const currentUser = auth.currentUser;
        // Nếu đã đăng nhập đúng acc Admin thì hiện controls luôn
        if (currentUser && currentUser.email === adminEmail) {
            showAdminControls();
        } 
    };

    window.promptForAuthentication = function() {
        closeAllModals();
        loginContainer.style.display = 'block';
    };

    window.closeLoginModal = function() {
        const loginContainer = document.getElementById('login-container');
        const passwordInput = document.getElementById('password');
        const loginError = document.getElementById('login-error');

        loginContainer.style.display = 'none';
        passwordInput.value = '';
        loginError.style.display = 'none';
    };

    // Đổi tên hàm để phản ánh đúng chức năng mới
window.calculateModalChiPhi = function(input) {
    const row = input.closest('tr');
    if (!row) return;

    const soLuongInput = row.querySelector('input[data-field="soLuong"]');
    const donGiaInput = row.querySelector('input[data-field="donGia"]');
    const chiPhiInput = row.querySelector('input[data-field="chiPhi"]');
    const namPbInput = row.querySelector('input[data-field="namPhanBo"]');
    const cpPbInput = row.querySelector('input[data-field="chiPhiPhanBo"]');
    
    const path = row.dataset.path || "";
    // --- SỬA LỖI TẠI ĐÂY: Kiểm tra thêm dataset ---
    // Nhận diện giải trình qua path HOẶC qua thuộc tính data của row (khi thêm mới)
    const isJustification = path.includes('/justifications/') || 
                            path.includes('/subJustifications/') || 
                            row.dataset.isJustification === "true";
    // ----------------------------------------------

    // 1. Tính Chi Phí
    let currentChiPhi = 0;
    if (chiPhiInput && (!chiPhiInput.disabled || isJustification)) {
        const soLuong = parseNumber(soLuongInput.value);
        const donGia = parseNumber(donGiaInput.value);
        currentChiPhi = soLuong * donGia;
        chiPhiInput.value = formatNumber(currentChiPhi);
    } else if (chiPhiInput) {
        currentChiPhi = parseNumber(chiPhiInput.value);
    }

    // 2. Tính CP Phân Bổ
    if (namPbInput && !namPbInput.disabled && cpPbInput) {
        const nam = parseNumber(namPbInput.value);
        if (nam > 0) {
            cpPbInput.value = formatNumber(Math.round(currentChiPhi / nam));
        } else {
            cpPbInput.value = 0;
        }
    }
};

// === HÀM MỚI ĐỂ XUẤT EXCEL TRA CỨU (CẬP NHẬT LẦN 4 bổ sung tên CV cấp 3 và mã hiệu) ===
window.exportExecutionSearchExcel = async function() {
        if (executionGroups.size === 0) {
            alert("Không có dữ liệu thực hiện để xuất.");
            return;
        }

        try {
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đang chuẩn bị dữ liệu Excel...';
            
            const excelData = [];
            let sequenceNumber = 1;

            excelData.push([
                "Thứ tự", 
                "Ngày thực hiện", 
                "Mã hiệu", 
                "Nội dung công việc", 
                "ĐV thực hiện", 
                "Thành tiền"
            ]);

            const sortedTimestamps = Array.from(executionGroups.keys()).sort((a, b) => {
                const firstExecA = Object.values(Object.values(executionGroups.get(a) || {})[0] || {})[0]?.[0];
                const firstExecB = Object.values(Object.values(executionGroups.get(b) || {})[0] || {})[0]?.[0];
                const dateA = new Date(firstExecA?.ngayThucHien || 0);
                const dateB = new Date(firstExecB?.ngayThucHien || 0);
                if (dateB - dateA !== 0) return dateB - dateA;
                return (firstExecB?.timestamp || 0) - (firstExecA?.timestamp || 0);
            });


            for (const timestampKey of sortedTimestamps) {
                const timestampGroup = executionGroups.get(timestampKey); 
                
                const allExecsInTimestamp = Object.values(timestampGroup).flatMap(grandchildGroup => 
                    Object.values(grandchildGroup).flat()
                );
                if (allExecsInTimestamp.length === 0) continue;

                const firstExec = allExecsInTimestamp[0];
                const ngayThucHienGroup = firstExec.ngayThucHien || '';

                let khuVuc = 'Không xác định';
                const pathParts = firstExec.parentLeafNodePath.split('/');
                if (pathParts.length > 1) {
                    const parentId = pathParts[1];
                    khuVuc = parentNoiDungMap.get(parentId) || parentId;
                }
                
                const totalThanhTienGroup = allExecsInTimestamp.reduce((sum, exec) => sum + (exec.thanhTien || 0), 0);

                const groupHeaderRow = [
                    sequenceNumber++,     
                    ngayThucHienGroup,    
                    '',                   
                    khuVuc,               
                    '',                   
                    totalThanhTienGroup   
                ];
                excelData.push(groupHeaderRow);
                
                const sortedGrandchildPaths = Object.keys(timestampGroup).sort((a, b) => {
                    const idA = parseInt(a.split('/').pop(), 10) || 0;
                    const idB = parseInt(b.split('/').pop(), 10) || 0;
                    return idA - idB;
                });
                
                for (const grandchildPath of sortedGrandchildPaths) {
                    const grandchildGroup = timestampGroup[grandchildPath]; 
                    const allExecsInGrandchild = Object.values(grandchildGroup).flat();
                    if (allExecsInGrandchild.length === 0) continue;
                    
                    // === BẮT ĐẦU THAY ĐỔI: Lấy Mã hiệu (tt) Cấp 3 ===
                    let dauMucC3 = 'Không xác định';
                    let maHieuC3 = ''; // <-- Biến mới

                    const grandchildData = docDataMap.get(grandchildPath);
                    if (grandchildData) {
                        dauMucC3 = grandchildData.noiDung || 'Không xác định';
                        maHieuC3 = grandchildData.tt ? convertTTForDisplay(grandchildData.tt) : '';
                    } else {
                        // Fallback (nếu docDataMap bị lỡ) - Lấy cả node
                        try {
                            const taskSnap = await get(ref(db, grandchildPath)); 
                            if (taskSnap.exists()) {
                                const data = taskSnap.val();
                                dauMucC3 = data.noiDung || 'Không xác định';
                                maHieuC3 = data.tt ? convertTTForDisplay(data.tt) : '';
                            }
                        } catch (e) { console.warn(`Không thể lấy data cho ${grandchildPath}`); }
                    }
                    // === KẾT THÚC THAY ĐỔI ===
                    
                    const totalThanhTienC3 = allExecsInGrandchild.reduce((sum, exec) => sum + (exec.thanhTien || 0), 0);

                    // === THAY ĐỔI: Thêm maHieuC3 vào mảng ===
                    const subGroupHeaderRow = [
                       '',                   // Thứ tự (để trống)
                       '',                   // Ngày thực hiện (để trống)
                       maHieuC3,             // Mã hiệu (CẬP NHẬT)
                       `  ${dauMucC3}`,       // Nội dung: Tên Cấp 3
                       '',                   // ĐV thực hiện (để trống)
                       totalThanhTienC3      // Thành tiền: Tổng của nhóm Cấp 3
                    ];
                    excelData.push(subGroupHeaderRow);
                    // === KẾT THÚC THAY ĐỔI ===

                    for (const exec of allExecsInGrandchild) {
                       let maHieu = '';
                       const taskData = docDataMap.get(exec.parentLeafNodePath);
                        if (taskData && taskData.tt) {
                           maHieu = convertTTForDisplay(taskData.tt);
                       } else {
                           try {
                               const taskSnap = await get(ref(db, exec.parentLeafNodePath + '/tt'));
                               if (taskSnap.exists()) {
                                   maHieu = convertTTForDisplay(taskSnap.val());
                               }
                           } catch (e) { console.warn(`Không thể lấy tt cho ${exec.parentLeafNodePath}`); }
                       }

                       const detailRow = [
                           '',                   
                           '',                   
                           maHieu,               
                           `    - ${exec.noiDung || ''}`, 
                           exec.dvThucHien || '', 
                           exec.thanhTien || 0    
                       ];
                       excelData.push(detailRow);
                    }
                }
            } 

            statusDiv.innerText = 'Đang tạo file Excel...';
            
            const ws = XLSX.utils.aoa_to_sheet(excelData);
            
            const moneyFormat = '#,##0'; 
            const range = XLSX.utils.decode_range(ws['!ref']);
            for (let R = 1; R <= range.e.r; ++R) {
                const cell_address = XLSX.utils.encode_cell({c: 5, r: R}); 
                if (!ws[cell_address]) continue; 
                if (typeof ws[cell_address].v === 'number') { 
                    ws[cell_address].t = 'n';
                    ws[cell_address].z = moneyFormat;
                }
            }

            // Logic in đậm (giữ nguyên, sẽ tự động in đậm Cấp 3)
            for (let R = 1; R <= range.e.r; ++R) {
                const maHieuCellAddr = XLSX.utils.encode_cell({c: 2, r: R});
                // Sửa logic: Chỉ in đậm nếu cột Mã hiệu trống (dành cho Cấp 1)
                if (!ws[maHieuCellAddr] || ws[maHieuCellAddr].v === '') {
                     for (let C = 0; C <= range.e.c; ++C) {
                         const cellAddr = XLSX.utils.encode_cell({c: C, r: R});
                         if (!ws[cellAddr]) ws[cellAddr] = { t: 's', v: '' };
                         if (!ws[cellAddr].s) ws[cellAddr].s = {};
                         if (!ws[cellAddr].s.font) ws[cellAddr].s.font = {};
                         ws[cellAddr].s.font.bold = true;
                     }
                } 
                // === THAY ĐỔI: Logic in đậm MỚI cho Cấp 3 ===
                // Nếu cột Mã hiệu (C) không trống, NHƯNG cột Ngày (B) trống
                // => đây là hàng Cấp 3
                else {
                    const ngayCellAddr = XLSX.utils.encode_cell({c: 1, r: R});
                    if (!ws[ngayCellAddr] || ws[ngayCellAddr].v === '') {
                        for (let C = 0; C <= range.e.c; ++C) {
                             const cellAddr = XLSX.utils.encode_cell({c: C, r: R});
                             if (!ws[cellAddr]) ws[cellAddr] = { t: 's', v: '' };
                             if (!ws[cellAddr].s) ws[cellAddr].s = {};
                             if (!ws[cellAddr].s.font) ws[cellAddr].s.font = {};
                             ws[cellAddr].s.font.bold = true;
                         }
                    }
                }
                // === KẾT THÚC THAY ĐỔI ===
            }

            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "TraCuuThucHien");

            XLSX.writeFile(wb, `TraCuuThucHien_${currentYear}.xlsx`);

            statusDiv.innerText = 'Xuất Excel thành công!';

        } catch (error) {
            console.error("Lỗi khi xuất Excel tra cứu:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi khi xuất file: ${error.message}`;
        }
    };
    // === KẾT THÚC HÀM XUẤT EXCEL ===

    window.calculateThanhTien = function(input) {
    const row = input.closest('tr');
    if (!row) return;

    const soLuongInput = row.querySelector('input[data-field="dvt"]');
    const donGiaInput = row.querySelector('input[data-field="donGia"]');
    const thanhTienInput = row.querySelector('input[data-field="thanhTien"]');

    const soLuong = parseNumber(soLuongInput.value);
    const donGia = parseNumber(donGiaInput.value);
    const cost = soLuong * donGia;

    // Cập nhật giá trị của ô thành tiền
    thanhTienInput.value = formatNumber(cost);
};

/**
 * HÀM TÍNH TOÁN LẠI TOÀN BỘ (PHIÊN BẢN TỐI ƯU HÓA - BATCH PROCESSING)
 * Thực hiện theo quy trình 7 bước từ dưới lên trên, giảm thiểu lặp lại.
 */
window.recalculateAllCostsAndReload = async function(showConfirm = true) {
    if (!isAuthenticated) return showAuthError();
    if (showConfirm && !confirm("Tính toán lại toàn bộ dữ liệu (Hệ thống 4 Cấp)?")) return;

    const button = document.querySelector('button[onclick="recalculateAllCostsAndReload()"]');
    if(button) button.disabled = true;
    
    try {
        statusDiv.className = 'success'; statusDiv.innerText = 'Đang tính toán (4 cấp độ)...';

        const rootRef = ref(db, getParentCollectionName());
        const snapshot = await get(rootRef);
        
        if (!snapshot.exists()) {
            if(button) button.disabled = false;
            return;
        }

        const allData = snapshot.val();
        const updates = {}; 

        const updateNode = (path, fields) => {
            for (const key in fields) {
                updates[`${path}/${key}`] = fields[key];
                let node = allData;
                const parts = path.split('/').slice(1);
                for (let p of parts) if(node) node = node[p];
                if (node) node[key] = fields[key];
            }
            let node = allData;
            const parts = path.split('/').slice(1);
            for (let p of parts) if(node) node = node[p];
            if (node) {
                 node.keHoachConLai = (node.chiPhi || 0) - (node.chiPhiThucHien || 0);
                 updates[`${path}/keHoachConLai`] = node.keHoachConLai;
            }
        };

        const processLeafNode = (node, path) => {
            let totalChiPhi = 0;
            let totalThucHien = 0;
            let hasExecutions = false;

            if (node.executions) {
                for (const key in node.executions) {
                    totalThucHien += (node.executions[key].thanhTien || 0);
                    hasExecutions = true;
                }
            }

            if (node.justifications) {
                for (const jKey in node.justifications) {
                    const just = node.justifications[jKey];
                    let justCost = 0;
                    
                    // --- SỬA LỖI LOGIC TÍNH TOÁN GIẢI TRÌNH ---
                    // Kiểm tra xem thực tế có con hay không
                    const hasSubs = just.subJustifications && Object.keys(just.subJustifications).length > 0;

                    if (hasSubs) {
                        // TRƯỜNG HỢP 1: CÓ CON -> TÍNH TỔNG CON
                        for (const sKey in just.subJustifications) {
                            justCost += (just.subJustifications[sKey].chiPhi || 0);
                        }
                    } else {
                        // TRƯỜNG HỢP 2: KHÔNG CÓ CON (LÁ) -> TÍNH THEO CÔNG THỨC
                        // Bất kể cờ hasSubJustifications là true hay false, nếu không tìm thấy con thì tính lại
                        const sl = just.soLuong || 0;
                        const dg = just.donGia || 0;
                        justCost = sl * dg;
                    }

                    // Cập nhật lại vào updates nếu giá trị tính toán khác giá trị lưu trữ
                    // Hoặc cập nhật lại cờ nếu nó bị sai
                    const justPath = `${path}/justifications/${jKey}`;
                    
                    if (just.chiPhi !== justCost) {
                        updates[`${justPath}/chiPhi`] = justCost;
                    }
                    
                    // Tự sửa lỗi cờ trạng thái: Nếu cờ đang true mà thực tế không có con -> set về false
                    if (just.hasSubJustifications && !hasSubs) {
                         updates[`${justPath}/hasSubJustifications`] = false;
                    }
                    // -------------------------------------------

                    totalChiPhi += justCost;
                }
            } else {
                totalChiPhi = node.chiPhi || 0;
            }

            let cpPhanBo = 0;
            let namPhanBo = node.namPhanBo;
            if (!namPhanBo && totalChiPhi > 0) {
                namPhanBo = 1;
                updates[`${path}/namPhanBo`] = 1;
            }
            if (namPhanBo > 0) cpPhanBo = Math.round(totalChiPhi / namPhanBo);

            let cpCap1 = 0;
            const capDoStr = String(node.capDo || '').trim().toLowerCase();
            if (capDoStr === '1' || capDoStr === '') cpCap1 = totalChiPhi;
            else if (capDoStr === '6t') cpCap1 = Math.round(totalChiPhi * 0.5);
            else cpCap1 = 0;

            updateNode(path, {
                chiPhi: totalChiPhi,
                chiPhiThucHien: totalThucHien,
                daThucHien: hasExecutions,
                chiPhiPhanBo: cpPhanBo,
                cpCap1: cpCap1 
            });
        };

        const traverseToLeaves = (node, path) => {
            const hasChildren = (node.children || node.grandchildren || node.greatGrandchildren || node.hasChildren);
            
            if (!hasChildren) {
                processLeafNode(node, path);
            } else {
                if (node.executions) { 
                     updateNode(path, { daThucHien: true });
                }
                updates[`${path}/soLuong`] = null;
                updates[`${path}/donGia`] = null;
                updates[`${path}/donVi`] = null;
            }

            if (node.children) Object.keys(node.children).forEach(k => traverseToLeaves(node.children[k], `${path}/children/${k}`));
            if (node.grandchildren) Object.keys(node.grandchildren).forEach(k => traverseToLeaves(node.grandchildren[k], `${path}/grandchildren/${k}`));
            if (node.greatGrandchildren) Object.keys(node.greatGrandchildren).forEach(k => traverseToLeaves(node.greatGrandchildren[k], `${path}/greatGrandchildren/${k}`));
        };

        const parents = Object.keys(allData);
        for (const pid of parents) {
            traverseToLeaves(allData[pid], `${getParentCollectionName()}/${pid}`);
        }

        const aggregateFromChildren = (parentNode, childCollectionName) => {
            let sumCP = 0, sumTH = 0, sumKHPrev = 0, sumTHPrev = 0, sumCPPhanBo = 0, sumCpCap1 = 0;
            let anyExecuted = false;
            
            if (parentNode[childCollectionName]) {
                for (const key in parentNode[childCollectionName]) {
                    const child = parentNode[childCollectionName][key];
                    sumCP += (child.chiPhi || 0);
                    sumTH += (child.chiPhiThucHien || 0);
                    sumKHPrev += (child.khNamTruoc || 0);
                    sumTHPrev += (child.thucHienNamTruoc || 0);
                    sumCPPhanBo += (parseFloat(child.chiPhiPhanBo) || 0);
                    sumCpCap1 += (child.cpCap1 || 0);

                    if (child.daThucHien || (child.executions && Object.keys(child.executions).length > 0)) {
                         anyExecuted = true;
                    }
                    if (child.children || child.grandchildren || child.greatGrandchildren) {
                         if(child.daThucHien) anyExecuted = true;
                    }
                }
            }
            return { 
                chiPhi: sumCP, 
                chiPhiThucHien: sumTH, 
                khNamTruoc: sumKHPrev, 
                thucHienNamTruoc: sumTHPrev, 
                daThucHien: anyExecuted,
                chiPhiPhanBo: sumCPPhanBo,
                cpCap1: sumCpCap1 
            };
        };

        const aggregateNodeRecursively = (node, path) => {
            if (node.children) Object.keys(node.children).forEach(k => aggregateNodeRecursively(node.children[k], `${path}/children/${k}`));
            if (node.grandchildren) Object.keys(node.grandchildren).forEach(k => aggregateNodeRecursively(node.grandchildren[k], `${path}/grandchildren/${k}`));
            if (node.greatGrandchildren) Object.keys(node.greatGrandchildren).forEach(k => aggregateNodeRecursively(node.greatGrandchildren[k], `${path}/greatGrandchildren/${k}`));
            
            let aggResult = null;
            if (node.greatGrandchildren) { 
                 aggResult = aggregateFromChildren(node, 'greatGrandchildren');
            } else if (node.grandchildren) { 
                 aggResult = aggregateFromChildren(node, 'grandchildren');
            } else if (node.children) { 
                 aggResult = aggregateFromChildren(node, 'children');
            }

            if (aggResult) {
                updateNode(path, aggResult);
            }
        };

        for (const pid of parents) {
            aggregateNodeRecursively(allData[pid], `${getParentCollectionName()}/${pid}`);
        }

        if (Object.keys(updates).length > 0) await update(ref(db), updates);

        await calculateSummaryData();
        await fetchData();
        statusDiv.className = 'success'; statusDiv.innerText = 'Đã tính toán xong (4 Cấp).';

    } catch (error) {
        console.error("Lỗi:", error);
        statusDiv.className = 'error'; statusDiv.innerText = `Lỗi: ${error.message}`;
    } finally {
        if(button) button.disabled = false;
    }
};

/**
 * HÀM HELPER MỚI
 * Trả về một đối tượng chứa các trường cần set về 'null' cho một nút cha.
 */
function getCleanupFieldsForParentNode(path) {
    return {
        [`${path}/donVi`]: null,
        [`${path}/soLuong`]: null,
        [`${path}/donGia`]: null,
        [`${path}/tanSuatTH`]: null
        // Chúng ta giữ lại 'dvThucHien' và 'capDo' vì chúng có thể hữu ích
    };
}

    window.logoutUser = async function() {
        if(confirm('Bạn có muốn đăng xuất và quay về chế độ chỉ xem không?')) {
            try {
                await signOut(auth);
            } catch (error) {
                console.error("Lỗi đăng xuất:", error);
                statusDiv.className = 'error';
                statusDiv.innerText = 'Lỗi khi đăng xuất: ' + error.message;
            }
        }
    };

  window.deleteSelectedTasks = async function() {
        if (!isAuthenticated) return showAuthError();
        
        let allPaths = [...selectedTasks, ...selectedJustifications];
        
        if (allPaths.length === 0) { 
            alert("Vui lòng chọn ít nhất một mục để xoá."); 
            return; 
        }

        const finalPathsToDelete = allPaths.filter(path => {
            const isParentOfAnother = allPaths.some(otherPath => 
                otherPath !== path && otherPath.startsWith(path + '/')
            );
            return !isParentOfAnother;
        });

        if (finalPathsToDelete.length === 0) return;

        try {
            for (const path of finalPathsToDelete) {
                const execSnapshot = await get(ref(db, `${path}/executions`));
                if (execSnapshot.exists() && Object.keys(execSnapshot.val()).length > 0) {
                    const taskDoc = await get(ref(db, path));
                    const taskName = taskDoc.exists() ? taskDoc.val().noiDung : 'không xác định';
                    alert(`Công việc "${taskName}" (Mục ${taskDoc.val().tt}) đã được thực hiện nên không được phép xóa.`);
                    return;
                }
            }
        } catch (error) {
            statusDiv.className = 'error'; statusDiv.innerText = `Lỗi khi kiểm tra công việc: ${error.message}`; return;
        }

        if (!confirm(`Bạn có chắc chắn muốn xoá vĩnh viễn ${finalPathsToDelete.length} mục đã chọn không? (Các mục cha sẽ được giữ lại)`)) return;

        const deleteButton = document.getElementById('deleteSelectedBtn');
        try {
            deleteButton.disabled = true;
            statusDiv.className = 'success'; statusDiv.innerText = `Đang xoá...`;
            
            const updates = {};
            const parentsToCheck = new Set();

            for (const path of finalPathsToDelete) {
                updates[path] = null; 

                let parentPath = null;
                if (path.includes('/justifications/')) {
                     parentPath = path.substring(0, path.lastIndexOf('/justifications/'));
                } else if (path.includes('/subJustifications/')) {
                     parentPath = path.substring(0, path.lastIndexOf('/subJustifications/'));
                } else {
                     const parts = path.split('/');
                     if (parts.length >= 2) {
                         parentPath = parts.slice(0, parts.length - 2).join('/');
                     }
                }

                if (parentPath) parentsToCheck.add(parentPath);
            }

            await update(ref(db), updates);

            const updateBatch = {};
            
            for (const parentPath of parentsToCheck) {
                if (parentPath.endsWith(getParentCollectionName())) continue;

                const parentSnap = await get(ref(db, parentPath));
                if (parentSnap.exists()) {
                    const data = parentSnap.val();
                    
                    const hasChildren = (data.children && Object.keys(data.children).length > 0) ||
                                        (data.grandchildren && Object.keys(data.grandchildren).length > 0) ||
                                        (data.greatGrandchildren && Object.keys(data.greatGrandchildren).length > 0) ||
                                        (data.justifications && Object.keys(data.justifications).length > 0) ||
                                        (data.subJustifications && Object.keys(data.subJustifications).length > 0);

                    if (!hasChildren) {
                        // Biến thành Lá
                        updateBatch[`${parentPath}/hasChildren`] = false;
                        // --- SỬA ĐỔI: Reset vô điều kiện để đảm bảo sạch sẽ ---
                        updateBatch[`${parentPath}/hasSubJustifications`] = false; 
                        // ------------------------------------------------------
                        
                        updateBatch[`${parentPath}/chiPhi`] = 0;
                        updateBatch[`${parentPath}/chiPhiThucHien`] = 0;
                        updateBatch[`${parentPath}/keHoachConLai`] = 0;
                    }
                }
            }

            if (Object.keys(updateBatch).length > 0) {
                await update(ref(db), updateBatch);
            }

            statusDiv.innerText = "Đã xoá. Đang tính toán lại chi phí...";
            await recalculateAllCostsAndReload(false);

            statusDiv.innerText = `Đã xoá thành công.`;
        } catch (error) {
            console.error("Lỗi khi xoá công việc:", error);
            statusDiv.className = 'error'; statusDiv.innerText = `Lỗi khi xoá: ${error.message}`;
            updateButtonStates();
        }
    };

    window.exportToExcel = function(type) {
        // type 1: simplified (Excel 1 - Không giải trình)
        // type 2: full (Excel 2 - Có giải trình)
        activeExportType = type === 1 ? 'simplified' : 'full';
        document.getElementById('exportOptionsModal').style.display = 'block';
    };

   window.openMultiExecutionModal = function() {
    if (!isAuthenticated) return showAuthError();
    const allSelected = [...selectedTasks];
    
    // --- SỬA LỖI TẠI ĐÂY: CẬP NHẬT BỘ LỌC ĐỂ CHẤP NHẬN CẤP 3 LÀ LÁ ---
    const leafTasks = allSelected.filter(path => {
        const taskData = docDataMap.get(path);
        if (!taskData) {
            return false; 
        }
        
        // 1. Cấp 5 (Luôn là lá)
        if (path.includes('/greatGreatGrandchildren/')) {
            return true;
        }
        
        // 2. Cấp 4 (Là lá nếu không có con cấp 5)
        if (path.includes('/greatGrandchildren/')) {
            return taskData.hasChildren !== true;
        }

        // 3. Cấp 3 (Là lá nếu không có con cấp 4) --> ĐÂY LÀ PHẦN THIẾU
        if (path.includes('/grandchildren/')) {
            // Kiểm tra xem có danh sách con cấp 4 không
            const hasLevel4Children = taskData.greatGrandchildren && Object.keys(taskData.greatGrandchildren).length > 0;
            // Nếu không có con cấp 4 (dù có giải trình hay không), thì nó là lá -> Được phép thực hiện
            return !hasLevel4Children;
        }

        return false;
    });
    // ------------------------------------------------------------------

    if (leafTasks.length === 0) {
        if (allSelected.length > 0) {
             alert("Bạn đã chọn công việc, nhưng không có mục nào là công việc 'lá' (công việc chi tiết cuối cùng) có thể thực hiện. Vui lòng chỉ chọn các công việc chi tiết.");
        } else {
            alert("Vui lòng chọn ít nhất một công việc 'lá' (công việc chi tiết cuối cùng) để thực hiện.");
        }
        return;
    }

    const title = `Thực hiện công việc cho ${leafTasks.length} mục đã chọn`;
    document.getElementById('modalTitle').innerHTML = `<h2>${title}</h2>`;

    const headers = [ 
        {text: 'TT', width: '2%'}, 
        {text: 'Khu vực', width: '20%'},
        {text: 'Mục KH', width: '4%'},
        {text: 'Công việc thực hiện', width: '25%'},
        {text: 'Đ.vị tính', width: '4%'}, 
        {text: 'Số lượng', width: '5%'}, 
        {text: 'Đơn giá', width: '9%'}, 
        {text: 'Thành tiền', width: '9%'}
    ];

    let table = createModalTable(headers);
    
    leafTasks.forEach((path, index) => {
        const taskData = docDataMap.get(path);
        const taskTT = taskData ? convertTTForDisplay(taskData.tt) : '';
        const noiDung = taskData?.noiDung || '';
        const donVi = taskData?.donVi || '';
        const donGia = taskData?.donGia || 0;

        let khuVuc = 'Không xác định';
        const pathParts = path.split('/');
        if (pathParts.length > 1) {
            const parentId = pathParts[1]; 
            khuVuc = parentNoiDungMap.get(parentId) || parentId;
        }

        table += `<tr data-path="${path}">
            <td><input type="text" value="${index + 1}" disabled></td>
            <td><input type="text" value="${khuVuc}" disabled></td> 
            <td><input type="text" value="${taskTT}" disabled></td> 
            <td><input type="text" value="${noiDung}" disabled></td>
            <td><input type="text" value="${donVi}" disabled></td>
            <td><input type="number" value="" data-field="dvt" oninput="calculateThanhTien(this)" onfocus="this.select()"></td>
            <td><input type="number" value="${donGia}" data-field="donGia" oninput="calculateThanhTien(this)" onfocus="this.select()"></td>
            <td><input type="text" value="" data-field="thanhTien" disabled oninput="this.value=formatNumber(parseNumber(this.value))" onfocus="this.select()"></td> 
        </tr>`;
    });
    
    table += '</tbody></table>';
    const dateInput = `<div style="margin-top: 15px;"><label for="executionDate">Ngày thực hiện:</label><input type="date" id="executionDate" style="margin-left: 10px; padding: 8px;"></div>`;
    document.getElementById('modalBody').innerHTML = dateInput + table;
    document.getElementById('modalSaveButton').onclick = saveMultiExecutionData;
    document.getElementById('modalSaveButton').style.display = 'block';
    document.getElementById('modalDeleteButton').style.display = 'none';
    document.getElementById('modal-footer-left').innerHTML = '';
    enableArrowKeyNavigation('dataModal');
    document.getElementById('dataModal').style.display = 'block';
};

window.openSearchModal = async function() {
    const modal = document.getElementById('dataModal');
    const title = 'Tra cứu thực hiện công việc';
    document.getElementById('modalTitle').innerHTML = `<h2>${title}</h2>`;

    const headers = [
        {text: 'Ngày thực hiện', width: '10%'},
        {text: 'Nội dung công việc', width: '50%'},
        {text: 'ĐV thực hiện', width: '10%'},
        {text: 'Thành tiền', width: '15%'},
        {text: 'Hành động', width: '15%'}
    ];
    let table = createModalTable(headers);
    table += '</tbody></table>';
    document.getElementById('modalBody').innerHTML = table;
    document.getElementById('modalSaveButton').style.display = 'none';
    document.getElementById('modalDeleteButton').style.display = 'none';
    document.getElementById('modal-footer-left').innerHTML = '<button class="btn-success" onclick="exportExecutionSearchExcel()">Xuất Excel</button>';
    modal.style.display = 'block';

    try {
        statusDiv.className = 'success';
        statusDiv.innerText = 'Đang tải dữ liệu thực hiện...';
        executionGroups.clear(); // Xóa dữ liệu cũ

        const parentQuery = ref(db, getParentCollectionName());
        const parentSnapshot = await get(parentQuery);
        if (!parentSnapshot.exists()) {
            document.getElementById('modalBody').innerHTML = '<p>Không có dữ liệu thực hiện.</p>';
            statusDiv.innerText = '';
            document.getElementById('modal-footer-left').innerHTML = '';
            return;
        }

        const parentsData = parentSnapshot.val();
        const allExecutions = [];

        // Hàm đệ quy lấy dữ liệu thực hiện phẳng
        const processNodeForExecutions = (node, path) => {
            if (node.executions) {
                for (const execId in node.executions) {
                    const exec = node.executions[execId];
                    const executionWithPath = {
                        ...exec,
                        path: `${path}/executions/${execId}`,
                        parentLeafNodePath: path, // Đường dẫn Task Lá
                        noiDung: node.noiDung || 'Không có tên',
                        dvThucHien: node.dvThucHien || ''
                    };
                    allExecutions.push(executionWithPath);
                }
            }
            if (node.children) for (const k in node.children) processNodeForExecutions(node.children[k], `${path}/children/${k}`);
            if (node.grandchildren) for (const k in node.grandchildren) processNodeForExecutions(node.grandchildren[k], `${path}/grandchildren/${k}`);
            if (node.greatGrandchildren) for (const k in node.greatGrandchildren) processNodeForExecutions(node.greatGrandchildren[k], `${path}/greatGrandchildren/${k}`);
            if (node.greatGreatGrandchildren) for (const k in node.greatGreatGrandchildren) processNodeForExecutions(node.greatGreatGrandchildren[k], `${path}/greatGreatGrandchildren/${k}`);
        };

        for (const parentId in parentsData) {
            processNodeForExecutions(parentsData[parentId], `${getParentCollectionName()}/${parentId}`);
        }

        // Sắp xếp theo ngày
        allExecutions.sort((a, b) => {
            const dateA = new Date(a.ngayThucHien || 0);
            const dateB = new Date(b.ngayThucHien || 0);
            if (dateB - dateA !== 0) return dateB - dateA;
            return (b.timestamp || 0) - (a.timestamp || 0);
        });

        // === LOGIC GOM NHÓM MỚI (Theo Cha trực tiếp của Task Lá) ===
        // Map<timestamp, Map<directParentPath, exec[]>>
        allExecutions.forEach(exec => {
            const timestampKey = String(exec.timestamp || exec.ngayThucHien);
            
            // Tìm đường dẫn Task Cha (Cắt bỏ 2 phần cuối: collection/id)
            // Ví dụ Lá: .../grandchildren/1 -> Cha: .../children/I
            // Ví dụ Lá: .../greatGrandchildren/1,1 -> Cha: .../grandchildren/1
            const pathParts = exec.parentLeafNodePath.split('/');
            const directParentPath = pathParts.slice(0, pathParts.length - 2).join('/');

            if (!executionGroups.has(timestampKey)) {
                executionGroups.set(timestampKey, {});
            }
            const timestampGroup = executionGroups.get(timestampKey);

            if (!timestampGroup[directParentPath]) {
                timestampGroup[directParentPath] = [];
            }
            timestampGroup[directParentPath].push(exec);
        });

        let tbody = '';
        const sortedTimestamps = Array.from(executionGroups.keys()).sort((a, b) => {
            const firstExecA = Object.values(executionGroups.get(a))[0][0];
            const firstExecB = Object.values(executionGroups.get(b))[0][0];
            const dateA = new Date(firstExecA?.ngayThucHien || 0);
            const dateB = new Date(firstExecB?.ngayThucHien || 0);
            if (dateB - dateA !== 0) return dateB - dateA;
            return (firstExecB?.timestamp || 0) - (firstExecA?.timestamp || 0);
        });

        for (const timestampKey of sortedTimestamps) {
            const timestampGroup = executionGroups.get(timestampKey); // Map<directParentPath, exec[]>
            
            // Tính tổng tiền cho cả ngày
            const allExecsInTimestamp = Object.values(timestampGroup).flat();
            if (allExecsInTimestamp.length === 0) continue;
            
            const firstExec = allExecsInTimestamp[0];
            const totalThanhTien = allExecsInTimestamp.reduce((sum, exec) => sum + (exec.thanhTien || 0), 0);

            // 1. Lấy Tên Cấp 1 (Khu vực)
            let khuVuc = 'Không xác định';
            const pathParts = firstExec.parentLeafNodePath.split('/');
            if (pathParts.length > 1) {
                const parentId = pathParts[1];
                khuVuc = parentNoiDungMap.get(parentId) || parentId;
            }

            // Bắt đầu tạo HTML
            let noiDungCellHtml = `<strong style="color: #0056b3;">${khuVuc}</strong><br>`;

            // Sắp xếp các nhóm Cha theo thứ tự TT (dùng numericSort)
            const sortedParentPaths = Object.keys(timestampGroup).sort((a, b) => {
                const idA = a.split('/').pop();
                const idB = b.split('/').pop();
                // Dùng logic sort cũ hoặc so sánh chuỗi đơn giản
                return idA.localeCompare(idB, undefined, { numeric: true });
            });

            sortedParentPaths.forEach((parentPath, pIndex) => {
                const executions = timestampGroup[parentPath];
                
                // 2. Lấy Tên Task Cha (Direct Parent)
                let parentName = 'Không xác định';
                let parentTT = '';
                const parentData = docDataMap.get(parentPath);
                
                if (parentData) {
                    parentName = parentData.noiDung || 'Không có tên';
                    parentTT = parentData.tt ? convertTTForDisplay(parentData.tt) : '';
                } else {
                    // Fallback nếu docDataMap chưa có (hiếm khi xảy ra nếu đã fetchData)
                    parentName = parentPath.split('/').pop(); 
                }

                // Hiển thị dòng Task Cha
                noiDungCellHtml += `<strong style="color: #333; padding-left: 10px;">${parentTT ? parentTT + '. ' : ''}${parentName}</strong><br>`;

                // 3. Hiển thị các Task Lá (Con của Task Cha trên)
                executions.forEach((exec, index) => {
                    const leafName = exec.noiDung || 'N/A';
                    noiDungCellHtml += `<span style="padding-left: 20px;">- ${leafName}</span>`;
                    
                    // Xuống dòng nếu chưa phải lá cuối cùng của nhóm này
                    if (index < executions.length - 1) {
                        noiDungCellHtml += '<br>';
                    }
                });

                // Xuống dòng ngăn cách giữa các nhóm Cha (nếu chưa phải nhóm cuối)
                if (pIndex < sortedParentPaths.length - 1) {
                    noiDungCellHtml += '<br>';
                }
            });

            // Kiểm tra link hồ sơ (dùng danh sách phẳng của ngày)
            const hasHoSoLink = allExecsInTimestamp.some(exec => exec.hoSoLink && exec.hoSoLink.trim() !== '');
            const hoSoButtonClass = hasHoSoLink ? 'btn-danger' : 'btn-info';
            const hoSoButtonText = hasHoSoLink ? 'Thay HS' : 'Hồ sơ';

            tbody += `<tr>
                <td>${firstExec.ngayThucHien}</td>
                <td>${noiDungCellHtml}</td>
                <td>${firstExec.dvThucHien}</td>
                <td class="text-right">${formatNumber(totalThanhTien)}</td>
                <td>
                    <button class="${hoSoButtonClass} btn-action btn-profile-exec" onclick="uploadPdfForExecution('${timestampKey}')">${hoSoButtonText}</button>
                    <button class="btn-warning btn-action btn-edit-exec" onclick="openExecutionEdit('${timestampKey}')">Sửa</button>
                </td>
            </tr>`;
        }

        document.querySelector('#dataModal .modal-table tbody').innerHTML = tbody;
        statusDiv.innerText = '';
    } catch (error) {
        console.error("Lỗi khi tải dữ liệu thực hiện:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi: ${error.message}`;
         document.getElementById('modal-footer-left').innerHTML = '';
    }
};

    window.togglePlanningColumns = function(isChecked) {
        if (isChecked) {
            if (!isAuthenticated) {
                activatePlanningModeForSelection('all');
            } else {
                activatePlanningModeForSelection('all');
            }
        } else {
            const taskList = document.getElementById('taskList');
            planningModeByYear[currentYear] = false;
            taskList.classList.remove('planning-mode');
            document.getElementById('exportExcel1Btn').disabled = false;
            document.getElementById('exportExcel2Btn').disabled = true;
            const allRows = document.querySelectorAll('#taskListBody tr');
            allRows.forEach(row => row.style.display = '');
        }
    };

    window.changeYear = function(year) {
        currentYear = parseInt(year);
        
        // Lấy trạng thái Planning Mode từ bộ nhớ
        const isPlanningMode = planningModeByYear[currentYear] || false;
        
        // Cập nhật Checkbox
        const toggle = document.getElementById('planningModeToggle');
        toggle.checked = isPlanningMode;
        
        // Cập nhật giao diện bảng (Thêm/Xóa class)
        const taskList = document.getElementById('taskList');
        if (isPlanningMode) {
            taskList.classList.add('planning-mode');
            document.getElementById('exportExcel1Btn').disabled = true;
            document.getElementById('exportExcel2Btn').disabled = false;
        } else {
            taskList.classList.remove('planning-mode');
            document.getElementById('exportExcel1Btn').disabled = false;
            document.getElementById('exportExcel2Btn').disabled = true;
            // Reset inline display style cho các dòng nếu tắt chế độ
            const allRows = document.querySelectorAll('#taskListBody tr');
            allRows.forEach(row => row.style.display = '');
        }

        // Sau đó mới tải dữ liệu
        fetchData();
        updateButtonStates();
    };

    window.closeAllModals = function() {
        document.querySelectorAll('.modal').forEach(modal => modal.style.display = 'none');
        activeCharts.forEach(chart => chart.destroy());
        activeCharts = [];
        const toggleDiv = document.getElementById('editModeToggle');
        if (toggleDiv) {
            toggleDiv.style.display = 'none';
            document.getElementById('unlockButton').style.display = 'block';
        }
    };

    window.showLinks = function(event) {
        event.stopPropagation();
        const existingDropdown = document.getElementById('links-dropdown-container');
        if (existingDropdown) existingDropdown.remove();
        
        const button = event.target;
        const links = JSON.parse(button.dataset.links);
        if (!links || links.length === 0) return;

        const dropdown = document.createElement('div');
        dropdown.id = 'links-dropdown-container';
        dropdown.className = 'links-dropdown';

        links.forEach(link => {
            const a = document.createElement('a');
            a.href = link;
            a.textContent = link.length > 50 ? link.substring(0, 50) + '...' : link;
            a.target = '_blank';
            a.title = link;
            dropdown.appendChild(a);
        });

        document.body.appendChild(dropdown);
        
        const rect = button.getBoundingClientRect();
        dropdown.style.left = `${rect.left + window.scrollX}px`;
        dropdown.style.top = `${rect.bottom + window.scrollY}px`;
    };

    /**
  * Điều phối quy trình nhập Excel theo nguyên tắc "Hợp nhất thông minh" (Smart Merge):
 * 1. Đọc file Excel, lấy cả dữ liệu (jsonData) và danh sách cột (headers).
 * 2. Xây dựng gói dữ liệu "chỉ cập nhật" (buildImportUpdates_Merge).
 * 3. Hợp nhất (update) gói dữ liệu này vào CSDL mà không xóa.
 * 4. Kích hoạt quy trình tính toán & dọn dẹp (recalculateAllCostsAndReload).
 * 5. Tải lại giao diện.
 */
/**
 * HÀM CẬP NHẬT: Thêm kiểm tra chế độ Edit Mode
 */
window.importData = function() {
    // 1. Kiểm tra đăng nhập
    if (!isAuthenticated) return showAuthError();

    // 2. [MỚI] Kiểm tra xem chế độ sửa đổi có đang bật không
    if (editModeStatusByYear[currentYear] !== true) {
        alert("Chức năng NHẬP DỮ LIỆU đang bị khóa.\n\nVui lòng liên hệ Admin cấp quyền trước khi thực hiện hành động này.");
        return;
    }

    const fileInput = document.getElementById('excelFile');
    if (!fileInput.files.length) {
        statusDiv.className = 'error';
        statusDiv.innerText = "Vui lòng chọn một file Excel (.xlsx).";
        return;
    }

    // Thông báo về hành động Hợp nhất
    if (!confirm(`HÀNH ĐỘNG: HỢP NHẤT DỮ LIỆU.\n\nCác tác vụ trong file Excel sẽ được CẬP NHẬT vào CSDL.\nCác tác vụ không có trong file Excel sẽ được GIỮ NGUYÊN.\n\nCẢNH BÁO: Nếu file Excel có cột dữ liệu nào thì dữ liệu đó trong CSDL sẽ bị GHI ĐÈ.\n\nBạn có muốn tiếp tục không?`)) {
        fileInput.value = ''; // Reset file input nếu hủy
        return;
    }

    const reader = new FileReader();
    reader.onload = async (event) => {
        const importButton = document.querySelector('#dataManagementModal .btn-primary[onclick="importData()"]');
        try {
            if(importButton) importButton.disabled = true; // Vô hiệu hóa nút nhập
            statusDiv.className = 'success';
            statusDiv.innerText = "Đang đọc file Excel...";

            const workbook = XLSX.read(new Uint8Array(event.target.result), { type: 'array' });
            // Đọc sheet đầu tiên
            const firstSheetName = workbook.SheetNames[0];
            const worksheet = workbook.Sheets[firstSheetName];
            // Lấy header một cách an toàn
            const headerJson = XLSX.utils.sheet_to_json(worksheet, { header: 1 });
            const headers = headerJson.length > 0 ? headerJson[0].map(String) : []; // Lấy dòng đầu tiên làm header
            // Đọc dữ liệu với header đã xác định
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: '' }); // defval: '' để ô trống là chuỗi rỗng

            statusDiv.innerText = "Đã đọc file. Đang xây dựng gói dữ liệu hợp nhất...";

            // BƯỚC 1: Xây dựng gói dữ liệu (Hàm mới v4 - "Schema-Aware")
            const updates = buildImportUpdates_Merge(jsonData, headers);

            if (Object.keys(updates).length === 0) {
                 throw new Error("Không tìm thấy dữ liệu hợp lệ trong file Excel. Vui lòng kiểm tra định dạng cột TT (tiêu đề cột TT phải là chữ hoa, các mã hiệu phải đúng tiêu chuẩn) và nội dung bảng dữ liệu.");
            }

            // BƯỚC 2: Hợp nhất (Merge) dữ liệu vào CSDL
            statusDiv.innerText = "Đang hợp nhất dữ liệu vào CSDL...";
            // KHÔNG XÓA CSDL
            await update(ref(db), updates);

            // BƯỚC 3: Kích hoạt quy trình rà soát, tính toán và dọn dẹp
            statusDiv.innerText = "Hợp nhất thành công! Đang rà soát và tính toán lại toàn bộ dữ liệu...";
            await window.recalculateAllCostsAndReload(false); // false = không hiển thị confirm()

            statusDiv.innerText = "Hoàn tất! Đang tải lại giao diện...";
            closeAllModals();
            await fetchData(); // Tải lại giao diện với dữ liệu đã được tính toán

        } catch (error) {
            console.error("Lỗi khi nhập: ", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi: ${error.message}`;
        } finally {
             if(importButton) importButton.disabled = false; // Kích hoạt lại nút nhập
             fileInput.value = ''; // Reset file input sau khi hoàn tất hoặc lỗi
        }
    };
     reader.onerror = (error) => {
         console.error("Lỗi đọc file:", error);
         statusDiv.className = 'error';
         statusDiv.innerText = 'Lỗi khi đọc file. Vui lòng thử lại.';
         fileInput.value = ''; // Reset file input
     };
    reader.readAsArrayBuffer(fileInput.files[0]);
};

    /**
 * HÀM CẬP NHẬT: Thêm kiểm tra chế độ Edit Mode
 */
window.openDeleteAllDataModal = function() {
    // 1. Kiểm tra đăng nhập
    if (!isAuthenticated) return showAuthError();

    // 2. [MỚI] Kiểm tra xem chế độ sửa đổi có đang bật không
    if (editModeStatusByYear[currentYear] !== true) {
        alert("Chức năng XÓA TOÀN BỘ đang bị khóa.\n\nVui lòng đề nghị Admin cấp quyền trước khi thực hiện hành động này.");
        return;
    }

    document.getElementById('deleteAllDataModal').style.display = 'block';
    document.getElementById('deleteConfirmEmail').value = '';
    document.getElementById('deleteConfirmPassword').value = '';
};

    /**
 * HÀM CẬP NHẬT: Xóa toàn bộ dữ liệu (Có hỏi sao lưu Excel trước)
 */
/**
 * HÀM CẬP NHẬT (FIXED): Xóa toàn bộ dữ liệu (Backup đúng bản FULL XLSX)
 */
	window.confirmDeleteAllData = async function() {
    // 1. Kiểm tra điều kiện cơ bản
    if (!isAuthenticated) return showAuthError();
    
    // Kiểm tra Edit Mode
    if (editModeStatusByYear[currentYear] !== true) {
        alert("Chức năng XÓA TOÀN BỘ đang bị khóa.\n\nVui lòng tích chọn 'Cho phép sửa đổi, thêm, xóa dữ liệu' (cần quyền Admin) trước khi thực hiện hành động này.");
        return;
    }

    const email = document.getElementById('deleteConfirmEmail').value;
    const password = document.getElementById('deleteConfirmPassword').value;
    
    if (!email || !password) { 
        alert('Vui lòng nhập đầy đủ email và mật khẩu.'); 
        return; 
    }

    const deleteButton = document.querySelector('#deleteAllDataModal .btn-danger');
    
    try {
        deleteButton.disabled = true;
        deleteButton.textContent = 'Đang xác thực...';
        
        // 2. Xác thực lại với Firebase
        const credential = EmailAuthProvider.credential(email, password);
        await reauthenticateWithCredential(auth.currentUser, credential);
        
        statusDiv.className = 'success'; 
        statusDiv.innerText = "Đã xác thực thành công.";

        // 3. Hỏi người dùng có muốn sao lưu không
        const wantBackup = confirm("XÁC THỰC THÀNH CÔNG.\n\nTrước khi xóa vĩnh viễn dữ liệu, bạn có muốn xuất file Excel (.xlsx bản Full) để sao lưu không?");

        if (wantBackup) {
            try {
                statusDiv.innerText = "Đang tạo file sao lưu bản Full...";
                
                // === [FIX QUAN TRỌNG]: Ép buộc chế độ 'full' để lấy đủ cột (Đơn giá, Ghi chú...) ===
                const originalExportType = activeExportType; // Lưu lại trạng thái cũ
                activeExportType = 'full'; 
                // ==================================================================================

                // Gọi hàm tạo dữ liệu (true = có giải trình)
                const { wb, ws } = await generateWorksheetWithFormulas(true);
                
                // Trả lại trạng thái cũ (cho gọn gàng, dù sắp xóa hết)
                activeExportType = originalExportType;

                // Đặt tên file backup
                const timestamp = new Date().toISOString().slice(0,19).replace(/:/g,"-");
                const backupFileName = `FULL_BACKUP_BDSC_${currentYear}_${timestamp}.xlsx`;

                XLSX.utils.book_append_sheet(wb, ws, 'Data');
                XLSX.writeFile(wb, backupFileName);
                
                // Đợi trình duyệt tải xuống
                await new Promise(resolve => setTimeout(resolve, 1500));
                
            } catch (exportError) {
                console.error("Lỗi khi xuất file backup:", exportError);
                if (!confirm(`CẢNH BÁO: Lỗi khi tạo file sao lưu (${exportError.message}).\n\nBạn có muốn tiếp tục XÓA DỮ LIỆU mà không có bản sao lưu không?`)) {
                    statusDiv.className = 'error';
                    statusDiv.innerText = "Đã hủy thao tác xóa do lỗi sao lưu.";
                    return; 
                }
            }
        }

        // 4. Tiến hành Xóa dữ liệu
        statusDiv.innerText = "Đang tiến hành xóa dữ liệu trên hệ thống...";
        deleteButton.textContent = 'Đang xóa...';
        
        await set(ref(db, getParentCollectionName()), null);
        
        statusDiv.innerText = "Đã xoá toàn bộ dữ liệu thành công.";
        closeAllModals();
        await fetchData();

    } catch (error) {
        console.error("Lỗi khi xoá: ", error);
        if (error.code === 'auth/invalid-credential') {
            alert('Email hoặc mật khẩu không chính xác. Thao tác xóa đã bị hủy.');
            statusDiv.className = 'error';
            statusDiv.innerText = "Xác thực thất bại.";
        } else {
            statusDiv.className = 'error';
            statusDiv.innerText = "Lỗi khi xoá: " + error.message;
        }
    } finally {
        deleteButton.disabled = false;
        deleteButton.textContent = 'Xác nhận xóa toàn bộ';
    }
};

   // HÀM MỚI: Xác thực bằng tài khoản Admin cố định

   window.promptForUnlock = async function() {
        const adminEmail = "admin@pvgaslpg.com.vn";
        const unlockBtn = document.getElementById('unlockButton');
        const originalText = "Admin/Cấp phép chỉnh sửa";
        const toggleDiv = document.getElementById('editModeToggle');
        const checkbox = document.getElementById('editModeCheckbox');

        // Lấy trạng thái thực tế từ Database để hiển thị đúng
        const isCurrentlyEnabled = editModeStatusByYear[currentYear] === true;

        // 1. KIỂM TRA ĐĂNG NHẬP HIỆN TẠI (Đi tiếp nếu đã là Admin)
        const currentUser = auth.currentUser;
        if (currentUser && currentUser.email === adminEmail) {
            // Đã là Admin -> Chỉ chuyển đổi giao diện
            statusDiv.className = 'success';
            statusDiv.innerText = "Đã nhận diện Admin.";

            unlockBtn.style.display = 'none';
            toggleDiv.style.display = 'block';
            
            // SỬA LỖI: Chỉ hiển thị trạng thái hiện tại, KHÔNG tự động bật
            checkbox.checked = isCurrentlyEnabled;
            return;
        }

        // 2. Nếu chưa phải Admin -> Hỏi mật khẩu
        const password = prompt(`Nhập mật khẩu quản trị (${adminEmail}):`);
        if (password === null) return;

        try {
            unlockBtn.disabled = true;
            unlockBtn.textContent = "Đang xác thực...";

            // Thực hiện Đăng nhập
            await signInWithEmailAndPassword(auth, adminEmail, password);

            statusDiv.className = 'success';
            statusDiv.innerText = "Xác thực thành công.";
            
            // SỬA LỖI: Chỉ chuyển đổi giao diện hiển thị
            unlockBtn.style.display = 'none';
            toggleDiv.style.display = 'block';
            
            // SỬA LỖI: Tuyệt đối không tự động update DB hay tự động check
            // Checkbox chỉ phản ánh đúng trạng thái hiện tại của hệ thống
            checkbox.checked = isCurrentlyEnabled;

        } catch (error) {
            console.error(error);
            alert("Mật khẩu không chính xác hoặc lỗi kết nối.");
            statusDiv.className = 'error';
            statusDiv.innerText = "Lỗi xác thực.";
            
            // Reset lại nút nếu lỗi
            unlockBtn.disabled = false;
            unlockBtn.textContent = originalText;
        }
    };

    window.toggleEditMode = async function(isChecked) {
        if (!isAuthenticated) {
            document.getElementById('editModeCheckbox').checked = !isChecked;
            return showAuthError();
        }
        try {
            const settingsRef = ref(db, 'settings/global');
            await update(settingsRef, { editModeStatus: { [currentYear]: isChecked } });
        } catch (error) {
            console.error("Lỗi khi cập nhật trạng thái mở khóa:", error);
            alert("Đã có lỗi xảy ra khi lưu trạng thái. Vui lòng thử lại.");
        }
    };

window.saveTasks = async function() {
        if (!isAuthenticated) return showAuthError();
        const saveButton = document.getElementById('modalSaveButton');
        try {
            saveButton.disabled = true; saveButton.textContent = 'Đang lưu...';
            const updates = {};
            const rows = document.querySelectorAll("#dataModal .modal-table tbody tr");
            const pathsToRecalculate = new Set();
            const justificationPathsToRecalculate = new Set();

            for (const row of rows) {
                const path = row.dataset.path;
                const isLeafNode = row.dataset.isLeaf === 'true'; 
                const isJustification = path.includes('/justifications/') || path.includes('/subJustifications/');

                row.querySelectorAll('input[data-field], select[data-field]').forEach(input => {
                    const field = input.dataset.field;
                    const fieldPath = `${path}/${field}`; 

                    // --- SỬA LỖI QUAN TRỌNG TẠI ĐÂY ---
                    // Nếu là Chi phí bị khóa: Chỉ bỏ qua nếu KHÔNG PHẢI là giải trình.
                    // (Vì giải trình luôn bị khóa chi phí nhưng vẫn CẦN lưu giá trị đó)
                    if (field === 'chiPhi' && input.disabled && !isJustification) { return; }
                    // ----------------------------------

                    if (field === 'tt') {
                        updates[fieldPath] = convertTTForStorage(input.value);
                    } 
                    else if (['chiPhi', 'khNamTruoc', 'thucHienNamTruoc', 'soLuong', 'donGia'].includes(field)) { 
                        updates[fieldPath] = parseFormattedNumber(input.value);
                    }
                    else if (field === 'namPhanBo') {
                        if (input.value.trim() === '' || input.value == 0) {
                            updates[fieldPath] = 1; 
                        } else {
                            updates[fieldPath] = parseFormattedNumber(input.value);
                        }
                    }
                    else if (field === 'tanSuatTH') {
                        if (input.value.trim() === '') {
                            updates[fieldPath] = 1; 
                        } else {
                            const value = parseInt(input.value, 10);
                            updates[fieldPath] = isNaN(value) || value < 0 ? 0 : value;
                        }
                    } 
                    else {
                        updates[fieldPath] = input.value;
                    }
                });

                if (isJustification) {
                    // Logic tìm cha để tính toán lại tổng
                    let leafNodePath = '';
                    if (path.includes('/subJustifications/')) {
                        // Nếu là sub, tìm lên cha của cha (Task lá)
                        // path: .../justifications/JID/subJustifications/SID
                        const justPath = path.substring(0, path.indexOf('/subJustifications/'));
                        leafNodePath = justPath.substring(0, justPath.indexOf('/justifications/'));
                    } else {
                        leafNodePath = path.substring(0, path.indexOf('/justifications/'));
                    }
                    justificationPathsToRecalculate.add(leafNodePath);
                    
                    // Đã loại bỏ đoạn tính toán thủ công updates[`${path}/chiPhi`] ở đây
                    // Vì bây giờ ta đã lấy trực tiếp giá trị từ ô input (đã được tính bởi calculateModalChiPhi)
                } else {
                    pathsToRecalculate.add(path);
                    const docSnap = await get(ref(db, path));
                    if (docSnap.exists() && !docSnap.val().hasChildren) {
                        const chiPhiInput = row.querySelector('input[data-field="chiPhi"]');
                        const chiPhi = chiPhiInput ? parseFormattedNumber(chiPhiInput.value) : (docSnap.val().chiPhi || 0);
                        const chiPhiThucHien = docSnap.val().chiPhiThucHien || 0;
                        updates[`${path}/keHoachConLai`] = chiPhi - chiPhiThucHien;
                    }
                    
                    if (isLeafNode) {
                        const namPbInput = row.querySelector('input[data-field="namPhanBo"]');
                        let finalChiPhi = updates[`${path}/chiPhi`] !== undefined ? updates[`${path}/chiPhi`] : parseFormattedNumber(row.querySelector('input[data-field="chiPhi"]').value);
                        
                        if (namPbInput) {
                            let nam = updates[`${path}/namPhanBo`];
                            if (nam === undefined) { 
                                if (namPbInput.value.trim() === '' || namPbInput.value == 0) nam = 1;
                                else nam = parseFormattedNumber(namPbInput.value);
                            }
                            
                            const cpPb = (nam > 0) ? Math.round(finalChiPhi / nam) : 0;
                            updates[`${path}/chiPhiPhanBo`] = cpPb;
                        }
                        
                        // Cập nhật CP Cấp 1
                        const capDoInput = row.querySelector('input[data-field="capDo"]');
                        const capDoStr = capDoInput ? String(capDoInput.value).trim().toLowerCase() : '';
                        let cpCap1 = 0;
                        if (capDoStr === '1' || capDoStr === '') cpCap1 = finalChiPhi;
                        else if (capDoStr === '6t') cpCap1 = Math.round(finalChiPhi * 0.5);
                        updates[`${path}/cpCap1`] = cpCap1;
                    }
                }
            }

            if (Object.keys(updates).length > 0) {
                await update(ref(db), updates);
            }
            
            if (justificationPathsToRecalculate.size > 0) {
                 await recalculateCostsAfterJustificationChange(Array.from(justificationPathsToRecalculate));
            }
            
            if (pathsToRecalculate.size > 0) {
                await recalculateCostsForParents(Array.from(pathsToRecalculate));
            }

            await calculateSummaryData();
            closeAllModals();
            await fetchData();
            statusDiv.className = 'success';
            statusDiv.innerText = `Đã cập nhật ${rows.length} công việc.`;
        } catch (error) {
            console.error("Lỗi khi lưu:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi khi lưu: ${error.message}`;
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = 'Lưu thay đổi';
        }
    };

// === CẬP NHẬT: HÀM saveNewTasks (Xử lý Lưu nhiều dòng từ Modal Thêm mới) ===
  window.saveNewTasks = async function(parentPath, level) {
        if (!isAuthenticated) return showAuthError();
        const saveButton = document.getElementById('modalSaveButton');
        try {
            saveButton.disabled = true; saveButton.textContent = 'Đang lưu...';
            
            const updates = {};
            const parentUpdates = {}; 
            const rows = document.querySelectorAll("#dataModal .modal-table tbody tr");
            
            if (rows.length === 0) {
                 throw new Error("Không có dòng nào để lưu.");
            }

            const pathsToRecalculate = new Set();
            const justificationPathsToRecalculate = new Set();

            let subCollectionName;
            if (level === 'child') subCollectionName = 'children';
            else if (level === 'grandchild') subCollectionName = 'grandchildren';
            else if (level === 'greatGrandchild') subCollectionName = 'greatGrandchildren';
            else if (level === 'greatGreatGrandchild') subCollectionName = 'greatGreatGrandchildren';
            else if (level === 'justification') subCollectionName = 'justifications';
            else if (level === 'subJustification') subCollectionName = 'subJustifications';
            else {
                console.error("Level không hợp lệ:", level);
                return;
            }

            const parentRef = ref(db, parentPath);
            const parentSnap = await get(parentRef);
            const parentData = parentSnap.exists() ? parentSnap.val() : {};

            for (const row of rows) {
                const newData = {};
                const ttInput = row.querySelector('input[data-field="tt"]');
                if (!ttInput) continue;
                
                const newTT = convertTTForStorage(ttInput.value);

                row.querySelectorAll('input[data-field], select[data-field]').forEach(input => {
                    const field = input.dataset.field;
                    if (field === 'tt') return; 

                    if (level === 'justification' || level === 'subJustification') {
                        // --- CẬP NHẬT: Thêm ghiChu vào danh sách lấy dữ liệu ---
                        if (['noiDung', 'donVi', 'ghiChu'].includes(field)) {
                            newData[field] = input.value;
                        } else if (['soLuong', 'donGia'].includes(field)) {
                            newData[field] = parseFormattedNumber(input.value);
                        }
                    } else {
                        if (field === 'tanSuatTH') {
                            if (input.value.trim() === '') {
                                newData[field] = 1; 
                            } else {
                                const value = parseInt(input.value, 10);
                                newData[field] = isNaN(value) || value < 0 ? 0 : value;
                            }
                        } 
                        else if (field === 'namPhanBo') {
                             if (input.value.trim() === '' || input.value == 0) newData[field] = 1;
                             else newData[field] = parseFormattedNumber(input.value);
                        }
                        else if (['chiPhi', 'khNamTruoc', 'thucHienNamTruoc'].includes(field)) {
                            newData[field] = parseFormattedNumber(input.value);
                        } else {
                            newData[field] = input.value;
                        }
                    }
                });

                newData.tt = newTT; 
                const newDocPath = `${parentPath}/${subCollectionName}/${newTT}`;

               if (level === 'justification' || level === 'subJustification') {
                    const soLuong = newData.soLuong || 0;
                    const donGia = newData.donGia || 0;
                    newData.chiPhi = soLuong * donGia;

                    let leafNodePath = parentPath;
                    if (level === 'subJustification') {
                        leafNodePath = parentPath.substring(0, parentPath.indexOf('/justifications/'));
                    }
                    justificationPathsToRecalculate.add(leafNodePath);
                    pathsToRecalculate.add(leafNodePath); 

                } else {
                    newData.isHidden = false;
                    newData.chiPhi = newData.chiPhi || 0;
                    newData.chiPhiThucHien = 0;
                    newData.keHoachConLai = newData.chiPhi;
                    newData.khNamTruoc = newData.khNamTruoc || 0;
                    newData.thucHienNamTruoc = newData.thucHienNamTruoc || 0;
                    newData.tgBatDau = newData.tgBatDau || '';
                    newData.tgHoanThanh = newData.tgHoanThanh || '';
                    
                    if (['greatGrandchild', 'greatGreatGrandchild'].includes(level)) {
                        const nam = newData.namPhanBo || 1; 
                        newData.chiPhiPhanBo = Math.round(newData.chiPhi / nam);
                    } else {
                        newData.chiPhiPhanBo = 0; 
                    }

                    pathsToRecalculate.add(newDocPath);
                }

                if (!newData.noiDung) {
                    alert(`Nội dung cho mục ${convertTTForDisplay(newTT)} không được để trống!`);
                    throw new Error("Validation failed");
                }

                updates[newDocPath] = newData;

                if (level === 'subJustification' && !parentUpdates[`${parentPath}/hasSubJustifications`]) {
                    parentUpdates[`${parentPath}/hasSubJustifications`] = true;
                    parentUpdates[`${parentPath}/soLuong`] = '';
                    parentUpdates[`${parentPath}/donGia`] = '';
                }

                if (level === 'greatGreatGrandchild' && !parentUpdates[`${parentPath}/hasChildren`]) {
                    if (parentData && !parentData.hasChildren) {
                        const execSnapshot = await get(ref(db, `${parentPath}/executions`));
                        const justSnapshot = await get(ref(db, `${parentPath}/justifications`));
                        if ((execSnapshot.exists() && Object.keys(execSnapshot.val()).length > 0) || 
                            (justSnapshot.exists() && Object.keys(justSnapshot.val()).length > 0)) {
                            alert(`Lỗi: Không thể thêm công việc con vào mục ${parentData.tt} vì nó đã được thực hiện hoặc đã có giải trình.`);
                            throw new Error("Cannot add child to executed/justified item");
                        }
                        parentUpdates[`${parentPath}/hasChildren`] = true;
                        parentUpdates[`${parentPath}/chiPhi`] = 0;
                        parentUpdates[`${parentPath}/chiPhiThucHien`] = 0;
                        parentUpdates[`${parentPath}/keHoachConLai`] = 0;
                        parentUpdates[`${parentPath}/soLuong`] = '';
                        parentUpdates[`${parentPath}/donVi`] = '';
                        parentUpdates[`${parentPath}/namPhanBo`] = '';
                        parentUpdates[`${parentPath}/chiPhiPhanBo`] = 0;
                    } else {
                        parentUpdates[`${parentPath}/hasChildren`] = true;
                    }
                }
            } 

            Object.assign(updates, parentUpdates);
            await update(ref(db), updates);

            if (justificationPathsToRecalculate.size > 0) {
                await recalculateCostsAfterJustificationChange(Array.from(justificationPathsToRecalculate));
            }
            if (pathsToRecalculate.size > 0) {
                await recalculateCostsForParents(Array.from(pathsToRecalculate));
            }
            
            closeAllModals();
            await fetchData();
            statusDiv.className = 'success';
            statusDiv.innerText = `Đã thêm thành công ${rows.length} mục mới.`;

        } catch (error) {
            console.error("Lỗi khi lưu nhiều mục mới:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi khi lưu: ${error.message}`;
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = 'Lưu thay đổi';
        }
    };

    // === CẬP NHẬT: HÀM addNewTask (Xử lý thêm 1 dòng đơn lẻ - Thường dùng cho context menu) ===
  /// === CẬP NHẬT: HÀM addNewTask (Thêm logic null cho Tần suất) ===
window.saveNewTasks = async function(parentPath, level) {
        if (!isAuthenticated) return showAuthError();
        const saveButton = document.getElementById('modalSaveButton');
        try {
            saveButton.disabled = true; saveButton.textContent = 'Đang lưu...';
            
            const updates = {};
            const parentUpdates = {}; 
            const rows = document.querySelectorAll("#dataModal .modal-table tbody tr");
            
            if (rows.length === 0) {
                 throw new Error("Không có dòng nào để lưu.");
            }

            const pathsToRecalculate = new Set();
            const justificationPathsToRecalculate = new Set();

            let subCollectionName;
            if (level === 'child') subCollectionName = 'children';
            else if (level === 'grandchild') subCollectionName = 'grandchildren';
            else if (level === 'greatGrandchild') subCollectionName = 'greatGrandchildren';
            else if (level === 'greatGreatGrandchild') subCollectionName = 'greatGreatGrandchildren';
            else if (level === 'justification') subCollectionName = 'justifications';
            else if (level === 'subJustification') subCollectionName = 'subJustifications';
            else {
                console.error("Level không hợp lệ:", level);
                return;
            }

            const parentRef = ref(db, parentPath);
            const parentSnap = await get(parentRef);
            const parentData = parentSnap.exists() ? parentSnap.val() : {};

            for (const row of rows) {
                const newData = {};
                const ttInput = row.querySelector('input[data-field="tt"]');
                if (!ttInput) continue;
                
                const newTT = convertTTForStorage(ttInput.value);

                row.querySelectorAll('input[data-field]').forEach(input => {
                    const field = input.dataset.field;
                    if (field === 'tt') return; 

                    if (level === 'justification' || level === 'subJustification') {
                        if (['noiDung', 'donVi', 'ghiChu'].includes(field)) {
                            newData[field] = input.value;
                        } 
                        // --- SỬA LỖI TẠI ĐÂY: Thêm 'chiPhi' vào danh sách lấy dữ liệu ---
                        else if (['soLuong', 'donGia', 'chiPhi'].includes(field)) {
                            newData[field] = parseFormattedNumber(input.value);
                        }
                        // -------------------------------------------------------------
                    } else {
                        if (field === 'tanSuatTH') {
                            if (input.value.trim() === '') {
                                newData[field] = 1; 
                            } else {
                                const value = parseInt(input.value, 10);
                                newData[field] = isNaN(value) || value < 0 ? 0 : value;
                            }
                        } 
                        else if (field === 'namPhanBo') {
                             if (input.value.trim() === '' || input.value == 0) newData[field] = 1;
                             else newData[field] = parseFormattedNumber(input.value);
                        }
                        else if (['chiPhi', 'khNamTruoc', 'thucHienNamTruoc'].includes(field)) {
                            newData[field] = parseFormattedNumber(input.value);
                        } else {
                            newData[field] = input.value;
                        }
                    }
                });

                newData.tt = newTT; 
                const newDocPath = `${parentPath}/${subCollectionName}/${newTT}`;

               if (level === 'justification' || level === 'subJustification') {
                    // Dữ liệu chiPhi đã được lấy từ input (đã tính toán) nên không cần tính lại
                    // Tuy nhiên nếu người dùng không nhập gì thì vẫn đảm bảo logic
                    const soLuong = newData.soLuong || 0;
                    const donGia = newData.donGia || 0;
                    if (newData.chiPhi === undefined || newData.chiPhi === 0) {
                         newData.chiPhi = soLuong * donGia;
                    }

                    let leafNodePath = parentPath;
                    if (level === 'subJustification') {
                        leafNodePath = parentPath.substring(0, parentPath.indexOf('/justifications/'));
                    }
                    justificationPathsToRecalculate.add(leafNodePath);
                    pathsToRecalculate.add(leafNodePath); 

                } else {
                    newData.isHidden = false;
                    
                    if (['grandchild', 'greatGrandchild'].includes(level)) {
                        newData.hasChildren = false;
                    }
                    
                    newData.chiPhi = newData.chiPhi || 0;
                    newData.chiPhiThucHien = 0;
                    newData.keHoachConLai = newData.chiPhi;
                    newData.khNamTruoc = newData.khNamTruoc || 0;
                    newData.thucHienNamTruoc = newData.thucHienNamTruoc || 0;
                    newData.tgBatDau = newData.tgBatDau || '';
                    newData.tgHoanThanh = newData.tgHoanThanh || '';
                    
                    const nam = newData.namPhanBo || 1; 
                    newData.chiPhiPhanBo = Math.round(newData.chiPhi / nam);

                    let cpCap1 = 0;
                    const capDoStr = String(newData.capDo || '').trim().toLowerCase();
                    if (capDoStr === '1' || capDoStr === '') cpCap1 = newData.chiPhi;
                    else if (capDoStr === '6t') cpCap1 = Math.round(newData.chiPhi * 0.5);
                    newData.cpCap1 = cpCap1;

                    pathsToRecalculate.add(newDocPath);
                }

                if (!newData.noiDung) {
                    alert(`Nội dung cho mục ${convertTTForDisplay(newTT)} không được để trống!`);
                    throw new Error("Validation failed");
                }

                updates[newDocPath] = newData;

                if (level === 'subJustification' && !parentUpdates[`${parentPath}/hasSubJustifications`]) {
                    parentUpdates[`${parentPath}/hasSubJustifications`] = true;
                    parentUpdates[`${parentPath}/soLuong`] = '';
                    parentUpdates[`${parentPath}/donGia`] = '';
                }

                if (['grandchild', 'greatGrandchild'].includes(level)) {
                     parentUpdates[`${parentPath}/hasChildren`] = true;
                }
            } 

            Object.assign(updates, parentUpdates);
            await update(ref(db), updates);

            if (justificationPathsToRecalculate.size > 0) {
                await recalculateCostsAfterJustificationChange(Array.from(justificationPathsToRecalculate));
            }
            if (pathsToRecalculate.size > 0) {
                await recalculateCostsForParents(Array.from(pathsToRecalculate));
            }
            
            closeAllModals();
            await fetchData();
            statusDiv.className = 'success';
            statusDiv.innerText = `Đã thêm thành công ${rows.length} mục mới.`;

        } catch (error) {
            console.error("Lỗi khi lưu nhiều mục mới:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi khi lưu: ${error.message}`;
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = 'Lưu thay đổi';
        }
    };

  window.saveMultiExecutionData = async function() {
        if (!isAuthenticated) return showAuthError();
        const saveButton = document.getElementById('modalSaveButton');
        
        try {
            saveButton.disabled = true; 
            saveButton.textContent = 'Đang lưu...';
            const updates = {};
            const rows = document.querySelectorAll("#dataModal .modal-table tbody tr");
            const ngayThucHien = document.getElementById('executionDate').value;
            
            if (!ngayThucHien) throw new Error("Vui lòng chọn ngày thực hiện.");

            // === BỔ SUNG: KIỂM TRA NGÀY THỰC HIỆN (Không quá 10 ngày tương lai) ===
            // 1. Tạo đối tượng Date từ ngày nhập vào (lúc 00:00:00)
            const parts = ngayThucHien.split('-');
            const selectedDate = new Date(parts[0], parts[1] - 1, parts[2]); 
            
            // 2. Tạo đối tượng Date cho ngày hiện tại (lúc 00:00:00) để so sánh chính xác
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            
            // 3. Tính khoảng cách ngày
            const diffTime = selectedDate - today;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 

            if (diffDays > 10) {
                alert("Lỗi: Ngày thực hiện không được phép vượt quá 10 ngày so với ngày hiện tại.");
                throw new Error("Ngày thực hiện không hợp lệ (vượt quá 10 ngày tương lai).");
            }
            // ======================================================================

            statusDiv.className = 'success'; 
            statusDiv.innerText = "Đang lưu dữ liệu thực hiện...";
            const commonTimestamp = Date.now();
            const pathsToRecalculate = [];
            const childPathsToUpdate = new Set();

            for (const row of rows) {
                const leafNodePath = row.dataset.path;
                const leafNodeDocSnap = await get(ref(db, leafNodePath));
                if (!leafNodeDocSnap.exists()) continue;

                const pathParts = leafNodePath.split('/');
                const childPath = pathParts.slice(0, 4).join('/');
                childPathsToUpdate.add(childPath);

                const leafNodeData = leafNodeDocSnap.val();
                const initialChiPhi = leafNodeData.chiPhi || 0;
                const soLuong = parseNumber(row.querySelector('input[data-field="dvt"]').value);
                const thanhTien = parseFormattedNumber(row.querySelector('input[data-field="thanhTien"]').value);

                if (soLuong <= 0) continue; 

                pathsToRecalculate.push(leafNodePath);
                const executionCollectionRef = ref(db, `${leafNodePath}/executions`);
                const executionSnapshot = await get(executionCollectionRef);
                let lanThucHien = 1;
                if (executionSnapshot.exists()) {
                    lanThucHien = Object.keys(executionSnapshot.val()).length + 1;
                }
                const newExecutionData = {
                    dvt: soLuong,
                    donGia: parseNumber(row.querySelector('input[data-field="donGia"]').value),
                    thanhTien: thanhTien,
                    lanThucHien: lanThucHien,
                    ngayThucHien: ngayThucHien,
                    timestamp: commonTimestamp
                };
                updates[`${leafNodePath}/executions/${lanThucHien}`] = newExecutionData;

                const currentThucHien = leafNodeData.chiPhiThucHien || 0;
                const newThucHien = currentThucHien + thanhTien;
                updates[`${leafNodePath}/chiPhiThucHien`] = newThucHien;
                updates[`${leafNodePath}/keHoachConLai`] = leafNodeData.chiPhi - newThucHien;
            }

            childPathsToUpdate.forEach(path => {
                updates[`${path}/daThucHien`] = true; 
            });

            await update(ref(db), updates); 

            await recalculateCostsForParents(pathsToRecalculate);

            for (const childPath of childPathsToUpdate) {
                await checkAndUpdateDaThucHien(childPath);
            }

            await calculateSummaryData();

            closeAllModals();
            await fetchData(); 
            statusDiv.innerText = `Đã lưu các mục thực hiện thành công.`;

        } catch (error) {
            console.error("Lỗi khi lưu thực hiện:", error);
            statusDiv.className = 'error'; 
            statusDiv.innerText = `Lỗi khi lưu: ${error.message}`;
        } finally {
            saveButton.disabled = false; 
            saveButton.textContent = 'Lưu thay đổi';
        }
    };

    // === BẮT ĐẦU ĐOẠN MÃ THAY THẾ ===
window.saveExecutionEdits = async function() {
    if (!isAuthenticated) return showAuthError();
    const saveButton = document.getElementById('modalSaveButton');
    try {
        saveButton.disabled = true;
        saveButton.textContent = 'Đang lưu...';
        const updates = {};
        const rows = document.querySelectorAll("#dataModal .modal-table tbody tr");
        const pathsToRecalculate = new Set();
        const childPathsToUpdate = new Set();

        for (const row of rows) {
            const execPath = row.dataset.execPath;
            const parentLeafNodePath = execPath.substring(0, execPath.lastIndexOf('/executions/'));
            const childPath = parentLeafNodePath.split('/').slice(0, 4).join('/');
            pathsToRecalculate.add(parentLeafNodePath);
            childPathsToUpdate.add(childPath);

            // SỬA LỖI: Cập nhật từng trường bằng đường dẫn đầy đủ để merge, không ghi đè
            updates[`${execPath}/dvt`] = parseNumber(row.querySelector('input[data-field="dvt"]').value);
            updates[`${execPath}/donGia`] = parseNumber(row.querySelector('input[data-field="donGia"]').value);
            updates[`${execPath}/thanhTien`] = parseFormattedNumber(row.querySelector('input[data-field="thanhTien"]').value);
        }

        // Đoạn code còn lại không cần thay đổi
        childPathsToUpdate.forEach(path => {
            updates[`${path}/daThucHien`] = true;
        });

        await update(ref(db), updates);

        const recalcPromises = Array.from(pathsToRecalculate).map(path => recalculateExecutionCost(path));
        await Promise.all(recalcPromises);

        for (const childPath of childPathsToUpdate) {
            await checkAndUpdateDaThucHien(childPath);
        }

        await recalculateCostsForParents(Array.from(pathsToRecalculate));

        closeAllModals();
        await fetchData(); // Tải lại dữ liệu để cập nhật giao diện
        statusDiv.className = 'success';
        statusDiv.innerText = "Đã cập nhật thành công lần thực hiện.";

    } catch (error) {
        console.error("Lỗi khi sửa thực hiện:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi khi sửa: ${error.message}`;
    } finally {
        saveButton.disabled = false;
        saveButton.textContent = 'Lưu thay đổi';
    }
};
// === hàm cho nút xoá trong modal sửa ===

 window.handleDeleteExecution = async function(timestampKey) {
        if (!isAuthenticated) return showAuthError();
        if (!confirm("Bạn có chắc chắn muốn xóa lần thực hiện này không? Hành động này không thể hoàn tác.")) return;
        const exportBeforeDelete = confirm("Bạn có muốn xuất chi tiết lần thực hiện này ra Excel trước khi xóa không?");
        try {
            if (exportBeforeDelete) {
                // Lưu ý: hàm exportSingleExecutionToExcel(timestampKey) có thể cũng bị lỗi
                // và cần được cập nhật nếu nó tồn tại.
                // Tạm thời giả định nó không tồn tại hoặc bạn không dùng.
                // await exportSingleExecutionToExcel(timestampKey);
                // statusDiv.innerText = "Xuất Excel thành công. Chuẩn bị xóa...";
            }
            statusDiv.className = 'success';
            statusDiv.innerText = "Đang xóa dữ liệu...";

            // === SỬA LỖI: Cập nhật logic flattening cho cấu trúc 3 cấp ===
            const timestampGroup = executionGroups.get(timestampKey);
            const group = Object.values(timestampGroup).flatMap(grandchildGroup => 
                Object.values(grandchildGroup).flat()
            );
            // === KẾT THÚC SỬA LỖI ===
            
            const updates = {};
            const pathsToRecalculate = new Set(group.map(exec => exec.parentLeafNodePath));
            const childPathsToCheck = new Set(group.map(exec => exec.parentChildPath));
            group.forEach(exec => updates[exec.path] = null);
            await update(ref(db), updates);
            statusDiv.innerText = "Đã xóa. Đang cập nhật lại chi phí và trạng thái...";
            const recalcPromises = Array.from(pathsToRecalculate).map(path => recalculateExecutionCost(path));
            await Promise.all(recalcPromises);
            for (const childPath of childPathsToCheck) {
                await checkAndUpdateDaThucHien(childPath);
            }
            await recalculateCostsForParents(Array.from(pathsToRecalculate));
            closeAllModals();
            await fetchData();
            statusDiv.innerText = "Đã xóa thành công lần thực hiện.";
        } catch (error) {
             console.error("Lỗi khi xóa thực hiện:", error);
             statusDiv.className = 'error';
             statusDiv.innerText = `Lỗi khi xóa: ${error.message}`;
        }
    };

 window.performPdfUpload = async function(timestampKey) {
        if (!isAuthenticated) return showAuthError(); 
        
        const googleToken = gapi.client.getToken();
        if (!googleToken || !googleToken.access_token) {
            statusDiv.className = 'error';
            statusDiv.innerText = 'Phiên đăng nhập Google đã hết hạn hoặc không hợp lệ. Vui lòng thử lại thao tác "Hồ sơ".';
            closeAllModals(); 
            return;
        }

        const uploadButton = document.getElementById('uploadPdfButton');
        const fileInput = document.getElementById('pdf_file_input');
        const file = fileInput.files[0];
        if (!file) { 
            alert('Vui lòng chọn một tệp PDF.'); 
            return; 
        }
        
        try {
            uploadButton.disabled = true; 
            uploadButton.textContent = 'Đang tải...';
            statusDiv.className = 'success'; 
            statusDiv.innerText = 'Đang tải tệp lên Google Drive...';
            
            const metadata = { name: file.name, mimeType: 'application/pdf', parents: [FOLDER_ID] };
            const formData = new FormData();
            formData.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
            formData.append('file', file);
            
            const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${googleToken.access_token}` }, 
                body: formData
            });
            if (!response.ok) { 
                const error = await response.json(); 
                throw new Error(`Lỗi API Drive: ${error.error.message}`); 
            }
            
            const fileData = await response.json();
            const fileLink = `https://drive.google.com/file/d/${fileData.id}/view`;
            console.log('Tải lên Drive thành công:', fileLink);
            
            statusDiv.innerText = 'Đang cập nhật link hồ sơ vào cơ sở dữ liệu...';

            // --- BẮT ĐẦU SỬA ĐỔI: Cập nhật logic duyệt theo cấu trúc MỚI (2 cấp) ---
            // Cấu trúc mới: Map<timestamp, Object<directParentPath, Array<exec>>>
            const timestampGroup = executionGroups.get(timestampKey); 
            const updates = {};
            let updatedCount = 0;

            if (timestampGroup) {
                // Duyệt qua các nhóm cha trực tiếp (DirectParentPath)
                for (const parentPath in timestampGroup) {
                    // Lấy trực tiếp mảng executions (không cần duyệt qua leafPath nữa)
                    const executions = timestampGroup[parentPath]; 
                    
                    if (Array.isArray(executions)) {
                        executions.forEach(exec => {
                            // Kiểm tra timestamp để chắc chắn (dù đã filter theo key rồi)
                            if (String(exec.timestamp || exec.ngayThucHien) === String(timestampKey)) { 
                                updates[`${exec.path}/hoSoLink`] = fileLink; 
                                updatedCount++;
                            }
                        });
                    }
                }
            }
            // --- KẾT THÚC SỬA ĐỔI ---

            if (updatedCount > 0) {
                 await update(ref(db), updates);
                 console.log(`Đã cập nhật hoSoLink cho ${updatedCount} mục thực hiện.`);
            } else {
                 console.warn(`Không tìm thấy mục thực hiện nào khớp với timestampKey ${timestampKey} để cập nhật hoSoLink.`);
            }

            closeAllModals(); 
            await fetchData(); 
            statusDiv.className = 'success';
            statusDiv.innerText = `Tải lên và cập nhật hồ sơ thành công!`;

        } catch (error) {
            console.error('Lỗi khi tải tệp hồ sơ:', error);
            statusDiv.className = 'error';
            if (error.message.includes('token')) {
                 statusDiv.innerText = `Lỗi xác thực Google: ${error.message}. Vui lòng thử lại thao tác "Hồ sơ".`;
            } else if (error.message.includes('API Drive')) {
                 statusDiv.innerText = `Lỗi tải lên Google Drive: ${error.message}.`;
            } else {
                 statusDiv.innerText = `Đã xảy ra lỗi: ${error.message}`;
            }
        } finally {
            uploadButton.disabled = false;
            uploadButton.textContent = 'Tải Lên';
            fileInput.value = ''; 
        }
    };
    // === KẾT THÚC THAY THẾ ===

   window.handleEditClick = async function(docPath, level) {
        if (!isAuthenticated) return showAuthError();
		await loadEquipmentList();
        const allSelected = [...selectedTasks, ...selectedJustifications];
        const isMultiSelect = allSelected.some(p => p === docPath) && allSelected.length > 1;

        let pathsToEdit = isMultiSelect ? allSelected.sort() : [docPath];
        let title = isMultiSelect ? `Sửa ${pathsToEdit.length} mục đã chọn` : 'Sửa thông tin';
        document.getElementById('modalTitle').innerHTML = `<h2>${title}</h2>`;

        const isJustification = level === 'justification' || (pathsToEdit[0] && pathsToEdit[0].includes('justifications'));

        // === CẬP NHẬT HEADERS ĐẦY ĐỦ (ĐỒNG BỘ VỚI OPENADDMODAL) ===
        const headers = isJustification
            ? [ 
                {text: 'TT', width: '5%'}, 
                {text: 'Nội dung', width: '25%'}, 
                {text: 'Đ.vị tính', width: '10%'}, 
                {text: 'Số lượng', width: '10%'}, 
                {text: 'Đơn giá', width: '15%'}, 
                {text: 'Chi phí', width: '15%'},
                {text: 'Ghi chú', width: '20%'} // <-- Cột mới
            ]
            : [ 
                {text: 'TT', width: '2%'}, 
                {text: 'Nội dung', width: '20%'}, 
				{text: 'Tagname', width: '5%'},
                {text: 'ĐV th.hiện', width: '5%'}, 
                {text: 'KH năm trước', width: '6%'}, 
                {text: 'Thực hiện năm trước', width: '6%'}, 
                {text: 'Đ.vị tính', width: '4%'}, 
                {text: 'Số lượng', width: '5%'}, 
                {text: 'Tần suất', width: '3%'}, 
                {text: 'Chi phí', width: '7%'}, 
                {text: 'Năm PB', width: '3%'},     
                {text: 'CP p.bổ', width: '3%'}, 
                {text: 'Cấp độ', width: '3%'}, 
                {text: 'Thời điểm TH', width: '5%'}, 
                //{text: 'TG hoàn thành', width: '3%'}, 
                {text: 'Ghi chú', width: '15%'} 
            ];

        let table = createModalTable(headers);
        for (const path of pathsToEdit) {
            const currentIsJustification = path.includes('justifications');
            if (isMultiSelect && currentIsJustification !== isJustification) {
                continue;
            }
            const docSnap = await get(ref(db, path));
            if (!docSnap.exists()) continue;
            const data = docSnap.val();
            const pathLevel = currentIsJustification ? 'justification' : level;
            let context = {};
            if (pathLevel === 'greatGrandchild' && !data.hasChildren) {
                const justSnapshot = await get(ref(db, `${path}/justifications`));
                context.hasJustifications = justSnapshot.exists() && Object.keys(justSnapshot.val()).length > 0;
            }
            table += createInputRow(path, data, pathLevel, context);
        }
        table += '</tbody></table>';

        document.getElementById('modalBody').innerHTML = table;
        document.getElementById('modalSaveButton').onclick = saveTasks;
        document.getElementById('modalSaveButton').style.display = 'block';
        document.getElementById('modalDeleteButton').style.display = 'none';
        document.getElementById('modal-footer-left').innerHTML = '';
				enableArrowKeyNavigation('dataModal');
		document.getElementById('dataModal').style.display = 'block';
    };

// === BẮT ĐẦU: HÀM MỚI ĐỂ THÊM DÒNG VÀO MODAL ===
    window.addNewRowToModal = function(parentPath, level) {
        const modalTableBody = document.querySelector("#dataModal .modal-table tbody");
        if (!modalTableBody || !modalTableBody.lastElementChild) {
            console.error("Không tìm thấy bảng modal hoặc dòng cuối cùng.");
            return;
        }

        const lastRow = modalTableBody.lastElementChild;
        const lastTTInput = lastRow.querySelector('input[data-field="tt"]');
        if (!lastTTInput) {
             console.error("Không tìm thấy trường TT ở dòng cuối.");
             return;
        }

        try {
            const lastDisplayTT = lastTTInput.value;
            const nextDisplayTT = incrementTT(lastDisplayTT); // Sử dụng helper
            const nextStorageTT = convertTTForStorage(nextDisplayTT); // Chuyển về dạng '1,1'

            const newData = { tt: nextStorageTT };
            
            // Sử dụng một path giả lập, vì createInputRow yêu cầu nó.
            // Hàm saveNewTasks sẽ bỏ qua path này và tự xây dựng path thật.
            const dummyPath = `new_item_${Date.now()}`; 
            
            // Gọi createInputRow để tạo HTML cho dòng mới
            const rowHtml = createInputRow(dummyPath, newData, level);

            // Chuyển chuỗi HTML thành một DOM element
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = `<table><tbody>${rowHtml}</tbody></table>`;
            const newTr = tempDiv.querySelector('tr');

            if (newTr) {
                // Thêm dòng mới vào bảng
                modalTableBody.appendChild(newTr);
				// --- THÊM DÒNG NÀY ĐỂ KÍCH HOẠT PHÍM CHO DÒNG MỚI ---
                enableArrowKeyNavigation('dataModal');
                // Tự động focus vào ô nội dung của dòng mới
                newTr.querySelector('input[data-field="noiDung"]').focus();
            }
        } catch (e) {
            console.error("Lỗi khi thêm dòng mới vào modal:", e);
        }
    }
    // === KẾT THÚC: HÀM MỚI ĐỂ THÊM DÒNG VÀO MODAL ===

  
  window.openAddModal = async function(parentPath, level) {
        if (!isAuthenticated) return showAuthError();
    await loadEquipmentList();
        let title;
        if (level === 'justification') title = 'Thêm giải trình';
        else if (level === 'subJustification') title = 'Thêm giải trình con';
        else if (level === 'child') title = 'Thêm Hệ thống thiết bị/Hạng mục';
        else if (level === 'grandchild') title = 'Thêm thiết bị/Nhóm công việc';
        else if (level === 'greatGrandchild') title = 'Thêm vật tư/Đầu công việc';
        else title = `Thêm mục mới (Cấp: ${level})`;
        
        document.getElementById('modalTitle').innerHTML = `<h2>${title}</h2>`;

        // === CẬP NHẬT HEADERS (THÊM GHI CHÚ CHO GIẢI TRÌNH) ===
        const isJustificationLevel = (level === 'justification' || level === 'subJustification');
        
        // Tính toán độ rộng: Nội dung 25%, Ghi chú 20% (20/25 = 80%)
        const headers = isJustificationLevel
            ? [ 
                {text: 'TT', width: '5%'}, 
                {text: 'Nội dung', width: '25%'}, 
                {text: 'Đ.vị tính', width: '10%'}, 
                {text: 'Số lượng', width: '10%'}, 
                {text: 'Đơn giá', width: '15%'}, 
                {text: 'Chi phí', width: '15%'},
                {text: 'Ghi chú', width: '20%'} // <-- Cột mới
            ]
            : [ 
                {text: 'TT', width: '2%'}, 
                {text: 'Nội dung', width: '20%'}, 
				{text: 'Tagname', width: '5%'},
                {text: 'ĐV th.hiện', width: '5%'}, 
                {text: 'KH năm trước', width: '6%'}, 
                {text: 'Thực hiện năm trước', width: '6%'}, 
                {text: 'Đ.vị tính', width: '4%'}, 
                {text: 'Số lượng', width: '5%'}, 
                {text: 'Tần suất', width: '3%'}, 
                {text: 'Chi phí', width: '7%'}, 
                {text: 'Năm PB', width: '3%'},     
                {text: 'CP p.bổ', width: '3%'}, 
                {text: 'Cấp độ', width: '3%'}, 
                {text: 'Thời điểm TH', width: '5%'}, 
                //{text: 'TG hoàn thành', width: '3%'}, 
                {text: 'Ghi chú', width: '15%'} 
            ];

        let table = createModalTable(headers);
        
        const newTT = await generateNextTT(parentPath, level);
        const convertedNewTT = convertTTForStorage(newTT);
        const newData = { tt: convertedNewTT };
        const dummyPath = `new_item_${Date.now()}`;
        table += createInputRow(dummyPath, newData, level);
        table += '</tbody></table>';

        document.getElementById('modalBody').innerHTML = table;
        document.getElementById('modalSaveButton').onclick = () => saveNewTasks(parentPath, level);
        document.getElementById('modal-footer-left').innerHTML = `<button class="btn-info" onclick="addNewRowToModal('${parentPath}', '${level}')" title="Thêm dòng mới">+ Thêm dòng</button>`;
        document.getElementById('modalSaveButton').style.display = 'block';
        document.getElementById('modalDeleteButton').style.display = 'none';
				enableArrowKeyNavigation('dataModal');
		document.getElementById('dataModal').style.display = 'block';
        document.querySelector("#dataModal .modal-table tbody tr input[data-field='noiDung']").focus();
    };
    // === Bắt đầu hàm cho nút sửa công việc đã thực hiện ===
   window.openExecutionEdit = function(timestampKey) {
    if (!isAuthenticated) return showAuthError();
    const modal = document.getElementById('dataModal');
    
    // === SỬA LỖI: Cập nhật logic flattening cho cấu trúc 3 cấp ===
    const timestampGroup = executionGroups.get(timestampKey); // Map<grandchildPath, Map<leafPath, exec[]>>
    const group = Object.values(timestampGroup).flatMap(grandchildGroup => 
        Object.values(grandchildGroup).flat()
    );
    // === KẾT THÚC SỬA LỖI ===

    const firstExec = group[0];
    const title = `Sửa lần thực hiện ngày ${firstExec.ngayThucHien}`;
    document.getElementById('modalTitle').innerHTML = `<h2>${title}</h2>`;

    const headers = [
        {text: 'TT', width: '5%'},
        'Nội dung công việc',
        {text: 'Số lượng', width: '12%'},
        {text: 'Đơn giá', width: '15%'},
        {text: 'Thành tiền', width: '18%'}
    ];
    let table = createModalTable(headers);

    group.forEach((exec, index) => {
        table += `<tr data-exec-path="${exec.path}">
            <td><input type="text" value="${index + 1}" disabled></td>
            <td><input type="text" value="${exec.noiDung}" disabled></td>
            <td><input type="number" value="${exec.dvt}" data-field="dvt" oninput="calculateThanhTien(this)" onfocus="this.select()"></td>
            <td><input type="number" value="${exec.donGia}" data-field="donGia" oninput="calculateThanhTien(this)" onfocus="this.select()"></td>
            <td><input type="text" value="${formatNumber(exec.thanhTien)}" data-field="thanhTien" disabled></td>
        </tr>`;
    });

    table += '</tbody></table>';
    document.getElementById('modalBody').innerHTML = table;

    document.getElementById('modalSaveButton').onclick = saveExecutionEdits;
    document.getElementById('modalSaveButton').style.display = 'block';

    const keyParam = typeof timestampKey === 'number' ? timestampKey : `'${timestampKey}'`;

    document.getElementById('modal-footer-left').innerHTML = `
        <button class="btn-danger" onclick="handleDeleteExecution(${keyParam})">Xóa lần thực hiện này</button>
        <button class="btn-info" onclick="uploadPdfForExecution(${keyParam})">Tải lên Hồ sơ</button>
    `;

    document.getElementById('modalDeleteButton').style.display = 'none';
			enableArrowKeyNavigation('dataModal');
    modal.style.display = 'block';
};
// === KẾT THÚC hàm cho nút sửa ===

   window.uploadPdfForExecution = async function(timestampKey) { // Thêm async
        if (!isAuthenticated) return showAuthError();

        // === [FIX QUAN TRỌNG]: Kiểm tra và yêu cầu đăng nhập Google trước ===
        try {
            statusDiv.className = '';
            statusDiv.innerText = 'Đang kiểm tra kết nối Google Drive...';
            // Gọi hàm requestGoogleAuth để đảm bảo đã có token
            await requestGoogleAuth();
            statusDiv.innerText = ''; 
        } catch (error) {
            console.error("Lỗi xác thực Google:", error);
            // Lỗi đã được hiển thị trong requestGoogleAuth
            return; 
        }
        // =====================================================================

        document.getElementById('uploadPdfModalTitle').textContent = 'Tải lên Hồ sơ PDF';
        
        // Gán sự kiện cho nút "Tải Lên" trong modal, truyền timestampKey vào
        document.getElementById('uploadPdfButton').onclick = () => performPdfUpload(timestampKey);
        
        document.getElementById('pdf_file_input').value = '';
        document.getElementById('uploadPdfModal').style.display = 'block';
    };

    /**
     * Hàm xử lý Checkbox "Chọn tất cả" ở header bảng
     */
    window.toggleAllCheckboxes = function(headerCheckbox) {
        const isChecked = headerCheckbox.checked;
        const allCheckboxes = document.querySelectorAll('#taskListBody input[type="checkbox"]');
        
        // 1. Reset dữ liệu đã chọn để nạp lại từ đầu (tránh trùng lặp hoặc sót)
        if (!isChecked) {
            selectedTasks.clear();
            selectedJustifications.clear();
        }

        allCheckboxes.forEach(cb => {
            // Cập nhật trạng thái hiển thị
            cb.checked = isChecked;
            cb.indeterminate = false; // Quan trọng: Xóa trạng thái "bán phần" nếu có

            // Cập nhật dữ liệu vào Set
            const path = cb.dataset.path;
            if (isChecked) {
                if (cb.classList.contains('justification-checkbox')) {
                    selectedJustifications.add(path);
                } else {
                    selectedTasks.add(path);
                }
            }
        });

        updateButtonStates();
    };

    /**
     * Hàm Wrapper: Đảm bảo tính tương thích với HTML cũ
     * (Vì trong HTML có chỗ gọi toggleChildrenCheckboxes, có chỗ gọi toggleSelection)
     */
    window.toggleChildrenCheckboxes = function(parentCheckbox) {
        // Chuyển tiếp sang logic mới ở toggleSelection
        window.toggleSelection(parentCheckbox);
    };

    
   /**
     * Hàm xử lý chính: Chọn/Bỏ chọn task 
     * Hỗ trợ lan truyền xuống (Down) và cập nhật ngược lên (Up)
     */
    window.toggleSelection = function(checkbox, isFromCascade = false) {
        const path = checkbox.dataset.path;
        const isChecked = checkbox.checked;
        const isJustification = checkbox.classList.contains('justification-checkbox');

        // 1. Cập nhật vào danh sách đã chọn (Set)
        if (isChecked) {
            if (isJustification) selectedJustifications.add(path);
            else selectedTasks.add(path);
        } else {
            if (isJustification) selectedJustifications.delete(path);
            else selectedTasks.delete(path);
        }

        // 2. LAN TRUYỀN XUỐNG (Cascade Down): Chọn tất cả con cháu
        // Chỉ chạy khi người dùng click trực tiếp (isFromCascade = false)
        if (!isFromCascade) {
            const descendantCheckboxes = document.querySelectorAll(`input[type="checkbox"][data-path^="${path}/"]`);
            descendantCheckboxes.forEach(childCb => {
                if (childCb !== checkbox) {
                    childCb.checked = isChecked;
                    childCb.indeterminate = false; // Con cháu thì phải rõ ràng (Chọn/Không)
                    window.toggleSelection(childCb, true); // Gọi đệ quy nhẹ để cập nhật Set
                }
            });
        }

        // 3. CẬP NHẬT NGƯỢC LÊN (Bubble Up): Kiểm tra trạng thái cha/ông
        // Luôn chạy để đảm bảo tính nhất quán visual
        updateAncestors(path);

        // 4. Cập nhật nút bấm
        if (!isFromCascade) {
            updateButtonStates();
        }
    };

    /**
     * Hàm đệ quy cập nhật trạng thái visual của các cấp cha (Indeterminate)
     */
    function updateAncestors(currentPath) {
        // Tìm đường dẫn cha bằng cách cắt bỏ 2 phần cuối (VD: .../children/ID)
        // Regex: Tìm pattern "/[collection]/[id]" ở cuối chuỗi và loại bỏ nó
        const parentPathMatch = currentPath.match(/^(.*)\/[^\/]+\/[^\/]+$/);
        
        if (!parentPathMatch) return; // Đã đến root hoặc không tìm thấy cha

        const parentPath = parentPathMatch[1];
        const parentCheckbox = document.querySelector(`input[type="checkbox"][data-path="${parentPath}"]`);

        if (parentCheckbox) {
            // Tìm tất cả con TRỰC TIẾP của cha này để kiểm tra trạng thái
            // Logic: Tìm các checkbox có path bắt đầu bằng "parentPath/" 
            // Lưu ý: Cách này tìm cả cháu chắt, nhưng ta chỉ cần kiểm tra tổng thể
            const allDescendants = document.querySelectorAll(`input[type="checkbox"][data-path^="${parentPath}/"]`);
            
            let checkedCount = 0;
            let indeterminateCount = 0;
            const totalCount = allDescendants.length;

            allDescendants.forEach(cb => {
                if (cb.checked) checkedCount++;
                if (cb.indeterminate) indeterminateCount++;
            });

            if (checkedCount === totalCount && totalCount > 0) {
                // Tất cả con đều được chọn -> Cha chọn
                parentCheckbox.checked = true;
                parentCheckbox.indeterminate = false;
                // Cập nhật Set cho cha
                if(parentCheckbox.classList.contains('justification-checkbox')) selectedJustifications.add(parentPath);
                else selectedTasks.add(parentPath);

            } else if (checkedCount === 0 && indeterminateCount === 0) {
                // Không con nào được chọn -> Cha bỏ chọn
                parentCheckbox.checked = false;
                parentCheckbox.indeterminate = false;
                // Xóa Set cho cha
                if(parentCheckbox.classList.contains('justification-checkbox')) selectedJustifications.delete(parentPath);
                else selectedTasks.delete(parentPath);

            } else {
                // Trạng thái hỗn hợp -> Cha Indeterminate (dấu gạch ngang)
                // Lưu ý: Indeterminate về mặt logic dữ liệu thường coi là chưa chọn (checked = false)
                // hoặc tùy nghiệp vụ. Ở đây ta để checked = false để khi click vào nó sẽ thành true (chọn hết).
                parentCheckbox.checked = false;
                parentCheckbox.indeterminate = true;
                // Xóa Set cho cha (vì chưa chọn trọn vẹn)
                if(parentCheckbox.classList.contains('justification-checkbox')) selectedJustifications.delete(parentPath);
                else selectedTasks.delete(parentPath);
            }

            // Tiếp tục đệ quy lên cấp ông/cố
            updateAncestors(parentPath);
        }
    }

    window.scrollToTop = function() {
        window.scrollTo({ top: 0, behavior: 'smooth' });
    };

   // === HÀM XUẤT EXCEL THUẦN ===

// === BẮT ĐẦU KHỐI MÃ MỚI ĐỂ XUẤT EXCEL CÓ CÔNG THỨC ===

/**
 * HÀM PHỤ TRỢ 1: (ĐÃ SỬA LỖI)
 * Đệ quy "khô" qua toàn bộ dữ liệu để tìm số lần thực hiện tối đa.
 * Cần thiết để biết tạo bao nhiêu cột header.
 */
function findMaxExecutions(nodes) {
    let maxExec = 0;
    if (!nodes) return 0;

    const nodesArray = Array.isArray(nodes) ? nodes : Object.values(nodes);

    for (const node of nodesArray) {
        // === SỬA LỖI: THÊM KIỂM TRA "if (node)" ===
        // Bỏ qua các entry bị null hoặc undefined trong CSDL
        if (node) { 
            if (node.executions) {
                const execCount = Object.keys(node.executions).length;
                if (execCount > maxExec) maxExec = execCount;
            }
            
            // Đệ quy xuống các cấp con
            let childMax = 0;
            if (node.children) childMax = Math.max(childMax, findMaxExecutions(node.children));
            if (node.grandchildren) childMax = Math.max(childMax, findMaxExecutions(node.grandchildren));
            if (node.greatGrandchildren) childMax = Math.max(childMax, findMaxExecutions(node.greatGrandchildren));
            if (node.greatGreatGrandchildren) childMax = Math.max(childMax, findMaxExecutions(node.greatGreatGrandchildren));
            
            if (childMax > maxExec) maxExec = childMax;
        }
        // === KẾT THÚC SỬA LỖI ===
    }
    return maxExec;
}


/**
 * HÀM PHỤ TRỢ 2: (ĐÃ CẬP NHẬT: Thêm 'v:' cho các ô công thức)
 * Xử lý đệ quy các giải trình (Justifications) và ghi vào worksheet.
 * Trả về mảng các HÀNG (row index) của các giải trình con để SUM.
 */

function processJustificationForExcel(justificationNode, parentTT, level, ctx) {
    const r = ctx.currentRow;
    
    // === [SỬA LỖI]: Đưa khai báo justStyle lên đầu hàm ===
    const justStyle = { 
        font: { color: { rgb: "FF0000" }, italic: true },
        numFmt: ctx.moneyFormat 
    };
    // ====================================================

    const isParentJustification = justificationNode.hasSubJustifications === true && justificationNode.subJustifications;
    let subJustificationRows = [];

    // Ghi dữ liệu giải trình
    ctx.ws[ctx.COLS.TT + r] = { t: 's', v: convertTTForDisplay(justificationNode.tt) };
    ctx.ws[ctx.COLS.NOI_DUNG + r] = { t: 's', v: justificationNode.noiDung || '' };
    
    // Bây giờ dòng này sẽ chạy đúng vì justStyle đã được khai báo
    ctx.ws[ctx.COLS.TAG_NAME + r] = { t: 's', v: '', s: justStyle };
    
    if (isParentJustification) {
        const subJustifications = Object.keys(justificationNode.subJustifications)
            .map(subId => ({ id: subId, ...justificationNode.subJustifications[subId] }))
            .sort((a,b) => a.tt.localeCompare(b.tt));
        
        for (const subJustData of subJustifications) {
            ctx.currentRow++;
            const subJustChildRows = processJustificationForExcel(subJustData, justificationNode.tt, level + 1, ctx);
            subJustificationRows.push(...subJustChildRows);
        }
    }

    ctx.ws[ctx.COLS.DON_VI + r] = { t: 's', v: justificationNode.donVi || '', s: justStyle };
    
    if (!isParentJustification) {
        ctx.ws[ctx.COLS.SO_LUONG + r] = { t: 'n', v: justificationNode.soLuong || 0, s: justStyle };
        if (activeExportType === 'full' && ctx.COLS.DON_GIA) {
            ctx.ws[ctx.COLS.DON_GIA + r] = { t: 'n', v: justificationNode.donGia || 0, s: justStyle };
        }
    }
    
    // --- GHI CHI PHÍ ---
    const cellValue = justificationNode.chiPhi || 0; 

    if (isParentJustification && subJustificationRows.length > 0) {
        const sumCells = subJustificationRows.map(childR => ctx.COLS.CHI_PHI + childR).join(',');
        ctx.ws[ctx.COLS.CHI_PHI + r] = { t: 'n', v: cellValue, f: `SUM(${sumCells})`, s: justStyle };

    } else if (!isParentJustification && activeExportType === 'full' && ctx.COLS.DON_GIA) {
        const soLuongAddr = ctx.COLS.SO_LUONG + r;
        const donGiaAddr = ctx.COLS.DON_GIA + r; 
        ctx.ws[ctx.COLS.CHI_PHI + r] = { t: 'n', v: cellValue, f: `${soLuongAddr}*${donGiaAddr}`, s: justStyle };

    } else {
        ctx.ws[ctx.COLS.CHI_PHI + r] = { t: 'n', v: cellValue, s: justStyle };
    }
    
    // --- MỚI: GHI CỘT GHI CHÚ CHO GIẢI TRÌNH ---
    if (activeExportType === 'full' && ctx.COLS.GHI_CHU) {
        ctx.ws[ctx.COLS.GHI_CHU + r] = { t: 's', v: justificationNode.ghiChu || '', s: justStyle };
    }
    // -------------------------------------------

    // Thêm style cho các cột khác
    ctx.ws[ctx.COLS.TT + r].s = justStyle;
    ctx.ws[ctx.COLS.NOI_DUNG + r].s = justStyle;
    if (ctx.ws[ctx.COLS.SO_LUONG + r]) ctx.ws[ctx.COLS.SO_LUONG + r].s = justStyle;
    if (activeExportType === 'full' && ctx.COLS.DON_GIA && ctx.ws[ctx.COLS.DON_GIA + r]) {
        ctx.ws[ctx.COLS.DON_GIA + r].s = justStyle;
    }
    
    return [r];
}



/**
 * HÀM PHỤ TRỢ 3: (ĐÃ CẬP NHẬT: Thêm 'v:' cho các ô công thức)
 * Xử lý đệ quy các mục CÔNG VIỆC và ghi vào worksheet.
 * Trả về mảng các HÀNG (row index) của các mục con để SUM.
 */
function processNodeForExcel(node, path, level, ctx) {
    const r = ctx.currentRow;
    let childRows = [];
    let justificationRows = [];
    
    const hasL4Children = node.greatGrandchildren && Object.keys(node.greatGrandchildren).length > 0;
    const hasL3Children = node.grandchildren && Object.keys(node.grandchildren).length > 0;
    const hasL2Children = node.children && Object.keys(node.children).length > 0;
    let isContainer = (node.hasChildren === true) || hasL2Children || hasL3Children || hasL4Children;

    if (node.children) {
        const children = Object.keys(node.children).map(id => ({ id, ...node.children[id] })).sort(childSort);
        for (const childData of children) {
            ctx.currentRow++;
            childRows.push(...processNodeForExcel(childData, `${path}/children/${childData.id}`, level + 1, ctx));
        }
    }
    if (node.grandchildren) {
        const grandchildren = Object.keys(node.grandchildren).map(id => ({ id, ...node.grandchildren[id] })).sort((a,b)=>parseInt(a.id,10)-parseInt(b.id,10));
        for (const grandchildData of grandchildren) {
            ctx.currentRow++;
            childRows.push(...processNodeForExcel(grandchildData, `${path}/grandchildren/${grandchildData.id}`, level + 2, ctx));
        }
    }
    if (node.greatGrandchildren) {
        const greatGrandchildren = Object.keys(node.greatGrandchildren).map(id => ({ id, ...node.greatGrandchildren[id]})).sort(numericSort);
        for (const greatGrandchildData of greatGrandchildren) {
            ctx.currentRow++;
            childRows.push(...processNodeForExcel(greatGrandchildData, `${path}/greatGrandchildren/${greatGrandchildData.id}`, level + 3, ctx));
        }
    }
    
    if (!isContainer && node.justifications && ctx.includeJustifications) {
         const justifications = Object.keys(node.justifications)
            .map(id => ({ id, ...node.justifications[id] }))
            .sort((a,b) => (a.tt || '').localeCompare((b.tt || ''), 'en', { numeric: true }));
        for (const justData of justifications) {
            ctx.currentRow++;
            justificationRows.push(...processJustificationForExcel(justData, node.tt, level + 5, ctx));
        }
    }

    // --- GHI DỮ LIỆU CƠ BẢN ---
    ctx.ws[ctx.COLS.TT + r] = { t: 's', v: convertTTForDisplay(node.tt), z: '@' };
    ctx.ws[ctx.COLS.NOI_DUNG + r] = { t: 's', v: node.noiDung || '' };
	ctx.ws[ctx.COLS.TAG_NAME + r] = { t: 's', v: node.tagName || '' };
    ctx.ws[ctx.COLS.DV_THUCHIEN + r] = { t: 's', v: node.dvThucHien || '' };
    ctx.ws[ctx.COLS.DON_VI + r] = { t: 's', v: node.donVi || '' };
    ctx.ws[ctx.COLS.TAN_SUAT + r] = { t: 'n', v: node.tanSuatTH === undefined || node.tanSuatTH === null ? '' : node.tanSuatTH };
    ctx.ws[ctx.COLS.NAM_PHAN_BO + r] = { t: 'n', v: node.namPhanBo || '' };
    ctx.ws[ctx.COLS.CAP_DO + r] = { t: 's', v: node.capDo || '' };
    
    // --- GHI CỘT MỚI (Giá trị sẽ được tính toán hoặc ghi đè bởi công thức ở dưới) ---
    // Mặc định ghi 0 hoặc giá trị có sẵn
    ctx.ws[ctx.COLS.CP_CAP_1 + r] = { t: 'n', v: node.cpCap1 || 0, s: { numFmt: ctx.moneyFormat } }; 
    // ------------------------------------------------------------------------------

    let tgBatDauValue = node.tgBatDau || '';
let tgBatDauType = 's'; // Mặc định là string

if (level === 0 && ctx.summaryData && ctx.summaryData[node.id]) {
    // Nếu là cấp 1, lấy từ summary và ép kiểu số
    tgBatDauValue = ctx.summaryData[node.id].totalExecutedLeafNodesCap1 || 0;
    tgBatDauType = 'n';
}

ctx.ws[ctx.COLS.TG_BATDAU + r] = { t: tgBatDauType, v: tgBatDauValue };

    ctx.ws[ctx.COLS.TG_HOANTHANH + r] = { t: 's', v: node.tgHoanThanh || '' };
    ctx.ws[ctx.COLS.GHI_CHU + r] = { t: 's', v: node.ghiChu || '' };

    if (level === 0 && ctx.summaryData && ctx.summaryData[node.id]) {
        const totalLeafNodesCap1 = ctx.summaryData[node.id].totalLeafNodesCap1 || 0;
        ctx.ws[ctx.COLS.SO_LUONG + r] = { t: 'n', v: totalLeafNodesCap1, s: { numFmt: ctx.moneyFormat } };
    } else if (!isContainer) {
        ctx.ws[ctx.COLS.SO_LUONG + r] = { t: 'n', v: node.soLuong || '', s: { numFmt: ctx.moneyFormat } };
    } else {
        ctx.ws[ctx.COLS.SO_LUONG + r] = { t: 'n', v: 0, s: { numFmt: ctx.moneyFormat } };
    }
    ctx.ws[ctx.COLS.DON_GIA + r] = { t: 'n', v: !isContainer ? (node.donGia || 0) : 0, s: { numFmt: ctx.moneyFormat } };

    // --- XỬ LÝ CÔNG THỨC ---
    const sumFields = [
        { key: 'chiPhi', col: ctx.COLS.CHI_PHI },
        { key: 'chiPhiThucHien', col: ctx.COLS.CHI_PHI_THUCHIEN },
        { key: 'chiPhiPhanBo', col: ctx.COLS.CP_PHAN_BO },
        // === THÊM CP_CAP_1 VÀO DANH SÁCH TÍNH TỔNG ===
        { key: 'cpCap1', col: ctx.COLS.CP_CAP_1 }
    ];
    
    sumFields.unshift({ key: 'khNamTruoc', col: ctx.COLS.KH_NAM_TRUOC });
    sumFields.unshift({ key: 'thucHienNamTruoc', col: ctx.COLS.TH_NAM_TRUOC });

    for (const field of sumFields) {
        const cellAddress = field.col + r;
        const cellValue = node[field.key] || 0; 

        if (isContainer && childRows.length > 0) {
            // Nút CHA: SUM con
            const sumCells = childRows.map(childR => field.col + childR).join(',');
            ctx.ws[cellAddress] = { t: 'n', v: cellValue, f: `SUM(${sumCells})`, s: { numFmt: ctx.moneyFormat } };
        
        } else if (!isContainer && field.key === 'chiPhiPhanBo') {
            // Nút LÁ: CP Phân Bổ = Chi phí / Năm
            const chiPhiAddr = ctx.COLS.CHI_PHI + r;
            const namPbAddr = ctx.COLS.NAM_PHAN_BO + r;
            if (node.namPhanBo && node.namPhanBo > 0) {
                 ctx.ws[cellAddress] = { t: 'n', v: cellValue, f: `IF(${namPbAddr}>0, ${chiPhiAddr}/${namPbAddr}, 0)`, s: { numFmt: ctx.moneyFormat } };
            } else {
                ctx.ws[cellAddress] = { t: 'n', v: 0, s: { numFmt: ctx.moneyFormat } };
            }

        } else if (!isContainer && field.key === 'cpCap1') {
            // === NÚT LÁ: CP Cấp 1 = Chi phí * Tỷ lệ ===
            // Tỷ lệ phụ thuộc vào Cấp độ (6t -> 0.5, 1 -> 1, else -> 0)
            const chiPhiAddr = ctx.COLS.CHI_PHI + r;
            const capDoStr = String(node.capDo || '').trim().toLowerCase();
            
            if (capDoStr === '1' || capDoStr === '') {
                ctx.ws[cellAddress] = { t: 'n', v: cellValue, f: `${chiPhiAddr}`, s: { numFmt: ctx.moneyFormat } };
            } else if (capDoStr === '6t') {
                ctx.ws[cellAddress] = { t: 'n', v: cellValue, f: `${chiPhiAddr}*0.5`, s: { numFmt: ctx.moneyFormat } };
            } else {
                ctx.ws[cellAddress] = { t: 'n', v: 0, s: { numFmt: ctx.moneyFormat } };
            }

        } else if (!isContainer && field.key === 'chiPhi' && justificationRows.length > 0) {
            // Nút LÁ có giải trình: SUM giải trình
            const sumCells = justificationRows.map(justR => ctx.COLS.CHI_PHI + justR).join(',');
            ctx.ws[cellAddress] = { t: 'n', v: cellValue, f: `SUM(${sumCells})`, s: { numFmt: ctx.moneyFormat } };

        } else {
            // Giá trị thường
            ctx.ws[cellAddress] = { t: 'n', v: cellValue, s: { numFmt: ctx.moneyFormat } };
        }
    }
    
    const chiPhiAddr = ctx.COLS.CHI_PHI + r;
    const chiPhiThucHienAddr = ctx.COLS.CHI_PHI_THUCHIEN + r;
    const keHoachConLaiValue = (node.chiPhi || 0) - (node.chiPhiThucHien || 0);
    
    ctx.ws[ctx.COLS.KH_CON_LAI + r] = { 
        t: 'n', 
        v: keHoachConLaiValue,
        f: `${chiPhiAddr}-${chiPhiThucHienAddr}`,
        s: { numFmt: ctx.moneyFormat } 
    };

    if (node.executions && !isContainer) {
        for (const execId in node.executions) {
            const exec = node.executions[execId];
            const lanThucHien = exec.lanThucHien !== undefined ? parseInt(exec.lanThucHien, 10) : parseInt(execId, 10);
            if (isNaN(lanThucHien) || lanThucHien <= 0) continue;

            const colMap = ctx.execHeaderMap[lanThucHien];
            if (!colMap) continue;

            if (colMap.ngayTh) ctx.ws[colMap.ngayTh + r] = { t: 's', v: exec.ngayThucHien || '', s: { numFmt: '@' } };
            if (colMap.soLuong) ctx.ws[colMap.soLuong + r] = { t: 'n', v: exec.dvt || 0, s: { numFmt: ctx.moneyFormat } };
            if (colMap.donGia) ctx.ws[colMap.donGia + r] = { t: 'n', v: exec.donGia || 0, s: { numFmt: ctx.moneyFormat } };
            if (colMap.thanhTien) ctx.ws[colMap.thanhTien + r] = { t: 'n', v: exec.thanhTien || 0, s: { numFmt: ctx.moneyFormat } };
            
            if (activeExportType === 'full') {
                 if (colMap.timestamp) ctx.ws[colMap.timestamp + r] = { t: 's', v: String(exec.timestamp || ''), s: { numFmt: '@' } };
                 if (colMap.hoSoLink) ctx.ws[colMap.hoSoLink + r] = { t: 's', v: exec.hoSoLink || '' };
            }
        }
    }
    
    return [r];
}

/**
 * HÀM LÕI MỚI (Helper function)
 * Tách logic tạo worksheet ra khỏi hàm export
 * Hàm này sẽ được cả exportPlainDataExcel và exportToClipboard sử dụng
 */
async function generateWorksheetWithFormulas(includeJustifications) {
    const parentQuery = ref(db, getParentCollectionName());
    const parentSnapshot = await get(parentQuery);
    if (!parentSnapshot.exists()) { throw new Error('Không có dữ liệu để xuất.'); }
    const parentsData = parentSnapshot.val();

    const summaryRef = ref(db, `summary_data/${currentYear}`);
    const summarySnap = await get(summaryRef);
    const summaryData = summarySnap.exists() ? summarySnap.val() : {};
    const maxLanThucHien = findMaxExecutions(parentsData);

    // --- THÊM CỘT 'CP Cấp 1' ---
    const baseHeaders = [
        'TT', 'Đầu việc/Dự án', 'Tag Name', 'ĐV th.hiện', 'KH năm trước', 'Thực hiện năm trước', 
        'Tần suất TH', 'Đ.vị tính', 'Số lượng', 'Đơn giá (GT)', 'Chi phí KH', 
        'Chi phí thực hiện', 'Kế hoạch còn lại', 
        'Năm phân bổ', 'CP phân bổ', 
        'Cấp độ', 'CP Cấp 1', 'Thời điểm TH', 'TG hoàn thành', 'Ghi chú'
    ];
    // ---------------------------

    const headersToUse = baseHeaders;
    const executionHeaders = [];
    const execHeaderMap = {};
    let currentColIndex = baseHeaders.length; 
    
    for (let i = 1; i <= maxLanThucHien; i++) {
        const colMap = {};
        colMap.ngayTh = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Ngày TH (${i})`); currentColIndex++;
        colMap.soLuong = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Số lượng (${i})`); currentColIndex++;
        colMap.donGia = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Đơn giá (${i})`); currentColIndex++;
        colMap.thanhTien = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Thành tiền (${i})`); currentColIndex++;
        colMap.timestamp = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Timestamp (${i})`); currentColIndex++;
        colMap.hoSoLink = XLSX.utils.encode_col(currentColIndex); executionHeaders.push(`Hồ sơ Link (${i})`); currentColIndex++;
        execHeaderMap[i] = colMap;
    }

    const finalHeaders = [...baseHeaders, ...executionHeaders];
    const COLS = {};
    
    // --- THÊM MAPPING CHO CỘT MỚI ---
    const colNameMap = {
        'TT': 'TT', 'Đầu việc/Dự án': 'NOI_DUNG',
		'Tag Name': 'TAG_NAME',
		'ĐV th.hiện': 'DV_THUCHIEN',
        'KH năm trước': 'KH_NAM_TRUOC', 'Thực hiện năm trước': 'TH_NAM_TRUOC',
        'Tần suất TH': 'TAN_SUAT', 'Đ.vị tính': 'DON_VI', 'Số lượng': 'SO_LUONG',
        'Đơn giá (GT)': 'DON_GIA', 'Chi phí KH': 'CHI_PHI',
        'Chi phí thực hiện': 'CHI_PHI_THUCHIEN', 'Kế hoạch còn lại': 'KH_CON_LAI',
        'Năm phân bổ': 'NAM_PHAN_BO', 'CP phân bổ': 'CP_PHAN_BO',   
        'Cấp độ': 'CAP_DO', 'CP Cấp 1': 'CP_CAP_1', 
        'Thời điểm TH': 'TG_BATDAU', 'TG hoàn thành': 'TG_HOANTHANH', 'Ghi chú': 'GHI_CHU'
    };
    
    finalHeaders.forEach((h, i) => {
        const key = colNameMap[h];
        if (key) COLS[key] = XLSX.utils.encode_col(i);
    });

    const wb = XLSX.utils.book_new();
    const ws = {}; 
    const moneyFormat = '#,##0';

    const ctx = { ws, currentRow: 1, COLS, execHeaderMap, moneyFormat, summaryData, includeJustifications };

    finalHeaders.forEach((h, i) => {
        const cellAddress = XLSX.utils.encode_cell({ c: i, r: 0 });
        ws[cellAddress] = { t: 's', v: h };
    });
    
    statusDiv.innerText = 'Đang xử lý dữ liệu và tạo công thức...';
    
    const parents = Object.keys(parentsData).map(id => ({ id, ...parentsData[id] })).sort((a,b) => a.id.localeCompare(b.id));
    ctx.currentRow = 2; 

    for (const p of parents) {
        processNodeForExcel(p, `${getParentCollectionName()}/${p.id}`, 0, ctx);
        ctx.currentRow++; 
    }
    
    const range = { s: { c: 0, r: 0 }, e: { c: finalHeaders.length - 1, r: ctx.currentRow - 1 } };
    ws['!ref'] = XLSX.utils.encode_range(range);

    return { wb, ws, finalHeaders };
}

/**
 * HÀM CẬP NHẬT: (Nút 1)
 * Xuất Excel với công thức tính toán (Tải file).
 */
window.exportPlainDataExcel = async function() {
    try {
        statusDiv.className = 'success';
        statusDiv.innerText = 'Đang chuẩn bị dữ liệu file Excel...';
        closeAllModals();

        // QUAN TRỌNG: Quyết định có xuất giải trình hay không dựa trên nút bấm ban đầu
        // Nút 1 (Simplified) -> false. Nút 2 (Full) -> true.
        const includeJustifications = (activeExportType === 'full');

        // Gọi hàm tạo dữ liệu (Hàm này đã được cấu hình để luôn xuất FULL CỘT)
        const { wb, ws } = await generateWorksheetWithFormulas(includeJustifications);
        
        // Đặt tên file khác nhau để dễ phân biệt
        const fileName = includeJustifications ? 
            `BDSC_${currentYear}_Full.xlsx` : 
            `BDSC_${currentYear}_NoJustification.xlsx`;

        XLSX.utils.book_append_sheet(wb, ws, 'Data');
        XLSX.writeFile(wb, fileName);
        
        statusDiv.innerText = 'Xuất file Excel (.xlsx) thành công!';

    } catch (error) {
        console.error("Lỗi khi xuất Excel:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi khi xuất file: ${error.message}`;
    }
};

/**
 * HÀM MỚI: (Nút 3 - Sửa lỗi triệt để bằng cách TỰ TẠO TSV)
 * Xuất dữ liệu vào Clipboard.
 */
window.exportToClipboard = async function() {
    try {
        statusDiv.className = 'success';
        statusDiv.innerText = 'Đang chuẩn bị dữ liệu cho clipboard...';
        closeAllModals();

        // Kiểm tra nút bấm ban đầu để quyết định có xuất giải trình không
        // Nút 1 (Simplified) -> false. Nút 2 (Full) -> true.
        const includeJustifications = (activeExportType === 'full');

        const { ws } = await generateWorksheetWithFormulas(includeJustifications);

        statusDiv.innerText = 'Đang chuyển đổi dữ liệu...';

        const tsvData = [];
        const range = XLSX.utils.decode_range(ws['!ref']);
        
        for (let R = range.s.r; R <= range.e.r; ++R) {
            const row = [];
            for (let C = range.s.c; C <= range.e.c; ++C) {
                const cellAddress = XLSX.utils.encode_cell({ r: R, c: C });
                const cell = ws[cellAddress];

                if (!cell) {
                    row.push(""); 
                    continue;
                }

                // Ưu tiên công thức
                if (cell.f) {
                    row.push(`=${cell.f}`);
                }
                else if (cell.v !== undefined && cell.v !== null) {
                    let value = cell.v;
                    
                    // --- SỬA LỖI HIỂN THỊ CLIPBOARD (CẬP NHẬT MỚI) ---
                    // Nếu là cột TT (C=0), áp dụng công thức ="giá_trị" cho TẤT CẢ các mã
                    // để bảo toàn định dạng (VD: 1.10, 1.20, -1.10, A.1)
                    if (C === 0) {
                         let strVal = String(value).trim();
                         // Chỉ áp dụng nếu không phải là tiêu đề "TT" và không phải ô trống
                         if (strVal !== 'TT' && strVal !== '') {
                             value = `="${strVal}"`;
                         }
                    }
                    // --------------------------------------------------

                    if (cell.t === 's' || typeof value === 'string') {
                        let str = String(value);
                        // Xử lý ký tự đặc biệt trong TSV (Tab, Quote, Newline)
                        if (str.includes('"') || str.includes('\t') || str.includes('\n')) {
                            str = `"${str.replace(/"/g, '""')}"`;
                        }
                        row.push(str);
                    } else {
                        row.push(String(value));
                    }
                } 
                else {
                    row.push(""); 
                }
            }
            tsvData.push(row.join('\t')); 
        }
        
        const clipboardString = tsvData.join('\n'); 

        if (!navigator.clipboard) {
            throw new Error('Trình duyệt không hỗ trợ Clipboard API.');
        }

        await navigator.clipboard.writeText(clipboardString); 
        
        statusDiv.className = 'success';
        statusDiv.innerText = includeJustifications 
            ? 'Đã sao chép dữ liệu (Kèm giải trình) vào Clipboard!'
            : 'Đã sao chép dữ liệu (Không giải trình) vào Clipboard!';

    } catch (error) {
        console.error("Lỗi khi sao chép vào Clipboard:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi sao chép: ${error.message}`;
    }
};

// === HÀM exportFormattedExcel_HTML ĐẦY ĐỦ (ĐÃ SỬA LỖI MÀU & TIMESTAMP) ===
// === HÀM exportFormattedExcel_HTML ĐẦY ĐỦ (ĐÃ SỬA THỨ TỰ CỘT) ===

// === HÀM XUẤT EXCEL (CẬP NHẬT: EXCEL 1 ĐỦ CỘT NHƯNG KHÔNG GIẢI TRÌNH) ===
window.exportFormattedExcel_HTML = async function() {
    try {
        statusDiv.className = 'success';
        statusDiv.innerText = 'Đang chuẩn bị dữ liệu...';
        closeAllModals();

        const parentQuery = ref(db, getParentCollectionName());
        const parentSnapshot = await get(parentQuery);
        if (!parentSnapshot.exists()) {
            alert('Không có dữ liệu để xuất.');
            statusDiv.innerText = '';
            return;
        }
        const parentsData = parentSnapshot.val();
        
        // === LẤY DỮ LIỆU SUMMARY ===
        const summaryRef = ref(db, `summary_data/${currentYear}`);
        const summarySnap = await get(summaryRef);
        const summaryData = summarySnap.exists() ? summarySnap.val() : {};
        // ==========================

        const allRows = [];
        let maxLanThucHien = 0;

        const processNode = (node, path, parentTT = '', level = 0) => {
            if (node.tt) {
                // Xử lý số lượng cấp 1
                let soLuongVal = node.soLuong;
			let tgBatDauVal = node.tgBatDau;	
                if (level === 0 && summaryData[node.id]) {
                    soLuongVal = summaryData[node.id].totalLeafNodesCap1 || 0;
					tgBatDauVal = summaryData[node.id].totalExecutedLeafNodesCap1 || 0;
                }

                const row = {
                    'TT': convertTTForDisplay(node.tt),
                    'Đầu việc/Dự án': node.noiDung || '',
					'Tag Name': node.tagName || '',
                    'ĐV th.hiện': node.dvThucHien || '',
                    'KH năm trước': node.khNamTruoc === 0 ? 0 : (node.khNamTruoc || ''),
                    'Thực hiện năm trước': node.thucHienNamTruoc === 0 ? 0 : (node.thucHienNamTruoc || ''),
                    'Tần suất TH': node.tanSuatTH === undefined || node.tanSuatTH === null || node.tanSuatTH === '' ? '' : node.tanSuatTH,
                    'Đ.vị tính': node.donVi || '',
                    
                    // Sử dụng biến soLuongVal đã xử lý
                    'Số lượng': soLuongVal === 0 ? 0 : (soLuongVal || ''),
                    
                    'Đơn giá (GT)': node.donGia === 0 ? 0 : (node.donGia || ''),
                    'Chi phí KH': node.chiPhi === 0 ? 0 : (node.chiPhi || ''),
                    'Chi phí thực hiện': node.chiPhiThucHien === 0 ? 0 : (node.chiPhiThucHien || ''),
                    'Kế hoạch còn lại': node.keHoachConLai === 0 ? 0 : (node.keHoachConLai || ''),
                    'Năm phân bổ': node.namPhanBo || '',
                    'CP phân bổ': node.chiPhiPhanBo === 0 ? 0 : (node.chiPhiPhanBo || ''),
                    'Cấp độ': node.capDo || '',
                    'CP Cấp 1': node.cpCap1 === 0 ? 0 : (node.cpCap1 || ''), // Đã có từ yêu cầu trước
                    'Thời điểm TH': tgBatDauVal || '',
                    'TG hoàn thành': node.tgHoanThanh || '',
                    'Ghi chú': node.ghiChu || '',
                    level: level,
                    isJustification: false
                };

                if (node.executions) {
                    for (const execId in node.executions) {
                        const exec = node.executions[execId];
                        const lanThucHien = exec.lanThucHien !== undefined ? parseInt(exec.lanThucHien, 10) : parseInt(execId, 10);
                        if (!isNaN(lanThucHien)) {
                             row[`Ngày TH (${lanThucHien})`] = exec.ngayThucHien || '';
                             row[`Số lượng (${lanThucHien})`] = exec.dvt === 0 ? 0 : (exec.dvt || '');
                             row[`Đơn giá (${lanThucHien})`] = exec.donGia === 0 ? 0 : (exec.donGia || '');
                             row[`Thành tiền (${lanThucHien})`] = exec.thanhTien === 0 ? 0 : (exec.thanhTien || '');
                             if (activeExportType === 'full') {
                                 row[`Timestamp (${lanThucHien})`] = String(exec.timestamp || '');
                                 row[`Hồ sơ Link (${lanThucHien})`] = exec.hoSoLink || '';
                             }
                             if (lanThucHien > maxLanThucHien) {
                                 maxLanThucHien = lanThucHien;
                             }
                        }
                    }
                }
                allRows.push(row);
            }

            if (node.children) {
                const children = Object.keys(node.children).map(id => ({ id, ...node.children[id] })).sort(childSort);
                children.forEach(child => processNode(child, `${path}/children/${child.id}`, node.tt, level + 1));
            }
            if (node.grandchildren) {
                const grandchildren = Object.keys(node.grandchildren).map(id => ({ id, ...node.grandchildren[id] })).sort((a,b)=>parseInt(a.id,10)-parseInt(b.id,10));
                grandchildren.forEach(gc => processNode(gc, `${path}/grandchildren/${gc.id}`, node.tt, level + 2));
            }
            if (node.greatGrandchildren) {
                const greatGrandchildren = Object.keys(node.greatGrandchildren).map(id => ({ id, ...node.greatGrandchildren[id] })).sort(numericSort);
                greatGrandchildren.forEach(ggc => processNode(ggc, `${path}/greatGrandchildren/${ggc.id}`, node.tt, level + 3));
            }
            if (node.greatGreatGrandchildren) {
                const greatGreatGrandchildren = Object.keys(node.greatGreatGrandchildren).map(id => ({ id, ...node.greatGreatGrandchildren[id] })).sort(numericSort);
                greatGreatGrandchildren.forEach(gggc => processNode(gggc, `${path}/greatGreatGrandchildren/${gggc.id}`, node.tt, level + 4));
            }

            if (activeExportType === 'full' && node.justifications) {
                // --- SỬA LỖI SẮP XẾP TẠI ĐÂY ---
                // Sử dụng localeCompare với { numeric: true } trên trường tt
                const justifications = Object.keys(node.justifications)
                    .map(id => ({ id, ...node.justifications[id] }))
                    .sort((a, b) => (a.tt || '').localeCompare((b.tt || ''), 'en', { numeric: true }));
                // ------------------------------

                justifications.forEach(just => {
                    const justRow = {
                        'TT': convertTTForDisplay(just.tt),
                        'Đầu việc/Dự án': just.noiDung || '',
						'Tag Name': '',
                        'ĐV th.hiện': '', 'KH năm trước': '', 'Thực hiện năm trước': '', 'Tần suất TH': '',
                        'Đ.vị tính': just.donVi || '',
                        'Số lượng': just.soLuong === 0 ? 0 : (just.soLuong || ''),
                        'Đơn giá (GT)': just.donGia === 0 ? 0 : (just.donGia || ''),
                        'Chi phí KH': just.chiPhi === 0 ? 0 : (just.chiPhi || ''),
                        'Chi phí thực hiện': '', 'Kế hoạch còn lại': '', 
                        'Năm phân bổ': '', 'CP phân bổ': '',
                        'Cấp độ': '', 'CP Cấp 1': '', 
                        'Thời điểm TH': '', 'TG hoàn thành': '', 
                        'Ghi chú': just.ghiChu || '', 
                        level: level + 5, isJustification: true
                    };
                    allRows.push(justRow);
                    if (just.hasSubJustifications && just.subJustifications) {
                        // --- SỬA LỖI SẮP XẾP GIẢI TRÌNH CON ---
                        // Cũng sử dụng localeCompare với { numeric: true }
                        const subJustifications = Object.keys(just.subJustifications)
                            .map(subId => ({ id: subId, ...just.subJustifications[subId] }))
                            .sort((a, b) => (a.tt || '').localeCompare((b.tt || ''), 'en', { numeric: true }));
                        // -------------------------------------

                        subJustifications.forEach(subJust => {
                            const subJustRow = {
                                'TT': convertTTForDisplay(subJust.tt),
                                'Đầu việc/Dự án': subJust.noiDung || '',
                                'ĐV th.hiện': '', 'KH năm trước': '', 'Thực hiện năm trước': '', 'Tần suất TH': '',
                                'Đ.vị tính': subJust.donVi || '',
                                'Số lượng': subJust.soLuong === 0 ? 0 : (subJust.soLuong || ''),
                                'Đơn giá (GT)': subJust.donGia === 0 ? 0 : (subJust.donGia || ''),
                                'Chi phí KH': subJust.chiPhi === 0 ? 0 : (subJust.chiPhi || ''),
                                'Chi phí thực hiện': '', 'Kế hoạch còn lại': '', 'Năm phân bổ': '', 'CP phân bổ': '',
                                'Cấp độ': '', 'CP Cấp 1': '',
                                'Thời điểm TH': '', 'TG hoàn thành': '', 
                                'Ghi chú': subJust.ghiChu || '',
                                level: level + 6, isJustification: true
                            };
                            allRows.push(subJustRow);
                        });
                    }
                });
            }
        };

        const parents = Object.keys(parentsData).map(id => ({ id, ...parentsData[id] })).sort((a,b) => a.id.localeCompare(b.id));
        parents.forEach(p => processNode(p, `${getParentCollectionName()}/${p.id}`, '', 0));

        statusDiv.innerText = 'Đang tạo bảng HTML để xuất...';

        const baseHeadersFull = ['TT', 'Đầu việc/Dự án', 'Tag Name', 'ĐV th.hiện', 'KH năm trước', 'Thực hiện năm trước', 'Tần suất TH', 'Đ.vị tính', 'Số lượng', 'Đơn giá (GT)', 'Chi phí KH', 'Chi phí thực hiện', 'Kế hoạch còn lại', 'Năm phân bổ', 'CP phân bổ', 'Cấp độ', 'CP Cấp 1', 'Thời điểm TH', 'TG hoàn thành', 'Ghi chú'];
        const baseHeadersSimplified = baseHeadersFull.filter(h => !['Đơn giá (GT)', 'KH năm trước', 'Thực hiện năm trước', 'Thời điểm TH', 'TG hoàn thành', 'Ghi chú'].includes(h));
        const executionHeadersOrdered = [];
        for (let i = 1; i <= maxLanThucHien; i++) {
            executionHeadersOrdered.push(`Ngày TH (${i})`);
            executionHeadersOrdered.push(`Số lượng (${i})`);
            executionHeadersOrdered.push(`Đơn giá (${i})`);
            executionHeadersOrdered.push(`Thành tiền (${i})`);
            if (activeExportType === 'full') {
                 executionHeadersOrdered.push(`Timestamp (${i})`);
                 executionHeadersOrdered.push(`Hồ sơ Link (${i})`);
            }
        }
        const headersToUse = activeExportType === 'full' ? [...baseHeadersFull, ...executionHeadersOrdered] : [...baseHeadersSimplified, ...executionHeadersOrdered];

        let tableHtml = `<table border="1"><thead><tr>${headersToUse.map(h => `<th>${h}</th>`).join('')}</tr></thead><tbody>`;

        allRows.forEach(row => {
            let baseStyle = '';
            const isJustificationRow = row.isJustification === true;

            if (isJustificationRow) {
                 baseStyle = 'background-color: #fffbe6; font-style: italic; color: red;';
                 if (row.level >= 6 ) baseStyle += ' padding-left: 20px;';
            } else {
                 if (row.level === 0) baseStyle = 'font-weight: bold; background-color: #e2e6ea;';
                 else if (row.level === 1) baseStyle = 'font-weight: bold; background-color: #e9ecef;';
                 else if (row.level === 2) baseStyle = 'font-weight: bold; background-color: #f2f4f6;';
                 else if (row.level === 3) baseStyle = 'font-weight: bold; background-color: #f8f9fa;';
            }

            tableHtml += '<tr>';
            headersToUse.forEach(h => {
                let currentStyle = baseStyle;
                if (h === 'TT' || h.startsWith('Ngày TH') || h.startsWith('Timestamp')) {
                    currentStyle += " mso-number-format:'\\@';";
                } else if (['Chi phí KH', 'Chi phí thực hiện', 'Kế hoạch còn lại', 'KH năm trước', 'Thực hiện năm trước', 'Thành tiền', 'Đơn giá', 'Đơn giá (GT)', 'Số lượng', 'CP phân bổ', 'Năm phân bổ', 'CP Cấp 1'].some(numCol => h.startsWith(numCol))) {
                     currentStyle += " mso-number-format:'#,##0'; text-align: right;";
                }
                let value = row[h];
                if (h.startsWith('Timestamp')) value = String(value !== undefined && value !== null ? value : '');
                else value = value !== undefined && value !== null ? value : '';
                tableHtml += `<td style="${currentStyle}">${value}</td>`;
            });
            tableHtml += '</tr>';
        });
        tableHtml += '</tbody></table>';

        const excelTemplate = `<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40"><head><meta charset="UTF-8"><style>td { white-space: normal; vertical-align: top; }</style></head><body>${tableHtml}</body></html>`;
        const blob = new Blob([excelTemplate], { type: 'application/vnd.ms-excel;charset=utf-8' });
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        link.download = `BDSC_${currentYear}_Formatted.xls`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(link.href);

        statusDiv.innerText = 'Xuất file Excel định dạng thành công!';
    } catch (error) {
        console.error("Lỗi khi xuất Excel định dạng:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi khi xuất file: ${error.message}`;
    }
};
 
 
 //Kết thúc hàm exportFormattedExcel_HTML

	window.openSummaryDetailModal = async function() {
        try {
            statusDiv.className = 'success';
            statusDiv.innerText = 'Đang tải dữ liệu chi tiết...';

            const summaryRef = ref(db, `summary_data/${currentYear}`);
            const summarySnap = await get(summaryRef);

            if (!summarySnap.exists()) {
                throw new Error('Không tìm thấy dữ liệu tổng hợp. Vui lòng nhấn "Tải lại & Tính toán lại".');
            }
            const summaryData = summarySnap.val();

            const parentQuery = ref(db, getParentCollectionName());
            const parentSnapshot = await get(parentQuery);
            if (!parentSnapshot.exists()) {
                throw new Error('Không có dữ liệu cho năm này.');
            }

            const parentsData = parentSnapshot.val();
            const parents = Object.keys(parentsData).map(id => ({ id, ...parentsData[id] })).sort((a, b) => a.id.localeCompare(b.id));

            const modal = document.getElementById('summaryDetailModal');
            const contentContainer = document.getElementById('summaryDetailContent');
            document.getElementById('summaryDetailYear').textContent = currentYear;
            contentContainer.innerHTML = '';

            let htmlContent = '';
            for (const parent of parents) {
                const parentId = parent.id;
                const parentSummary = summaryData[parentId] || {};

                const name = parent.noiDung || 'Chưa có tên';
                const totalLeafNodes = parentSummary.totalLeafNodes || 0;
                const executedLeafNodes = parentSummary.totalExecutedLeafNodes || 0;
                const totalLeafNodesCap1 = parentSummary.totalLeafNodesCap1 || 0;
                const executedLeafNodesCap1 = parentSummary.totalExecutedLeafNodesCap1 || 0;

                // === BẮT ĐẦU SỬA LỖI ===
                // Lấy chi phí trực tiếp từ "công việc mẹ" (parent) thay vì từ summaryData
                const plannedCost = parent.chiPhi || 0;
                const executedCost = parent.chiPhiThucHien || 0;
                // === KẾT THÚC SỬA LỖI ===

                const leafPercentage = totalLeafNodes > 0 ? Math.round((executedLeafNodes / totalLeafNodes) * 100) : 0;
                const cap1Percentage = totalLeafNodesCap1 > 0 ? Math.round((executedLeafNodesCap1 / totalLeafNodesCap1) * 100) : 0;
                const costPercentage = plannedCost > 0 ? Math.round((executedCost / plannedCost) * 100) : 0;

                htmlContent += `
                    <div class="summary-parent-card">
                        <h3>${convertTTForDisplay(parentId)}. ${name}</h3>
                        <div class="summary-columns-container">
                            <div class="summary-info-column">
                                <h4>Kế hoạch</h4>
                                <p><strong>Số đầu việc KH:</strong> <span class="value">${totalLeafNodes}</span></p>
                                <p><strong>Số đầu việc cấp độ 1:</strong> <span class="value">${totalLeafNodesCap1}</span></p>
                                <p><strong>Chi phí KH:</strong> <span class="value">${formatNumber(plannedCost)}</span></p>
                            </div>
                            <div class="summary-info-column">
                                <h4>Thực hiện</h4>
                                <p><strong>Số đầu việc TH:</strong> <span class="value">${executedLeafNodes} <span class="percentage">(${leafPercentage}%)</span></span></p>
                                <p><strong>Số đầu việc cấp độ 1 TH:</strong> <span class="value">${executedLeafNodesCap1} <span class="percentage">(${cap1Percentage}%)</span></span></p>
                                <p><strong>Chi phí TH:</strong> <span class="value">${formatNumber(executedCost)} <span class="percentage">(${costPercentage}%)</span></span></p>
                            </div>
                        </div>
                        <div class="summary-charts-container">
                            <div class="chart-wrapper">
                                <canvas id="cap1Chart-${parentId}"></canvas>
                                <p>Tỷ lệ đầu việc cấp độ 1</p>
                            </div>
                            <div class="chart-wrapper">
                                <canvas id="costChart-${parentId}"></canvas>
                                <p>Tỷ lệ Chi phí</p>
                            </div>
                        </div>
                    </div>
                `;
            }

            contentContainer.innerHTML = htmlContent || '<p>Không có dữ liệu chi tiết để hiển thị.</p>';
            modal.style.display = 'block';

            activeCharts.forEach(chart => chart.destroy());
            activeCharts = [];

            for (const parent of parents) {
                const parentId = parent.id;
                const parentSummary = summaryData[parentId] || {};

                const totalLeafNodesCap1 = parentSummary.totalLeafNodesCap1 || 0;
                const executedLeafNodesCap1 = parentSummary.totalExecutedLeafNodesCap1 || 0;
                
                // === BẮT ĐẦU SỬA LỖI ===
                // Lấy chi phí trực tiếp từ "công việc mẹ" (parent) cho biểu đồ
                const plannedCost = parent.chiPhi || 0;
                const executedCost = parent.chiPhiThucHien || 0;
                // === KẾT THÚC SỬA LỖI ===

                const cap1Ctx = document.getElementById(`cap1Chart-${parentId}`).getContext('2d');
                const cap1Chart = new Chart(cap1Ctx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Đã thực hiện', 'Chưa thực hiện'],
                        datasets: [{
                            data: [executedLeafNodesCap1, totalLeafNodesCap1 - executedLeafNodesCap1],
                            backgroundColor: ['#28a745', '#e9ecef'],
                            borderColor: ['#28a745', '#e9ecef'],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed !== null) {
                                            label += context.parsed + ' đầu việc';
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
                activeCharts.push(cap1Chart);

                const costCtx = document.getElementById(`costChart-${parentId}`).getContext('2d');
                 const costChart = new Chart(costCtx, {
                    type: 'doughnut',
                    data: {
                        labels: ['Đã thực hiện', 'Còn lại'],
                        datasets: [{
                            data: [executedCost, plannedCost > executedCost ? plannedCost - executedCost : 0],
                            backgroundColor: ['#007bff', '#e9ecef'],
                            borderColor: ['#007bff', '#e9ecef'],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.label || '';
                                        if (label) { label += ': '; }
                                        if (context.parsed !== null) {
                                            label += formatNumber(context.parsed);
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
                activeCharts.push(costChart);
            }

            statusDiv.innerText = '';
        } catch (error) {
            console.error("Lỗi khi mở modal chi tiết:", error);
            statusDiv.className = 'error';
            statusDiv.innerText = `Lỗi: ${error.message}`;
        }
    };

    window.toggleDropdown = function(event) {
        event.stopPropagation();
        document.querySelectorAll(".dropdown-content").forEach(content => {
            if (content !== event.target.nextElementSibling) content.classList.remove('show');
        });
        event.target.nextElementSibling.classList.toggle("show");
    };

    window.onclick = function(event) {
        // 1. Logic cũ: Đóng dropdown menu khi click ra ngoài
        if (!event.target.matches('.dropbtn')) {
            document.querySelectorAll(".dropdown-content").forEach(content => content.classList.remove('show'));
        }

        const linksDropdown = document.getElementById('links-dropdown-container');
        if (linksDropdown && !linksDropdown.contains(event.target) && !event.target.matches('[data-links]')) {
             linksDropdown.remove();
        }

        // 2. Logic MỚI: Đóng modal "Quản lý dữ liệu" khi click ra vùng trống (bên ngoài nội dung modal)
        // 'event.target' chính là phần tử bị click. 
        // Nếu click vào nội dung trắng bên trong, target sẽ là .modal-content (hoặc con của nó).
        // Nếu click ra ngoài, target chính là cái khung bao ngoài (#dataManagementModal).
        if (event.target.id === 'dataManagementModal') {
            closeAllModals();
        }

        // Mở rộng: Nếu bạn muốn áp dụng cho cả các modal khác (như Export, Delete...) trừ modal Nhập liệu (để tránh mất dữ liệu lỡ tay)
        // Bạn có thể thêm vào điều kiện OR (||), ví dụ:
        // if (event.target.id === 'dataManagementModal' || event.target.id === 'exportOptionsModal') { ... }
    };

    // CÁC HÀM HỖ TRỢ KHÔNG CẦN GLOBAL
    function showAuthError() {
        statusDiv.className = 'error';
        statusDiv.innerText = 'Lỗi: Bạn cần xác thực để thực hiện hành động này. Vui lòng "Đăng nhập".';
        setTimeout(() => { if (statusDiv.innerText && statusDiv.innerText.includes('Bạn cần xác thực')) { statusDiv.innerText = ''; } }, 6000);
    }

    function updateButtonStates() {
      
       // 1. Kiểm tra xem năm hiện tại có bị KHÓA không
        const isYearLocked = lockedYears[currentYear] === true;

        // 2. Quyền Sửa đổi:
        // Phải đăng nhập + Checkbox bật + Năm KHÔNG bị khóa
        const isCurrentYearEditable = editModeStatusByYear[currentYear] === true;
        const canEditStructure = isAuthenticated && isCurrentYearEditable && !isYearLocked;

        // 3. Quyền Thực hiện công việc:
        // Logic cũ: Chỉ cần isAuthenticated.
        // Logic MỚI: Phải đăng nhập + Năm KHÔNG bị khóa.
        const canExecute = isAuthenticated && !isYearLocked;

        const planningToggle = document.getElementById('planningModeToggle');
        if (planningToggle) planningToggle.disabled = false;

        // --- CẬP NHẬT NÚT THỰC HIỆN ---
        const multiExecuteButton = document.getElementById('multiExecuteBtn');
        if (multiExecuteButton) {
            multiExecuteButton.disabled = selectedTasks.size === 0 || !canExecute;
            // Thêm visual clue (nếu muốn): làm mờ đi nếu bị lock
            if (isYearLocked) {
                multiExecuteButton.title = "Dữ liệu năm nay đã bị khóa hoàn toàn.";
            } else {
                multiExecuteButton.title = "";
            }
        }

        // --- GIỮ NGUYÊN CÁC NÚT KHÁC (Dùng canEditStructure) ---
        const deleteSelectedButton = document.getElementById('deleteSelectedBtn');
        if (deleteSelectedButton) {
            deleteSelectedButton.disabled = !canEditStructure || (selectedTasks.size === 0 && selectedJustifications.size === 0);
        }

        const actionButtons = document.querySelectorAll('#taskList .dropbtn, #taskList .btn-edit-leaf');
        actionButtons.forEach(btn => {
            btn.disabled = !canEditStructure;
        });
        // Logic tắt Planning Mode khi mất quyền sửa đổi (giữ nguyên để đảm bảo an toàn giao diện)
        if (!canEditStructure) {
            if (planningToggle && planningToggle.checked && isAuthenticated) {
                planningToggle.checked = false;
                const taskList = document.getElementById('taskList');
                if (taskList) taskList.classList.remove('planning-mode');
                
                const btnExcel1 = document.getElementById('exportExcel1Btn');
                const btnExcel2 = document.getElementById('exportExcel2Btn');
                if (btnExcel1) btnExcel1.disabled = false;
                if (btnExcel2) btnExcel2.disabled = true;

                const allRows = document.querySelectorAll('#taskListBody tr');
                allRows.forEach(row => row.style.display = '');
            }
        }
    }

    const recalculateExecutionCost = async (leafNodePath) => {
        const execSnapshot = await get(ref(db, `${leafNodePath}/executions`));
        let newChiPhiThucHien = 0;
        if (execSnapshot.exists()) {
            const execData = execSnapshot.val();
            for (const execId in execData) {
                newChiPhiThucHien += (execData[execId].thanhTien || 0);
            }
        }
        const leafNodeSnap = await get(ref(db, leafNodePath));
        if (leafNodeSnap.exists()) {
            const leafNodeData = leafNodeSnap.val();
            const chiPhi = leafNodeData.chiPhi || 0;
            await update(ref(db, leafNodePath), { chiPhiThucHien: newChiPhiThucHien, keHoachConLai: chiPhi - newChiPhiThucHien });
        }
    };

    const writeTreeToRealtimeDatabase = async (tree) => {
    const updates = {};

    const processNode = (node, path) => {
        // Thay đổi logic: cập nhật từng trường riêng lẻ thay vì cả đối tượng
        if (node.data && Object.keys(node.data).length > 1) {
            for (const key in node.data) {
                if (Object.prototype.hasOwnProperty.call(node.data, key)) {
                    // Tạo đường dẫn đầy đủ cho từng trường dữ liệu, ví dụ: .../A/noiDung
                    updates[`${path}/${key}`] = node.data[key];
                }
            }
        }

        if (node.justifications) {
            node.justifications.forEach(just => {
                const justPath = `${path}/justifications/${just.id}`;
                // Áp dụng logic tương tự cho các giải trình
                for (const key in just.data) {
                    if (Object.prototype.hasOwnProperty.call(just.data, key)) {
                        updates[`${justPath}/${key}`] = just.data[key];
                    }
                }
  // THÊM PHẦN NÀY: Xử lý giải trình cấp 2
                if (just.subJustifications) {
                    just.subJustifications.forEach(subJust => {
                        const subJustPath = `${justPath}/subJustifications/${subJust.id}`;
                        for (const key in subJust.data) {
                            if (Object.prototype.hasOwnProperty.call(subJust.data, key)) {
                                updates[`${subJustPath}/${key}`] = subJust.data[key];
                            }
                        }
                    });
                }
            });
        }



        // Các lời gọi đệ quy để xử lý các cấp con được giữ nguyên
        if (node.children) {
            node.children.forEach(child => processNode(child, `${path}/children/${child.id}`));
        }
        if (node.grandchildren) {
            node.grandchildren.forEach(grandchild => processNode(grandchild, `${path}/grandchildren/${grandchild.id}`));
        }
        if (node.greatGrandchildren) {
            node.greatGrandchildren.forEach(ggc => {
                const ggcPath = `${path}/greatGrandchildren/${ggc.id}`;
                processNode(ggc, ggcPath);

                if ((!ggc.greatGreatGrandchildren || ggc.greatGreatGrandchildren.length === 0) && ggc.executions && ggc.executions.length > 0) {
                    ggc.executions.forEach(exec => {
                        const execKey = push(child(ref(db), `${ggcPath}/executions`)).key;
                        updates[`${ggcPath}/executions/${execKey}`] = exec;
                    });
                }
            });
        }
        if (node.greatGreatGrandchildren) {
             node.greatGreatGrandchildren.forEach(gggc => {
                const gggcPath = `${path}/greatGreatGrandchildren/${gggc.id}`;
                processNode(gggc, gggcPath);
                if (gggc.executions && gggc.executions.length > 0) {
                    gggc.executions.forEach(exec => {
                        const execKey = push(child(ref(db), `${gggcPath}/executions`)).key;
                        updates[`${gggcPath}/executions/${execKey}`] = exec;
                    });
                }
            });
        }
    };

    tree.forEach(p => processNode(p, `${getParentCollectionName()}/${p.id}`));

    // Lệnh update cuối cùng không thay đổi, nhưng đối tượng 'updates' đã an toàn
    await update(ref(db), updates);
};

    const formatNumber = (num) => num?.toLocaleString('vi-VN') || '0';

// === BẮT ĐẦU: HÀM HELPER MỚI ĐỂ TĂNG TT ===
 function incrementTT(displayTT) {
    try {
        // --- LOGIC MỚI: XỬ LÝ DẤU SAO (*) ---
        // Ví dụ: 2*1 -> 2*2, 3.2*5 -> 3.2*6
        if (displayTT.includes('*')) {
            // Tách phần trước và sau dấu * cuối cùng
            const lastStarIndex = displayTT.lastIndexOf('*');
            const prefix = displayTT.substring(0, lastStarIndex + 1); // "2*" hoặc "3.2*"
            const suffix = displayTT.substring(lastStarIndex + 1);    // "1" hoặc "1.1"

            // Nếu suffix có dấu chấm (SubJustification: 1.1)
            if (suffix.includes('.')) {
                const parts = suffix.split('.');
                const lastNum = parseInt(parts.pop(), 10);
                if (!isNaN(lastNum)) {
                    parts.push(lastNum + 1);
                    return prefix + parts.join('.');
                }
            } else {
                // Justification thường: "1"
                const num = parseInt(suffix, 10);
                if (!isNaN(num)) {
                    return prefix + (num + 1);
                }
            }
        }

        // --- XỬ LÝ TASK (GIỮ NGUYÊN) ---
        if (displayTT.includes('.')) {
            const parts = displayTT.split('.');
            const lastPart = parts.pop();
            const num = parseInt(lastPart, 10);
            
            if (!isNaN(num)) {
                parts.push(num + 1);
                return parts.join('.');
            }
        }

        const num = parseInt(displayTT, 10);
        if (!isNaN(num)) {
            return String(num + 1);
        }

    } catch (e) {
        console.error("Lỗi khi tăng TT:", displayTT, e);
    }
    
    return displayTT + "_new";
}
    // === KẾT THÚC: HÀM HELPER MỚI ĐỂ TĂNG TT ===

    function initializeGoogleClients() {
        // Khởi tạo GAPI Client (Drive API)
        gapi.load('client', async () => {
            try {
                await gapi.client.init({
                   // apiKey: API_KEY, // Không cần thiết khi dùng OAuth
                   discoveryDocs: DISCOVERY_DOCS,
                });
                gapiReady = true;
                console.log('GAPI client initialized.');
            } catch (error) {
                 console.error('Lỗi khởi tạo GAPI client:', error);
                 statusDiv.className = 'error';
                 statusDiv.innerText = 'Lỗi kết nối tới Google Drive API.';
            }
        });

        // Khởi tạo Google Identity Services (GIS) Client (OAuth)
        try {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: SCOPES,
                callback: tokenResponseCallback, // Callback mặc định (có thể bị ghi đè tạm thời)
            });
            gisInited = true;
            console.log('GIS token client initialized.');
        } catch (error) {
            console.error('Lỗi khởi tạo GIS token client:', error);
            statusDiv.className = 'error';
            statusDiv.innerText = 'Lỗi kết nối tới dịch vụ xác thực Google.';
        }
    }

    function ensureGapiAuthenticated() {
        return new Promise((resolve, reject) => {
            if (gapi.client.getToken()) return resolve(gapi.client.getToken());
            tokenClient.requestAccessToken({ prompt: '' });
            tokenClient.callback = (resp) => {
                if (resp.error) reject(resp.error);
                else resolve(resp);
                tokenClient.callback = () => {};
            };
        });
    }



    const calculateCosts = (tree) => {
    tree.forEach(parent => {
        let parentChiPhi = 0, parentChiPhiThucHien = 0, parentKhNamTruoc = 0;
        (parent.children || []).forEach(child => {
            let childChiPhi = 0, childChiPhiThucHien = 0, childKhNamTruoc = 0;
            (child.grandchildren || []).forEach(grandchild => {
                let grandchildChiPhi = 0, grandchildChiPhiThucHien = 0, grandchildKhNamTruoc = 0;
                (grandchild.greatGrandchildren || []).forEach(ggc => {
                    if ((ggc.greatGreatGrandchildren || []).length > 0) {
                        ggc.data.hasChildren = true;
                        
                        // THÊM MỚI: Tính chi phí cho lá cấp 5 (ggggc) từ giải trình của nó
                        ggc.greatGreatGrandchildren.forEach(ggggc => {
                            // Tính tổng chi phí từ giải trình (cả cấp 1 và cấp 2) của lá cấp 5
                            let justificationChiPhi = 0;
                            if (ggggc.justifications && ggggc.justifications.length > 0) {
                                ggggc.justifications.forEach(just => {
                                    // NẾU CÓ GIẢI TRÌNH CẤP 2: tính tổng chi phí của các giải trình cấp 2
                                    if (just.subJustifications && just.subJustifications.length > 0) {
                                        justificationChiPhi += just.subJustifications.reduce(
                                            (sum, subJust) => sum + (subJust.data.chiPhi || 0), 0
                                        );
                                    } else {
                                        // NẾU KHÔNG CÓ GIẢI TRÌNH CẤP 2: lấy chi phí của giải trình cấp 1
                                        justificationChiPhi += just.data.chiPhi || 0;
                                    }
                                });
                                ggggc.data.chiPhi = justificationChiPhi; // Ghi đè chiPhi của lá cấp 5
                            }
                        });

                        const ggcChiPhi = ggc.greatGreatGrandchildren.reduce((s, gggc) => s + (gggc.data.chiPhi || 0), 0);
                        const ggcChiPhiThucHien = ggc.greatGreatGrandchildren.reduce((s, gggc) => s + (gggc.data.chiPhiThucHien || 0), 0);
                        const ggcKhNamTruoc = ggc.greatGreatGrandchildren.reduce((s, gggc) => s + (gggc.data.khNamTruoc || 0), 0);
                        ggc.data.chiPhi = ggcChiPhi;
                        ggc.data.chiPhiThucHien = ggcChiPhiThucHien;
                        ggc.data.khNamTruoc = ggcKhNamTruoc;
                    } else {
                        // Đây là lá cấp 4. Tính chi phí từ giải trình của nó (cả cấp 1 và cấp 2)
                        let justificationChiPhi = 0;
                        if (ggc.justifications && ggc.justifications.length > 0) {
                            ggc.justifications.forEach(just => {
                                // NẾU CÓ GIẢI TRÌNH CẤP 2: tính tổng chi phí của các giải trình cấp 2
                                if (just.subJustifications && just.subJustifications.length > 0) {
                                    justificationChiPhi += just.subJustifications.reduce(
                                        (sum, subJust) => sum + (subJust.data.chiPhi || 0), 0
                                    );
                                } else {
                                    // NẾU KHÔNG CÓ GIẢI TRÌNH CẤP 2: lấy chi phí của giải trình cấp 1
                                    justificationChiPhi += just.data.chiPhi || 0;
                                }
                            });
                            ggc.data.chiPhi = justificationChiPhi; // Ghi đè chiPhi của lá cấp 4
                        }
                        ggc.data.hasChildren = false;
                    }
                    if (ggc.data) {
                        ggc.data.keHoachConLai = (ggc.data.chiPhi || 0) - (ggc.data.chiPhiThucHien || 0);
                        grandchildChiPhi += ggc.data.chiPhi || 0;
                        grandchildChiPhiThucHien += ggc.data.chiPhiThucHien || 0;
                        grandchildKhNamTruoc += ggc.data.khNamTruoc || 0;
                    }
                });
                if (grandchild.data) {
                    grandchild.data.chiPhi = grandchildChiPhi;
                    grandchild.data.chiPhiThucHien = grandchildChiPhiThucHien;
                    grandchild.data.khNamTruoc = grandchildKhNamTruoc;
                    grandchild.data.keHoachConLai = grandchildChiPhi - grandchildChiPhiThucHien;
                }
                childChiPhi += grandchildChiPhi;
                childChiPhiThucHien += grandchildChiPhiThucHien;
                childKhNamTruoc += grandchildKhNamTruoc;
            });
            if (child.data) {
                child.data.chiPhi = childChiPhi;
                child.data.chiPhiThucHien = childChiPhiThucHien;
                child.data.khNamTruoc = childKhNamTruoc;
                child.data.keHoachConLai = childChiPhi - childChiPhiThucHien;
            }
            parentChiPhi += childChiPhi;
            parentChiPhiThucHien += childChiPhiThucHien;
            parentKhNamTruoc += childKhNamTruoc;
        });
        if (parent.data) {
            parent.data.chiPhi = parentChiPhi;
            parent.data.chiPhiThucHien = parentChiPhiThucHien;
            parent.data.khNamTruoc = parentKhNamTruoc;
            parent.data.keHoachConLai = parentChiPhi - parentChiPhiThucHien;
        }
    });
};

   const childSort = (a, b) => {
        // (CẬP NHẬT) a.id và b.id bây giờ chỉ là 'I', 'V', 'X'.
        // Không cần split hay so sánh parent.
        const numA = romanToNumber(a.id);
        const numB = romanToNumber(b.id);
        return numA - numB;
    };

    const numericSort = (a, b) => {
        const partsA = String(a.id).split(',').map(v => parseInt(v, 10));
        const partsB = String(b.id).split(',').map(v => parseInt(v, 10));
        const len = Math.max(partsA.length, partsB.length);
        for (let i = 0; i < len; i++) {
            const valA = partsA[i] || 0, valB = partsB[i] || 0;
            if (valA !== valB) return valA - valB;
        }
        return 0;
    };

    const createModalTable = (headers) => {
        let table = '<table class="modal-table"><thead><tr>';
        headers.forEach(h => {
            const style = h.width ? ` style="width: ${h.width};"` : '';
            const className = h.class ? ` class="${h.class}"` : '';
            const text = typeof h === 'object' ? h.text : h;
            table += `<th${style}${className}>${text}</th>`;
        });
        table += '</tr></thead><tbody>';
        return table;
    };

const createInputRow = (path, data, level, context = {}) => {
        const isGrandchild = level === 'grandchild';
		const isJustification = level === 'justification';
        const isSubJustification = level === 'subJustification';
        
        // Biến cờ để đánh dấu dòng này là giải trình (Dùng cho calculateModalChiPhi)
        const isJustificationRow = isJustification || isSubJustification;
        
        const displayTT = convertTTForDisplay(data.tt);
        
        if (isJustificationRow) {
            const actuallyHasSubs = data.subJustifications && Object.keys(data.subJustifications).length > 0;
            const isParentJustification = isJustification && (data.hasSubJustifications === true && actuallyHasSubs);

            // --- SỬA ĐỔI: Thêm data-is-justification="true" ---
           return `<tr data-path="${path}" data-is-justification="true">
                <td><input type="text" value="${displayTT}" data-field="tt" disabled></td>
                <td><input type="text" value="${data.noiDung || ''}" data-field="noiDung"></td>
                <td><input type="text" value="${data.donVi || ''}" data-field="donVi" ${isParentJustification ? 'disabled' : ''}></td>
                <td><input type="number" value="${data.soLuong || ''}" data-field="soLuong" oninput="calculateModalChiPhi(this)" onfocus="this.select()" ${isParentJustification ? 'disabled' : ''}></td>
                <td><input type="number" value="${data.donGia || 0}" data-field="donGia" oninput="calculateModalChiPhi(this)" onfocus="this.select()" ${isParentJustification ? 'disabled' : ''}></td>
                <td><input type="text" value="${formatNumber(data.chiPhi || (data.soLuong * data.donGia) || 0)}" data-field="chiPhi" disabled oninput="this.value=formatNumber(parseNumber(this.value))"></td>
                <td><input type="text" value="${data.ghiChu || ''}" data-field="ghiChu"></td>
            </tr>`;
        }
    let tagNameHtml = '';
    if (isGrandchild) {
        let optionsHtml = '<option value="">-- Chọn Tag --</option>';
        
        // Lúc này cachedEquipmentList ĐẢM BẢO đã có dữ liệu (do đã await ở bước 3, 4)
        if (cachedEquipmentList && cachedEquipmentList.length > 0) {
            const currentTag = (data.tagName || '').trim();
            let found = false;

            cachedEquipmentList.forEach(item => {
                const isSelected = currentTag === item.tag;
                if (isSelected) found = true;
                optionsHtml += `<option value="${item.tag}" ${isSelected ? 'selected' : ''}>${item.tag} - ${item.name}</option>`;
            });
            
            // Giữ lại giá trị cũ nếu không nằm trong danh sách (để không bị mất dữ liệu nhập tay từ Excel)
            if (currentTag && !found) {
                 optionsHtml = `<option value="${currentTag}" selected style="color:red">${currentTag} (Chưa chuẩn hóa)</option>` + optionsHtml;
            }
        }
        
        tagNameHtml = `<select data-field="tagName" style="width: 100%; padding: 5px;">${optionsHtml}</select>`;
    } else {
        tagNameHtml = `<input type="text" disabled style="background-color: #f9f9f9; border: none;">`;
    }


        const isParent = ['parent', 'child'].includes(level) || (level === 'grandchild' && data.hasChildren === true);
        const isEditableLeaf = ['greatGrandchild', 'greatGreatGrandchild'].includes(level) || (level === 'grandchild' && !data.hasChildren);
        const chiPhiDisabled = isEditableLeaf && context.hasJustifications;

        const isDisabled = (field) => {
            if (field === 'tt') return true;
            if (field === 'namPhanBo') return isParent; 
            if (isParent) return !['noiDung', 'ghiChu', 'dvThucHien', 'capDo', 'khNamTruoc', 'thucHienNamTruoc', 'tgBatDau', 'tgHoanThanh', 'namPhanBo'].includes(field); 
            if (field === 'chiPhi') return chiPhiDisabled;
            if (field === 'chiPhiPhanBo' || field === 'cpCap1') return true;
            return false;
        };

        const triggerCalc = isEditableLeaf ? 'oninput="calculateModalChiPhi(this)"' : '';
        const chiPhiEvent = isEditableLeaf ? 'onfocus="this.select()"' : '';

        let displayTanSuatModal = 1; 
        if (data.tanSuatTH !== undefined && data.tanSuatTH !== null && data.tanSuatTH !== '') {
            displayTanSuatModal = data.tanSuatTH;
        }

                return `<tr data-path="${path}" data-is-leaf="${isEditableLeaf}">
            <td><input type="text" value="${displayTT}" data-field="tt" disabled></td>
            <td><input type="text" value="${data.noiDung || ''}" data-field="noiDung" ${isDisabled('noiDung') ? 'disabled' : ''}></td>
            
            <td>${tagNameHtml}</td> 
            <td><input type="text" value="${data.dvThucHien || ''}" data-field="dvThucHien" ${isDisabled('dvThucHien') ? 'disabled' : ''}></td>
            
            <td><input type="text" value="${formatNumber(data.khNamTruoc || 0)}" data-field="khNamTruoc" oninput="this.value=formatNumber(parseNumber(this.value))" ${chiPhiEvent} ${isDisabled('khNamTruoc') ? 'disabled' : ''}></td>
            <td><input type="text" value="${formatNumber(data.thucHienNamTruoc || 0)}" data-field="thucHienNamTruoc" oninput="this.value=formatNumber(parseNumber(this.value))" ${chiPhiEvent} ${isDisabled('thucHienNamTruoc') ? 'disabled' : ''}></td>

            <td><input type="text" value="${data.donVi || ''}" data-field="donVi" ${isDisabled('donVi') ? 'disabled' : ''}></td>
            <td><input type="text" value="${data.soLuong || ''}" data-field="soLuong" ${isDisabled('soLuong') ? 'disabled' : ''}></td>
            
            <td><input type="number" value="${displayTanSuatModal}" data-field="tanSuatTH" ${isDisabled('tanSuatTH') ? 'disabled' : ''}></td>
            
            <td><input type="text" value="${formatNumber(data.chiPhi || 0)}" data-field="chiPhi" oninput="this.value=formatNumber(parseNumber(this.value)); ${isEditableLeaf ? 'calculateModalChiPhi(this)' : ''}" ${chiPhiEvent} ${isDisabled('chiPhi') ? 'disabled' : ''}></td>
            
            <td><input type="number" value="${data.namPhanBo || ''}" data-field="namPhanBo" ${triggerCalc} ${isDisabled('namPhanBo') ? 'disabled' : ''}></td>
            <td><input type="text" value="${formatNumber(data.chiPhiPhanBo || 0)}" data-field="chiPhiPhanBo" disabled></td>

            <td><input type="text" value="${data.capDo || ''}" data-field="capDo" ${isDisabled('capDo') ? 'disabled' : ''}></td>

            <td><input type="text" value="${data.tgBatDau || ''}" data-field="tgBatDau" ${isDisabled('tgBatDau') ? 'disabled' : ''}></td>
            <td><input type="text" value="${data.tgHoanThanh || ''}" data-field="tgHoanThanh" ${isDisabled('tgHoanThanh') ? 'disabled' : ''}></td>

            <td><input type="text" value="${data.ghiChu || ''}" data-field="ghiChu" ${isDisabled('ghiChu') ? 'disabled' : ''}></td>
        </tr>`;

    };

  const generateNextTT = async (parentPath, level) => {
    const parentRef = ref(db, parentPath);
    const parentSnap = await get(parentRef);

    // Xử lý trường hợp tạo mới Cấp 1 (A, B...) - GIỮ NGUYÊN
    if (!parentSnap.exists()) {
        if (level === 'parent') {
            const rootSnapshot = await get(ref(db, getParentCollectionName()));
            let maxCharCode = 64; 
            if (rootSnapshot.exists()) {
                const rootData = rootSnapshot.val();
                for (const key in rootData) {
                    if (rootData[key]?.tt?.match(/^[A-Z]$/)) {
                        const charCode = rootData[key].tt.charCodeAt(0);
                        if (charCode > maxCharCode) maxCharCode = charCode;
                    }
                }
            }
            return String.fromCharCode(maxCharCode + 1);
        } else {
            return '1';
        }
    }

    const data = parentSnap.val();
    const parentTTStorage = data.tt || ''; 
    const parentTTDisplay = convertTTForDisplay(parentTTStorage);

    let subCollectionName;
    if (level === 'child') subCollectionName = 'children';
    else if (level === 'grandchild') subCollectionName = 'grandchildren';
    else if (level === 'greatGrandchild') subCollectionName = 'greatGrandchildren';
    else if (level === 'justification') subCollectionName = 'justifications';
    else if (level === 'subJustification') subCollectionName = 'subJustifications';
    else return 'error';

    const subCollection = data[subCollectionName] || {};
    let maxNumPart = 0; 

    // --- LOGIC SINH MÃ CHO GIẢI TRÌNH (DÙNG *) ---
    if (level === 'justification') {
        // Định dạng: [ParentTT]*[Num] (Ví dụ: 3.2*1)
        // Tiền tố cần tìm: "[ParentTT]*"
        const prefix = `${parentTTDisplay}*`;
        
        for (const key in subCollection) {
            const itemTT = convertTTForDisplay(subCollection[key].tt);
            if (itemTT.startsWith(prefix)) {
                // Lấy phần số sau dấu *
                const suffix = itemTT.substring(prefix.length);
                const num = parseInt(suffix, 10);
                if (!isNaN(num) && num > maxNumPart) maxNumPart = num;
            }
        }
        // Kết quả: 3.2*1
        return `${parentTTDisplay}*${maxNumPart + 1}`; 
    }

    // --- LOGIC SINH MÃ CHO GIẢI TRÌNH CON ---
    if (level === 'subJustification') {
        // Định dạng: [ParentJustTT].[Num] (Ví dụ: 3.2*1.1)
        // Lưu ý: ParentJustTT ở đây đã có dạng "3.2*1"
        // Tiền tố: "[ParentJustTT]."
        const prefix = `${parentTTDisplay}.`;
        
        for (const key in subCollection) {
            const itemTT = convertTTForDisplay(subCollection[key].tt);
            if (itemTT.startsWith(prefix)) {
                // Lấy phần số sau dấu chấm cuối cùng
                const suffix = itemTT.substring(prefix.length);
                const num = parseInt(suffix, 10);
                if (!isNaN(num) && num > maxNumPart) maxNumPart = num;
            }
        }
        return `${parentTTDisplay}.${maxNumPart + 1}`;
    }

    // --- LOGIC CŨ CHO CÁC TASK (GIỮ NGUYÊN) ---
    for (const key in subCollection) {
        const currentItem = subCollection[key];
        if (!currentItem?.tt) continue;
        const tt = currentItem.tt;
        try {
            let currentNum = NaN;
            let updateMax = false;
            if (level === 'child') {
                currentNum = romanToNumber(tt); 
                updateMax = !isNaN(currentNum) && currentNum > 0 && currentNum > maxNumPart;
            } else if (level === 'grandchild') {
                currentNum = parseInt(tt, 10); 
                updateMax = !isNaN(currentNum) && currentNum > maxNumPart;
            } else if (level === 'greatGrandchild') {
                let prefixFound = false;
                let numPartStr = null;
                if (tt.startsWith(parentTTStorage + ',')) {
                     prefixFound = true; numPartStr = tt.substring(parentTTStorage.length + 1);
                }
                if (prefixFound && numPartStr !== null) {
                    const parts = numPartStr.split(',');
                    if (parts.length > 0) {
                        currentNum = parseInt(parts[0], 10);
                        updateMax = !isNaN(currentNum) && currentNum > maxNumPart;
                    }
                }
            }
            if (updateMax) maxNumPart = currentNum;
        } catch (e) {}
    } 

    let nextTT = 'error';
    if (level === 'child') {
        nextTT = numberToRoman(maxNumPart + 1); 
    } else if (level === 'grandchild') {
        nextTT = String(maxNumPart + 1); 
    } else if (level === 'greatGrandchild') {
        nextTT = `${parentTTStorage},${maxNumPart + 1}`;
    }
    
    return nextTT;
};

    /**
     * Hàm nội bộ để bỏ chọn con (dùng cho nút "Chọn tất cả" ở đầu bảng)
     * Giữ nguyên dạng function cục bộ như mã nguồn gốc
     */
    function clearChildrenCheckboxes(parentCheckbox) {
        // Đảm bảo cha đã bỏ chọn trước khi gọi logic lan truyền
        if (parentCheckbox.checked) {
            parentCheckbox.checked = false;
        }
        // Tái sử dụng logic của toggleSelection để bỏ chọn toàn bộ con cháu
        window.toggleSelection(parentCheckbox);
    }

    window.onscroll = function() {
        const btn = document.getElementById("scrollToTopBtn");
        if (document.body.scrollTop > 300 || document.documentElement.scrollTop > 300) {
            btn.style.display = "block";
        } else {
            btn.style.display = "none";
        }
    };

// Ensure checkAndUpdateDaThucHien is robust
     

   const recalculateCostsForParents = async (paths) => {
        const pathsToRecalculate = new Set();
        const pathsToCheckDaThucHien = new Set(); // Keep track of child paths for 'daThucHien' check

        // 1. Gather all unique ancestor paths
        for (const path of paths) {
            let currentPath = path;
            while (currentPath.includes('/')) {
                const parentPath = currentPath.substring(0, currentPath.lastIndexOf('/'));
                // Ensure we don't add collection names like 'children', 'grandchildren' etc.
                if (parentPath.split('/').length > 1 && !['children', 'grandchildren', 'greatGrandchildren', 'greatGreatGrandchildren'].includes(parentPath.substring(parentPath.lastIndexOf('/') + 1))) {
                    pathsToRecalculate.add(parentPath);
                     // If it's a direct child of the root (e.g., congViecMeYYYY/A/children/A,1), add for 'daThucHien' check
                     if (parentPath.split('/').length === 4 && parentPath.includes('/children/')) {
                         pathsToCheckDaThucHien.add(parentPath);
                     }
                }
                 // If the original path was a direct child, add it for checking 'daThucHien' status
                 if (path.split('/').length === 4 && path.includes('/children/')) {
                      pathsToCheckDaThucHien.add(path);
                 }

                currentPath = parentPath;
            }
        }

        // 2. Sort paths by depth (deepest first) to ensure bottom-up calculation
        const sortedPaths = Array.from(pathsToRecalculate).sort((a, b) => {
            const depthA = a.split('/').length;
            const depthB = b.split('/').length;
            return depthB - depthA; // Sort descending by depth
        });

        // 3. Recalculate sequentially from deepest to shallowest
        for (const path of sortedPaths) {
            // Determine the correct children field based on the path structure
            let childrenField = null;
            if (path.includes('/greatGrandchildren/')) childrenField = 'greatGreatGrandchildren';
            else if (path.includes('/grandchildren/')) childrenField = 'greatGrandchildren';
            else if (path.includes('/children/')) childrenField = 'grandchildren';
            else if (path.startsWith('congViecMe')) childrenField = 'children'; // Root level

            await recalculateSingleParentCost(path, childrenField); // Pass the determined children field
        }

        // 4. Update 'daThucHien' status for relevant child nodes after costs are updated
        for (const childPath of pathsToCheckDaThucHien) {
             // Check based on the direct children first (grandchildren level)
             const childSnap = await get(ref(db, childPath));
             if (childSnap.exists() && childSnap.val().grandchildren) {
                await checkAndUpdateDaThucHien(childPath);
             } else {
                 // If no grandchildren, check if the child itself has executions (shouldn't happen with current structure, but safe check)
                  const execSnapshot = await get(ref(db, `${childPath}/executions`));
                  await update(ref(db), { [`${childPath}/daThucHien`]: execSnapshot.exists() && Object.keys(execSnapshot.val()).length > 0 });
             }

        }
    };

  /**
 * HÀM CẬP NHẬT: recalculateSingleParentCost
 * Đã bổ sung logic cộng dồn 'chiPhiPhanBo' từ con lên cha.
 */
const recalculateSingleParentCost = async (parentPath, childrenField = null, fieldsToRecalculate = ['chiPhi', 'chiPhiThucHien', 'keHoachConLai', 'khNamTruoc', 'thucHienNamTruoc', 'chiPhiPhanBo', 'cpCap1']) => {
    const parentRef = ref(db, parentPath);
    const parentSnap = await get(parentRef);
    if (!parentSnap.exists()) return;

    const parentData = parentSnap.val();
    let isLeafNode = false;
    let childrenData = {};

    const pathSegments = parentPath.split('/');
    const nodeLevelName = pathSegments[pathSegments.length - 2];

    if (nodeLevelName === 'greatGreatGrandchildren') {
        isLeafNode = true; 
    } else if (nodeLevelName === 'greatGrandchildren' && parentData.hasChildren !== true) {
        isLeafNode = true; 
    } else {
        if (childrenField && parentData[childrenField]) {
            childrenData = parentData[childrenField];
        } else {
             childrenData = {}; 
        }
    }

    const updates = {};
    let shouldUpdate = false;

    if (isLeafNode) {
        const currentChiPhi = parentData.chiPhi || 0;
        const currentChiPhiThucHien = parentData.chiPhiThucHien || 0;
        
        // 1. Tính Kế hoạch còn lại
        const newKeHoachConLai = currentChiPhi - currentChiPhiThucHien;
        if (parentData.keHoachConLai !== newKeHoachConLai) {
            updates[`${parentPath}/keHoachConLai`] = newKeHoachConLai;
            shouldUpdate = true;
        }
        
        // 2. Tính CP Phân Bổ
        const nam = parentData.namPhanBo || 0;
        const newCpPb = (nam > 0) ? Math.round(currentChiPhi / nam) : 0;
        if (parentData.chiPhiPhanBo !== newCpPb) {
            updates[`${parentPath}/chiPhiPhanBo`] = newCpPb;
            shouldUpdate = true;
        }

        // 3. Tính CP Cấp 1 (MỚI)
        let newCpCap1 = 0;
        const capDoStr = String(parentData.capDo || '').trim().toLowerCase();
        if (capDoStr === '1' || capDoStr === '') {
            newCpCap1 = currentChiPhi;
        } else if (capDoStr === '6t') {
            newCpCap1 = Math.round(currentChiPhi * 0.5);
        } else {
            newCpCap1 = 0;
        }

        if (parentData.cpCap1 !== newCpCap1) {
            updates[`${parentPath}/cpCap1`] = newCpCap1;
            shouldUpdate = true;
        }

    } else {
        // **XỬ LÝ NÚT CHA:**
        const total = { 
            chiPhi: 0, 
            chiPhiThucHien: 0, 
            khNamTruoc: 0, 
            thucHienNamTruoc: 0,
            chiPhiPhanBo: 0,
            cpCap1: 0 // Tổng CP Cấp 1
        };

        if (typeof childrenData === 'object' && childrenData !== null) {
            for (const childId in childrenData) {
                if (typeof childrenData[childId] === 'object' && childrenData[childId] !== null) {
                    const child = childrenData[childId];
                    total.chiPhi += child.chiPhi || 0;
                    total.chiPhiThucHien += child.chiPhiThucHien || 0;
                    total.khNamTruoc += child.khNamTruoc || 0;
                    total.thucHienNamTruoc += child.thucHienNamTruoc || 0;
                    total.chiPhiPhanBo += (parseFloat(child.chiPhiPhanBo) || 0);
                    // Cộng dồn từ con
                    total.cpCap1 += (child.cpCap1 || 0);
                }
            }
        }
        
        fieldsToRecalculate.forEach(field => {
            if (field === 'keHoachConLai') return;

            if (parentData[field] !== total[field]) {
                updates[`${parentPath}/${field}`] = total[field];
                shouldUpdate = true;
            }
        });

        const newChiPhi = updates[`${parentPath}/chiPhi`] !== undefined ? updates[`${parentPath}/chiPhi`] : (parentData.chiPhi || 0);
        const newChiPhiThucHien = updates[`${parentPath}/chiPhiThucHien`] !== undefined ? updates[`${parentPath}/chiPhiThucHien`] : (parentData.chiPhiThucHien || 0);
        const newKeHoachConLai = newChiPhi - newChiPhiThucHien;

        if (parentData.keHoachConLai !== newKeHoachConLai) {
            updates[`${parentPath}/keHoachConLai`] = newKeHoachConLai;
            shouldUpdate = true;
        }
    }

    if (shouldUpdate) {
        await update(ref(db), updates);
    }
};
    // kết thúc recalculateSingleParentCost ở đây


    const recalculateCostsAfterJustificationChange = async (leafNodePaths) => {
    console.log("Entering recalculateCostsAfterJustificationChange with:", leafNodePaths);

    const pathsToProcess = Array.isArray(leafNodePaths) ? leafNodePaths : [leafNodePaths];
    if (pathsToProcess.length === 0) return;

    const pathsForParentRecalc = new Set();

    try {
        for (const leafNodePath of pathsToProcess) {
            pathsForParentRecalc.add(leafNodePath);

            const justSnapshot = await get(ref(db, `${leafNodePath}/justifications`));
            const leafNodeSnap = await get(ref(db, leafNodePath)); 

            let calculatedTotalChiPhiForLeaf = 0; 
            const updatesForThisLeaf = {}; 

            if (leafNodeSnap.exists()) {
                const leafNodeData = leafNodeSnap.val();
                let currentLeafChiPhi = leafNodeData.chiPhi || 0; 

                if (justSnapshot.exists()) {
                    const justificationsData = justSnapshot.val();

                    for (const justId in justificationsData) {
                        const justificationL1 = justificationsData[justId];
                        const justificationL1Path = `${leafNodePath}/justifications/${justId}`;
                        let costForThisL1 = 0;

                        // SỬA LỖI LOGIC TẠI ĐÂY
                        if (justificationL1.hasSubJustifications === true) {
                            if (justificationL1.subJustifications) {
                                let totalSubCost = 0;
                                for (const subId in justificationL1.subJustifications) {
                                    totalSubCost += justificationL1.subJustifications[subId].chiPhi || 0;
                                }
                                costForThisL1 = totalSubCost;
                            } else {
                                // Nếu cờ = true nhưng không có con -> Chi phí phải là 0
                                costForThisL1 = 0; 
                            }

                            // Cập nhật nếu giá trị sai lệch
                            if (justificationL1.chiPhi !== costForThisL1) {
                                updatesForThisLeaf[`${justificationL1Path}/chiPhi`] = costForThisL1;
                            }
                        } else {
                            costForThisL1 = justificationL1.chiPhi || 0;
                        }
                        calculatedTotalChiPhiForLeaf += costForThisL1;
                    } 

                    updatesForThisLeaf[`${leafNodePath}/chiPhi`] = calculatedTotalChiPhiForLeaf;
                    currentLeafChiPhi = calculatedTotalChiPhiForLeaf; 

                } else {
                     // Nếu không có giải trình, giữ nguyên hoặc logic khác tùy ngữ cảnh
                     // Ở đây ta tập trung sửa lỗi tính toán khi CÓ giải trình
                }

                const chiPhiThucHien = leafNodeData.chiPhiThucHien || 0;
                const newKeHoachConLai = currentLeafChiPhi - chiPhiThucHien;
                 if (leafNodeData.keHoachConLai !== newKeHoachConLai || updatesForThisLeaf[`${leafNodePath}/chiPhi`] !== undefined) {
                      updatesForThisLeaf[`${leafNodePath}/keHoachConLai`] = newKeHoachConLai;
                 }
            }

            if (Object.keys(updatesForThisLeaf).length > 0) {
                await update(ref(db), updatesForThisLeaf);
            }
        } 

        const finalPathsArray = Array.from(pathsForParentRecalc);
        if (finalPathsArray.length > 0) {
             await recalculateCostsForParents(finalPathsArray);
        }

    } catch (innerError) {
         console.error(innerError);
    }
};
    
// Ensure checkAndUpdateDaThucHien is robust
   const checkAndUpdateDaThucHien = async (childPath) => {
        const childRef = ref(db, childPath);
        const childSnap = await get(childRef);
        if (!childSnap.exists()) return;

        const childData = childSnap.val();
        let hasExecutions = false;

        const findExecutions = async (node, currentPath) => {
            if (hasExecutions) return; 

            // Kiểm tra nút lá (Cấp 3 hoặc 4)
            const isPotentiallyLeaf = !(node.hasChildren === true || node.children || node.grandchildren || node.greatGrandchildren);

            if (isPotentiallyLeaf) {
                 const execRef = ref(db, `${currentPath}/executions`);
                 const execSnapshot = await get(execRef);
                 if (execSnapshot.exists() && Object.keys(execSnapshot.val()).length > 0) {
                    hasExecutions = true;
                    return;
                 }
            }

            // Kiểm tra Cấp 3 (nếu node hiện tại là cấp 2)
            if (node.grandchildren) {
                for (const id in node.grandchildren) {
                    const grandchildNodeSnap = await get(ref(db, `${currentPath}/grandchildren/${id}`));
                    if(grandchildNodeSnap.exists()) await findExecutions(grandchildNodeSnap.val(), `${currentPath}/grandchildren/${id}`);
                    if (hasExecutions) return;
                }
            }
            // Kiểm tra Cấp 4 (nếu node hiện tại là cấp 3)
            if (node.greatGrandchildren) {
                 for (const id in node.greatGrandchildren) {
                     // Cấp 4 là lá, kiểm tra trực tiếp
                     const execRef = ref(db, `${currentPath}/greatGrandchildren/${id}/executions`);
                     const execSnapshot = await get(execRef);
                     if (execSnapshot.exists() && Object.keys(execSnapshot.val()).length > 0) {
                        hasExecutions = true;
                        return;
                     }
                 }
            }
            // --- ĐÃ LOẠI BỎ greatGreatGrandchildren ---
        };

        await findExecutions(childData, childPath);

        if (childData.daThucHien !== hasExecutions) {
            await update(ref(db), { [`${childPath}/daThucHien`]: hasExecutions });
        }
     }; // <-- Đóng hàm checkAndUpdateDaThucHien ở đây

  const calculateSummaryData = async () => {
    try {
        statusDiv.className = 'success';
        statusDiv.innerText = 'Đang tính toán dữ liệu tổng hợp...';
        const parentQuery = ref(db, getParentCollectionName());
        const parentSnapshot = await get(parentQuery);
        
        if (!parentSnapshot.exists()) {
            const summaryRef = ref(db, `summary_data/${currentYear}`);
            await set(summaryRef, null); 
            statusDiv.innerText = ''; 
            document.getElementById('summarySection').innerHTML = '<p>Không có dữ liệu tổng hợp cho năm này.</p>';
            return; 
        }

        const parentsData = parentSnapshot.val();
        const summaryData = {};

        for (const parentId in parentsData) {
             summaryData[parentId] = {
                 totalLeafNodes: 0,
                 totalExecutedLeafNodes: 0,
                 totalLeafNodesCap1: 0,
                 totalExecutedLeafNodesCap1: 0,
                 totalPlannedCost: parentsData[parentId].chiPhi || 0, 
                 totalExecutedCost: parentsData[parentId].chiPhiThucHien || 0 
             };
        }

        const processNode = (node, path) => {
            if (node && node.tt) { 
                const parentId = path.split('/')[1];
                const parentSummary = summaryData[parentId]; 
                if (!parentSummary) return;

                const hasL4Children = node.greatGrandchildren && Object.keys(node.greatGrandchildren).length > 0;
                const hasL3Children = node.grandchildren && Object.keys(node.grandchildren).length > 0;
                const hasL2Children = node.children && Object.keys(node.children).length > 0;

                let isContainer = false;
                if (node.hasChildren === true) { isContainer = true; } 
                else if (node.hasChildren === false) { isContainer = false; } 
                else { isContainer = hasL2Children || hasL3Children || hasL4Children; }

                const pathLength = path.split('/').length;

                if (!isContainer && pathLength > 2) { 
                    let plannedCount;
                    const tanSuat = node.tanSuatTH;
                    if (tanSuat === 0) { plannedCount = 0; } 
                    else {
                         plannedCount = parseInt(tanSuat, 10);
                         if (isNaN(plannedCount) || tanSuat === null || tanSuat === undefined || tanSuat === '') {
                             plannedCount = 1;
                         }
                    }
                    parentSummary.totalLeafNodes += plannedCount;

                    let executedCount = 0;
                    const plannedCost = node.chiPhi || 0;

                    if (plannedCost === 0) {
                        if (node.executions) {
                            let validLinkCount = 0;
                            for (const key in node.executions) {
                                const exec = node.executions[key];
                                if (exec.hoSoLink && String(exec.hoSoLink).trim() !== '') {
                                    validLinkCount++;
                                }
                            }
                            executedCount = Math.min(plannedCount, validLinkCount);
                        }
                    } else {
                        if (plannedCount > 1) {
                            const actualExecutionCount = node.executions ? Object.keys(node.executions).length : 0;
                            executedCount = Math.min(plannedCount, actualExecutionCount);
                        } else if (plannedCount === 1) {
                            executedCount = node.chiPhiThucHien > 0 ? 1 : 0;
                        } 
                    }

                    parentSummary.totalExecutedLeafNodes += executedCount;
                    if (node.capDo == 1) {
                        parentSummary.totalLeafNodesCap1 += plannedCount;
                        parentSummary.totalExecutedLeafNodesCap1 += executedCount;
                    }
                }
            } 
            if (node.children) for (const k in node.children) processNode(node.children[k], `${path}/children/${k}`);
            if (node.grandchildren) for (const k in node.grandchildren) processNode(node.grandchildren[k], `${path}/grandchildren/${k}`);
            if (node.greatGrandchildren) for (const k in node.greatGrandchildren) processNode(node.greatGrandchildren[k], `${path}/greatGrandchildren/${k}`);
        };
        
        for (const parentId in parentsData) {
            processNode(parentsData[parentId], `${getParentCollectionName()}/${parentId}`);
        }

        // === [CẬP NHẬT MỚI]: Ghi cả Summary và Cập nhật tgBatDau cho Parent ===
        const updates = {};
        updates[`summary_data/${currentYear}`] = summaryData;
        
        for (const parentId in summaryData) {
            // Gán totalExecutedLeafNodesCap1 vào tgBatDau của task cha
            const val = summaryData[parentId].totalExecutedLeafNodesCap1 || 0;
            updates[`${getParentCollectionName()}/${parentId}/tgBatDau`] = val;
        }

        await update(ref(db), updates);
        // =====================================================================
        
        statusDiv.innerText = ''; 

    } catch (error) {
        console.error("Lỗi khi tính toán dữ liệu tổng hợp:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi khi tính toán summary: ${error.message}`;
    }
};


    async function ensureYearCollectionExists(year) {
        const collectionName = `congViecMe${year}`;
        try {
            const testQuery = ref(db, collectionName);
            const testSnapshot = await get(testQuery);
            if (!testSnapshot.exists()) {
                console.log(`Collection cho năm ${year} chưa tồn tại, sẽ được tạo khi có dữ liệu`);
            }
        } catch (error) {
            console.log(`Collection cho năm ${year} chưa tồn tại, sẽ được tạo khi có dữ liệu`);
        }
    }

    const planningPasswords = {
        'all': '2662', 'A': '8726', 'B': '8646', 'C': '8734',
        'D': '8663', 'E': '8853', 'F': '3822'
    };

    function openPlanningModeModal() {
        const modal = document.getElementById('planningModeModal');
        const optionsContainer = document.getElementById('planningModeOptions');
        optionsContainer.innerHTML = '';

        const allButton = document.createElement('button');
        allButton.className = 'btn-primary';
        allButton.textContent = 'Tất cả dữ liệu';
        allButton.style.cssText = 'width: 100%; margin-bottom: 10px; text-align: left; padding: 12px;';
        allButton.onclick = () => promptForPlanningPassword('all', 'Tất cả dữ liệu');
        optionsContainer.appendChild(allButton);

        const parentRows = document.querySelectorAll('.task-parent');
        parentRows.forEach(row => {
            const tt = row.querySelector('.col-tt').textContent;
            const noiDung = row.querySelector('.col-noidung').textContent;
            const parentButton = document.createElement('button');
            parentButton.className = 'btn-secondary';
            parentButton.textContent = `${tt}. ${noiDung}`;
            parentButton.style.cssText = 'width: 100%; margin-bottom: 10px; text-align: left; padding: 12px;';
            parentButton.onclick = () => promptForPlanningPassword(tt, `${tt}. ${noiDung}`);
            optionsContainer.appendChild(parentButton);
        });

        modal.style.display = 'block';
    }

    window.promptForPlanningPassword = function(selectionId, selectionText) {
        const correctPassword = planningPasswords[selectionId];
        if (!correctPassword) {
            activatePlanningModeForSelection(selectionId);
            return;
        }

        const enteredPassword = prompt(`Vui lòng nhập mật khẩu để xem phạm vi:\n"${selectionText}"`);

        if (enteredPassword === null) {
            return;
        }

        if (enteredPassword === correctPassword) {
            activatePlanningModeForSelection(selectionId);
        } else {
            alert('Mật khẩu không chính xác.');
        }
    };

    window.closePlanningModal = function() {
        document.getElementById('planningModeToggle').checked = false;
        document.getElementById('planningModeModal').style.display = 'none';
    }

    function activatePlanningModeForSelection(selectionId) {
        const taskList = document.getElementById('taskList');
        planningModeByYear[currentYear] = true;

        taskList.classList.add('planning-mode');
        document.getElementById('exportExcel1Btn').disabled = true;
        document.getElementById('exportExcel2Btn').disabled = false;

        const allRows = document.querySelectorAll('#taskListBody tr');
        allRows.forEach(row => {
            if (selectionId === 'all' || row.dataset.mainParent === selectionId) {
                row.style.display = '';
            } else {
                row.style.display = 'none';
            }
        });

        document.getElementById('planningModeModal').style.display = 'none';
    }

    
 // XỬ LÝ AUTH STATE
    onAuthStateChanged(auth, async (user) => {
        const authButton = document.getElementById('authButton');
        const logoutButton = document.getElementById('logoutButton');
        const titleEl = document.getElementById('mainHeaderTitle'); // Lấy thẻ tiêu đề

        if (user) {
            // --- TRƯỜNG HỢP: ĐÃ ĐĂNG NHẬP ---
            isAuthenticated = true;
            if (authButton) authButton.style.display = 'none';
            if (logoutButton) logoutButton.style.display = 'inline-block';

            loginContainer.style.display = 'none';
            mainContainer.style.display = 'block';

            statusDiv.className = 'success';
            statusDiv.innerText = 'Đăng nhập thành công. Đang tải dữ liệu...';

            // 1. Lắng nghe realtime: Để khi dữ liệu thay đổi thì tiêu đề tự đổi theo
            const tenCoSoRef = ref(db, 'settings/tenCoSo');
            onValue(tenCoSoRef, (snapshot) => {
                const name = snapshot.val();
                if (titleEl && name && String(name).trim() !== '') {
                    titleEl.textContent = String(name).toUpperCase();
                }
            });

            // 2. Kiểm tra xem tên có bị rỗng không. Chỉ hỏi KHI ĐÃ ĐĂNG NHẬP và DỮ LIỆU RỖNG
            try {
                const tenCoSoSnap = await get(tenCoSoRef);
                const currentName = tenCoSoSnap.val();
                
                // Logic: Nếu chưa có dữ liệu hoặc dữ liệu rỗng -> Mới hiện Prompt
                if (!tenCoSoSnap.exists() || !currentName || String(currentName).trim() === '') {
                    const newName = prompt("Hệ thống chưa có tên đơn vị. Vui lòng nhập TÊN ĐƠN VỊ để hiển thị (VD: CHI NHÁNH MIỀN BẮC):");
                    if (newName && newName.trim() !== '') {
                        await set(tenCoSoRef, newName.trim());
                        statusDiv.innerText = 'Đã cập nhật tên cơ sở.';
                    }
                }
            } catch (err) {
                console.error("Lỗi kiểm tra tên cơ sở:", err);
            }

            // 3. Các logic cài đặt khác (Giữ nguyên)
            
    const settingsRef = ref(db, 'settings/global');
    onValue(settingsRef, (snapshot) => {
        if (snapshot.exists()) {
            const val = snapshot.val();
            editModeStatusByYear = val.editModeStatus || {};
            lockedYears = val.lockedYears || {}; // [THÊM DÒNG NÀY]
        } else {
            editModeStatusByYear = {};
            lockedYears = {};
        }
        
        // Cập nhật giao diện Modal nếu đang mở
        const modal = document.getElementById('dataManagementModal');
        if (modal.style.display === 'block') {
             // Kiểm tra lại quyền admin để hiển thị
             const currentUser = auth.currentUser;
             if (currentUser && currentUser.email === "admin@pvgaslpg.com.vn") {
                 showAdminControls();
             }
        }
        updateButtonStates(); // Cập nhật lại các nút trên bảng chính
    });

            await recalculateAllCostsAndReload(false);

        } else {
            // --- TRƯỜNG HỢP: CHƯA ĐĂNG NHẬP ---
            isAuthenticated = false;
            if (authButton) authButton.style.display = 'inline-block';
            if (logoutButton) logoutButton.style.display = 'none';
            mainContainer.style.display = 'block';
            loginContainer.style.display = 'none';
            
            // 1. Chỉ cố gắng ĐỌC tên cơ sở để hiển thị (Không Prompt)
            try {
                const tenCoSoSnap = await get(ref(db, 'settings/tenCoSo'));
                if (tenCoSoSnap.exists() && tenCoSoSnap.val()) {
                     if (titleEl) titleEl.textContent = String(tenCoSoSnap.val()).toUpperCase();
                }
            } catch(e) {
                console.log("Khách chưa xem được tên cơ sở (có thể do rule bảo mật).");
            }

            fetchData();
        }
    });

    // XỬ LÝ LOGIN FORM
    loginForm.addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = document.getElementById('email').dataset.realEmail;
        const password = document.getElementById('password').value;
        const loginButton = loginForm.querySelector('button');
        loginError.style.display = 'none';
        loginButton.disabled = true;
        loginButton.textContent = 'Đang xử lý...';
        try {
            await signInWithEmailAndPassword(auth, email, password);
        } catch (error) {
            console.error("Lỗi đăng nhập:", error);
            let errorMessage = "Đã xảy ra lỗi. Vui lòng thử lại.";
            if (error.code === 'auth/invalid-credential') errorMessage = "Mật khẩu không chính xác.";
            loginError.textContent = errorMessage;
            loginError.style.display = 'block';
        } finally {
            loginButton.disabled = false;
            loginButton.textContent = 'Đăng nhập';
        }
    });

    // KHỞI TẠO ỨNG DỤNG
  // KHỞI TẠO ỨNG DỤNG
    window.addEventListener('DOMContentLoaded', async function() { // Thêm async ở đây
        // === THÊM ĐOẠN NÀY ĐỂ ĐĂNG XUẤT KHI TẢI TRANG ===
        try {
            await signOut(auth); // Thực hiện đăng xuất
            console.log('Đã tự động đăng xuất người dùng cũ (nếu có).');
        } catch (error) {
            console.error('Lỗi khi tự động đăng xuất:', error);
            // Bạn có thể thêm thông báo lỗi cho người dùng ở đây nếu cần
            // statusDiv.className = 'error';
            // statusDiv.innerText = 'Lỗi khi đăng xuất phiên cũ: ' + error.message;
        }
        // ===============================================

        // Các hàm khởi tạo khác
        initializeYearDropdown();
        // fetchData(); // Không gọi trực tiếp ở đây nữa, onAuthStateChanged sẽ xử lý
        initializeGoogleClients();

        // Gán sự kiện double click cho bảng (cho sửa nội tuyến)
        const taskListBody = document.getElementById('taskListBody');
        if (taskListBody) {
            taskListBody.addEventListener('dblclick', makeCellEditable);
        }

        // --- Quản lý việc chạy calculateSummaryData ---
        let summaryIntervalId = null; // Biến để lưu ID của interval

        // Hàm để bắt đầu tính summary và đặt lịch chạy định kỳ
        function startSummaryInterval() {
             if (summaryIntervalId) clearInterval(summaryIntervalId); // Xóa interval cũ nếu đang chạy
             // Chạy tính toán lần đầu (nên đợi fetchData xong)
             // calculateSummaryData(); // Chạy ngay có thể gây lỗi nếu fetchData chưa xong
             // Đặt lịch chạy định kỳ 5 phút một lần
             summaryIntervalId = setInterval(calculateSummaryData, 300000);
        }

        // Hàm dừng tính summary định kỳ (ví dụ khi đăng xuất)
        function stopSummaryInterval() {
            if (summaryIntervalId) {
                clearInterval(summaryIntervalId);
                summaryIntervalId = null;
            }
        }
        // --- Kết thúc quản lý calculateSummaryData ---


        // Gọi startSummaryInterval hoặc các xử lý khác sau khi dữ liệu được tải
        // (thông qua onAuthStateChanged)

    }); // Kết thúc DOMContentLoaded


    // XỬ LÝ AUTH STATE (Vẫn giữ nguyên hàm này để xử lý sau khi signOut chạy xong)
    onAuthStateChanged(auth, user => {
        const authButton = document.getElementById('authButton');
        const logoutButton = document.getElementById('logoutButton');

        if (user) {
            // Người dùng đăng nhập (Trường hợp này sẽ không xảy ra ngay sau khi tải trang vì đã signOut)
            isAuthenticated = true;
            if (authButton) authButton.style.display = 'none';
            if (logoutButton) logoutButton.style.display = 'inline-block';

            loginContainer.style.display = 'none';
            mainContainer.style.display = 'block';

            const settingsRef = ref(db, 'settings/global');
            onValue(settingsRef, (snapshot) => {
                if (snapshot.exists()) {
                    editModeStatusByYear = snapshot.val().editModeStatus || {};
                } else {
                    editModeStatusByYear = {};
                }
                updateButtonStates();
            });
            // Tải dữ liệu và sau đó bắt đầu tính summary
            fetchData().then(() => {
                // Có thể gọi calculateSummaryData() lần đầu ở đây nếu muốn
                // calculateSummaryData();
                // startSummaryInterval(); // Bắt đầu chạy định kỳ
            });
        } else {
            // Người dùng đã đăng xuất (Đây là trạng thái sau khi signOut trong DOMContentLoaded chạy)
            isAuthenticated = false;
            if (authButton) authButton.style.display = 'inline-block';
            if (logoutButton) logoutButton.style.display = 'none';

            mainContainer.style.display = 'block';
            loginContainer.style.display = 'none';
            // Vẫn tải dữ liệu ở chế độ chỉ xem
            fetchData().then(() => {
                 // Có thể gọi calculateSummaryData() lần đầu ở đây nếu muốn
                 // calculateSummaryData();
                 // startSummaryInterval(); // Bắt đầu chạy định kỳ (nếu cần xem summary khi chưa đăng nhập)
            });
            updateButtonStates(); // Cập nhật trạng thái nút (sẽ vô hiệu hóa các nút sửa/xóa)
            // stopSummaryInterval(); // Dừng tính summary định kỳ nếu không cần khi đăng xuất
        }
    });

 

/**
 * Biến một ô <td> thành <TEXTAREA> hay <INPUT> để chỉnh sửa nội tuyến.
 */
/**
 * Xử lý sự kiện nhấn phím Enter (lưu) và Escape (hủy)
 */
function handleInputKeydown(event) {
    // Nếu là ô nhập nhiều dòng (TEXTAREA)
    if (event.target.tagName === 'TEXTAREA') {
        if (event.key === 'Enter') {
            // Cho phép Enter xuống dòng bình thường (không preventDefault)
            // Nếu muốn Enter để lưu thì người dùng phải click ra ngoài (Blur)
            return; 
        }
        if (event.key === 'Escape') {
            event.preventDefault();
            event.target.value = event.target.dataset.originalValue;
            event.target.blur(); // Hủy và trả lại giá trị cũ
        }
    } 
    // Nếu là ô nhập thường (INPUT)
    else {
        if (event.key === 'Enter') {
            event.preventDefault();
            event.target.blur(); // Lưu
        } else if (event.key === 'Escape') {
            event.preventDefault();
            event.target.value = event.target.dataset.originalValue;
            event.target.blur(); // Hủy
        }
    }
}

/**
 * Hàm sửa nội tuyến nâng cấp: Hỗ trợ Input, Textarea và Select (cho TagName)
 */
async function makeCellEditable(event) { // Thêm async để chờ load danh sách
    const td = event.target.closest('.editable-cell');
    if (!td) return;

    // Kiểm tra quyền sửa đổi
    if (!isAuthenticated || editModeStatusByYear[currentYear] !== true) {
        showAuthError();
        return;
    }

    // Ngăn tạo lại nếu đang sửa
    if (td.querySelector('.editable-input')) return;

    const tr = td.closest('tr');
    const path = tr.dataset.path;
    const field = td.dataset.field;
    
    if (!path || !field) return;

    const originalValue = td.innerText.trim();
    let input;

    // === [LOGIC MỚI CHO TAG NAME] ===
    if (field === 'tagName') {
        // Tải danh sách nếu chưa có (Lazy loading)
        await loadEquipmentList(); 

        input = document.createElement('select');
        input.className = 'editable-input';
        
        // Tạo option mặc định
        let optionsHtml = '<option value="">-- Chọn Tag --</option>';
        
        if (cachedEquipmentList && cachedEquipmentList.length > 0) {
            let found = false;
            cachedEquipmentList.forEach(item => {
                const isSelected = originalValue === item.tag;
                if (isSelected) found = true;
                optionsHtml += `<option value="${item.tag}" ${isSelected ? 'selected' : ''}>${item.tag} - ${item.name}</option>`;
            });
            
            // Nếu giá trị cũ không nằm trong danh sách
            if (originalValue && !found) {
                 optionsHtml = `<option value="${originalValue}" selected style="color:red">${originalValue} (Chưa chuẩn hóa)</option>` + optionsHtml;
            }
        } else {
             // Fallback nếu không có danh sách
             optionsHtml = `<option value="${originalValue}" selected>${originalValue}</option>`;
        }
        
        input.innerHTML = optionsHtml;
        
        // CSS riêng cho select để đẹp hơn
        input.style.width = '100%';
        input.style.padding = '4px';
    }
    // === [KẾT THÚC LOGIC TAG NAME] ===

    else if (['ghiChu', 'noiDung'].includes(field)) {
        // Logic cũ cho Textarea
        input = document.createElement('textarea');
        input.className = 'editable-input';
        input.value = originalValue;
        input.spellcheck = false; 
        input.style.width = '98%';
        input.style.minHeight = '30px';
        input.style.resize = 'vertical';
        input.style.overflowY = 'hidden';
        input.style.lineHeight = '1.4';
        
        input.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = (this.scrollHeight) + 'px';
        });
    } else {
        // Logic cũ cho Input thường
        input = document.createElement('input');
        input.type = 'text';
        input.className = 'editable-input';
        input.value = originalValue;
        input.spellcheck = false; 
    }
    
    // Gán dữ liệu chung
    input.dataset.path = path;
    input.dataset.field = field;
    input.dataset.originalValue = originalValue;

    // Gán sự kiện
    input.onblur = saveInlineEdit; 
    input.onkeydown = handleInputKeydown;

    // Hiển thị
    td.innerHTML = '';
    td.appendChild(input);

    if (input.tagName === 'TEXTAREA') {
        input.style.height = 'auto';
        input.style.height = (input.scrollHeight) + 'px';
    }

    input.focus();
    // Chỉ bôi đen nếu là input text (select không có hàm select())
    if (input.select) input.select();
}



/**
 * Lưu hoặc hủy bỏ chỉnh sửa nội tuyến (CHỈ CHẠY KHI BLUR).
 * Đã nâng cấp để xử lý Năm phân bổ và Thực hiện năm trước.
 */
/**
 * Lưu hoặc hủy bỏ chỉnh sửa nội tuyến (CHỈ CHẠY KHI BLUR).
 * Đã nâng cấp để xử lý Năm phân bổ mặc định = 1.
 */
async function saveInlineEdit(event) {
    const input = event.target;
    if (!input.parentNode) return; 

    const td = input.closest('td');
    if (!td) return;

    const path = input.dataset.path;
    const field = input.dataset.field;
    const originalValue = input.dataset.originalValue;
    const newValue = input.value;

    if (newValue === originalValue) {
        td.innerHTML = originalValue; 
        return;
    }

    try {
        td.innerHTML = '<i>Đang lưu...</i>';
        const updates = {};
        let valueToSave = newValue;
        let formattedDisplay = newValue;

        if (['namPhanBo', 'thucHienNamTruoc', 'soLuong', 'donGia'].includes(field)) {
            valueToSave = parseFormattedNumber(newValue); 
            
            // === CẬP NHẬT: Mặc định namPhanBo = 1 ===
            if (field === 'namPhanBo') {
                if (newValue.trim() === '' || valueToSave == 0) valueToSave = 1;
                formattedDisplay = valueToSave;
            } else {
                formattedDisplay = formatNumber(valueToSave);
            }
            // =========================================
        }

        updates[`${path}/${field}`] = valueToSave;

        if (field === 'namPhanBo') {
            const nodeSnap = await get(ref(db, path));
            if (nodeSnap.exists()) {
                const nodeData = nodeSnap.val();
                const chiPhi = nodeData.chiPhi || 0;
                const nam = valueToSave; 
                
                const cpPb = (nam > 0) ? Math.round(chiPhi / nam) : 0;
                updates[`${path}/chiPhiPhanBo`] = cpPb;

                const tr = td.closest('tr');
                const cpPbCell = tr.querySelector('.col-chiphi-phanbo');
                if (cpPbCell) {
                    cpPbCell.textContent = formatNumber(cpPb);
                    cpPbCell.style.backgroundColor = '#ffffcc';
                    setTimeout(() => cpPbCell.style.backgroundColor = '', 1000);
                }
            }
        }

        await update(ref(db), updates);
        td.innerHTML = formattedDisplay;

    } catch (error) {
        console.error("Lỗi khi cập nhật nội tuyến:", error);
        statusDiv.className = 'error';
        statusDiv.innerText = `Lỗi: ${error.message}`;
        try { td.innerHTML = originalValue; } catch (e) {}
    }
}

// HÀM FETCHDATA CHÍNH (cần được định nghĩa sau cùng vì phụ thuộc vào nhiều hàm khác)
 window.fetchData = async function() {
    // 1. LƯU VỊ TRÍ CUỘN HIỆN TẠI
    const currentScrollPosition = window.scrollY;

    const tableBody = document.getElementById('taskListBody');
    // Xóa map dữ liệu cũ để nạp mới
    docDataMap.clear(); 
    
    try {
        await ensureYearCollectionExists(currentYear);

        // 1. Tải Link Hồ sơ (Execution Links)
        const hoSoLinksMap = new Map();
        const executionQuery = ref(db, `${getParentCollectionName()}`);
        const executionSnapshot = await get(executionQuery);
        
        if (executionSnapshot.exists()) {
            const processNodeForLinks = (node, path) => {
                if (node.executions) {
                    for (const execId in node.executions) {
                        const exec = node.executions[execId];
                        if (exec.hoSoLink) {
                            if (!hoSoLinksMap.has(path)) hoSoLinksMap.set(path, new Set());
                            hoSoLinksMap.get(path).add(exec.hoSoLink);
                        }
                    }
                }
                if (node.children) for (const k in node.children) processNodeForLinks(node.children[k], `${path}/children/${k}`);
                if (node.grandchildren) for (const k in node.grandchildren) processNodeForLinks(node.grandchildren[k], `${path}/grandchildren/${k}`);
                if (node.greatGrandchildren) for (const k in node.greatGrandchildren) processNodeForLinks(node.greatGrandchildren[k], `${path}/greatGrandchildren/${k}`);
            };
            const data = executionSnapshot.val();
            for (const parentId in data) processNodeForLinks(data[parentId], `${getParentCollectionName()}/${parentId}`);
        }

        // 2. Tải dữ liệu Summary
        const summaryRef = ref(db, `summary_data/${currentYear}`);
        const summarySnap = await get(summaryRef);
        const summaryData = summarySnap.exists() ? summarySnap.val() : {};

        // 3. Tải dữ liệu chính
        let html = '';
        let totalPlannedCost = 0, totalExecutedCost = 0;

        const parentSnapshot = await get(ref(db, getParentCollectionName()));
        if (!parentSnapshot.exists()) {
            tableBody.innerHTML = `<tr><td colspan="17" style="text-align: center;">Không có dữ liệu cho năm ${currentYear}.</td></tr>`;
            document.getElementById('summarySection').innerHTML = '';
            return;
        }
        
        parentNoiDungMap.clear();
        const parentsData = parentSnapshot.val();
        const parents = Object.keys(parentsData).map(id => ({ id, ...parentsData[id] }));
        parents.sort((a, b) => a.id.localeCompare(b.id));

        const getDisplayChiPhiForJustification = (justData) => {
            if (justData.hasSubJustifications && justData.subJustifications) {
                let sum = 0;
                for (const key in justData.subJustifications) sum += (justData.subJustifications[key].chiPhi || 0);
                return sum;
            }
            return justData.chiPhi || 0;
        };

        const getLevelSpecificActions = (level, path, data) => {
            if (level === 'parent') return `<a href="javascript:void(0)" onclick="openAddModal('${path}', 'child')">Thêm Hệ thống thiết bị/Hạng mục</a>`;
            if (level === 'child') return `<a href="javascript:void(0)" onclick="openAddModal('${path}', 'grandchild')">Thêm thiết bị/Nhóm công việc</a>`;
            
            if (level === 'grandchild') {
                const hasJustifications = data && data.justifications && Object.keys(data.justifications).length > 0;
                // Logic cũ: data.hasChildren (có thể sai). 
                // Logic mới: Kiểm tra trực tiếp greatGrandchildren
                const hasTaskChildren = data && data.greatGrandchildren && Object.keys(data.greatGrandchildren).length > 0;

                if (hasJustifications) {
                    return `<a href="javascript:void(0)" onclick="openAddModal('${path}', 'justification')">Thêm giải trình</a>`;
                } else if (hasTaskChildren) {
                        return `<a href="javascript:void(0)" onclick="openAddModal('${path}', 'greatGrandchild')">Thêm vật tư/Đầu công việc</a>`;
                } else {
                    return `<a href="javascript:void(0)" onclick="openAddModal('${path}', 'greatGrandchild')">Thêm vật tư/Đầu công việc</a>
                            <a href="javascript:void(0)" onclick="openAddModal('${path}', 'justification')">Thêm giải trình</a>`;
                }
            }
            
            if (level === 'greatGrandchild') return `<a href="javascript:void(0)" onclick="openAddModal('${path}', 'justification')">Thêm giải trình</a>`;
            return '';
        };

        const createRowHtml = (itemClass, path, data) => {
            const isParentLeaf = itemClass.includes('is-parent-leaf');
            const isCheckbox = !itemClass.includes('task-parent');
            
            let hoSoBtn = '';
            const links = hoSoLinksMap.get(path);
            if (links && links.size > 0) {
                const linksJson = JSON.stringify(Array.from(links));
                hoSoBtn = `<button class="btn-info btn-action" data-links='${linksJson}' onclick="showLinks(event)">Có</button>`;
            }
            const noiDungStyle = data.chiPhiThucHien > 0 ? 'style="color: #5B77A8;"' : '';
            let levelName = 'child';
            if (itemClass.includes('task-parent')) levelName = 'parent';
            else if (itemClass.includes('task-child')) levelName = 'child';
            else if (itemClass.includes('task-grandchild')) levelName = 'grandchild';
            else if (itemClass.includes('task-great-grandchild')) levelName = 'greatGrandchild';

            const displayTanSuat = (data.tanSuatTH === 0) ? '-' : (data.tanSuatTH || '');

                        return `<tr class="${itemClass}" data-main-parent="${mainParentId}" data-path="${path}">
                <td>${isCheckbox ? `<input type="checkbox" class="${isParentLeaf ? 'parent-checkbox' : 'task-checkbox'}" data-path="${path}" onchange="${isParentLeaf ? 'toggleChildrenCheckboxes(this)' : 'toggleSelection(this)'}">` : ''}</td>
                <td class="col-tt">${convertTTForDisplay(data.tt)}</td>
                <td class="col-noidung" ${noiDungStyle}>${data.noiDung}</td>
                
                <td class="col-tagname ${itemClass.includes('task-grandchild') ? 'editable-cell' : ''}" ${itemClass.includes('task-grandchild') ? 'data-field="tagName"' : ''}>
                    ${itemClass.includes('task-grandchild') ? (data.tagName || '') : ''}
                </td>
                <td class="col-dv-thuchien editable-cell" data-field="dvThucHien">${data.dvThucHien || ''}</td>
                <td class="text-right col-kh-nam-truoc">${formatNumber(data.khNamTruoc)}</td>
                <td class="text-right col-th-nam-truoc editable-cell" data-field="thucHienNamTruoc">${formatNumber(data.thucHienNamTruoc)}</td>
                <td class="col-donvi editable-cell" data-field="donVi">${data.donVi || ''}</td>
                <td class="col-soluong">${data.soLuong || ''}</td>
                <td class="col-tansuat-th" style="text-align: center;">${displayTanSuat}</td>
                <td class="text-right col-chiphi">${formatNumber(data.chiPhi)}</td>
                <td class="text-right col-chiphi-thuchien">${formatNumber(data.chiPhiThucHien)}</td>
                <td class="text-right col-kehoach-conlai">${formatNumber(data.keHoachConLai)}</td>
                <td class="col-nam-phanbo editable-cell" data-field="namPhanBo">${data.namPhanBo || ''}</td>
                <td class="col-chiphi-phanbo">${formatNumber(data.chiPhiPhanBo)}</td>
                <td class="col-capdo editable-cell" data-field="capDo">${data.capDo || ''}</td>
			<td class="col-cp-cap1">${formatNumber(data.cpCap1)}</td>	
                <td class="col-tg-batdau editable-cell" data-field="tgBatDau">${data.tgBatDau || ''}</td>
                <td class="col-tg-hoanthanh editable-cell" data-field="tgHoanThanh">${data.tgHoanThanh || ''}</td>
                <td class="col-ghichu editable-cell" data-field="ghiChu">${data.ghiChu || ''}</td>
                <td class="col-hoso">${hoSoBtn}</td>
                <td class="col-action">
                    <div class="dropdown">
                        <button onclick="toggleDropdown(event)" class="btn-secondary btn-action dropbtn">Thêm/sửa</button>
                        <div class="dropdown-content">
                            ${getLevelSpecificActions(levelName, path, data)}
                            <a href="javascript:void(0)" onclick="handleEditClick('${path}', '${levelName}')">Sửa Nội dung</a>
                        </div>
                    </div>
                </td>
            </tr>`;

        };

        for (const parentData of parents) {
            parentNoiDungMap.set(parentData.id, parentData.noiDung);
            var mainParentId = parentData.tt; 
            const parentSummary = summaryData[parentData.id] || {};
            parentData.soLuong = parentSummary.totalLeafNodesCap1 || 0;
parentData.tgBatDau = parentSummary.totalExecutedLeafNodesCap1 || 0;
            totalPlannedCost += parentData.chiPhi || 0;
            totalExecutedCost += parentData.chiPhiThucHien || 0;
            const parentPath = `${getParentCollectionName()}/${parentData.id}`;
            
            html += createRowHtml('task-parent', parentPath, parentData);

            if (parentData.children) {
                const children = Object.keys(parentData.children).map(id => ({ id, ...parentData.children[id] })).sort(childSort);
                for (const childData of children) {
                    const childPath = `${parentPath}/children/${childData.id}`;
                    docDataMap.set(childPath, childData);
                    if (!childData.isHidden) html += createRowHtml('task-child', childPath, childData);
                    
                    if (childData.grandchildren) {
                        const grandchildren = Object.keys(childData.grandchildren).map(id => ({ id, ...childData.grandchildren[id] })).sort((a, b) => parseInt(a.id, 10) - parseInt(b.id, 10));
                        for (const grandchildData of grandchildren) {
                            const grandchildPath = `${childPath}/grandchildren/${grandchildData.id}`;
                            
                            // === [QUAN TRỌNG] SỬA LỖI LOGIC LÁ CẤP 3 ===
                            // Kiểm tra thực tế xem có con cấp 4 không
                            const hasLevel4Children = grandchildData.greatGrandchildren && Object.keys(grandchildData.greatGrandchildren).length > 0;
                            
                            // Cập nhật lại cờ hasChildren trong bộ nhớ (docDataMap) để openMultiExecutionModal hiểu đúng
                            // Nếu không có con cấp 4, nó là Lá (hasChildren = false), bất kể DB nói gì
                            grandchildData.hasChildren = hasLevel4Children;
                            
                            docDataMap.set(grandchildPath, grandchildData);

                            // Xác định class hiển thị: Nếu KHÔNG có con cấp 4 -> là parent-leaf (chữ thường)
                            const isGCParent = hasLevel4Children;
                            const gcClass = `task-grandchild ${!isGCParent ? 'is-parent-leaf' : ''}`;
                            html += createRowHtml(gcClass, grandchildPath, grandchildData);
                            // ===============================================

                            if (grandchildData.greatGrandchildren) {
                                const greatGrandchildren = Object.keys(grandchildData.greatGrandchildren).map(id => ({ id, ...grandchildData.greatGrandchildren[id] })).sort(numericSort);
                                for (const greatGrandchildData of greatGrandchildren) {
                                    const greatGrandchildPath = `${grandchildPath}/greatGrandchildren/${greatGrandchildData.id}`;
                                    docDataMap.set(greatGrandchildPath, greatGrandchildData);
                                    const rowClass = `task-great-grandchild is-parent-leaf`; 
                                    html += createRowHtml(rowClass, greatGrandchildPath, greatGrandchildData);

                                    // Render Giải trình Cấp 4 (GreatGrandchild)
                                    if (greatGrandchildData.justifications) {
                                        const justifications = Object.keys(greatGrandchildData.justifications).map(id => ({ 
                                            id, path: `${greatGrandchildPath}/justifications/${id}`, ...greatGrandchildData.justifications[id] 
                                        })).sort((a, b) => (a.tt || '').localeCompare((b.tt || ''), 'en', { numeric: true }));
                                        for (const justData of justifications) {
                                             const displayCost = getDisplayChiPhiForJustification(justData);
                                             const chiPhiStyle = justData.hasSubJustifications ? 'font-weight: bold; font-style: italic;' : '';
                                             html += `<tr class="task-justification task-justification-parent" data-main-parent="${mainParentId}" data-path="${justData.path}">
                                                <td><input type="checkbox" class="justification-checkbox ${justData.hasSubJustifications ? 'parent-checkbox' : ''}" data-path="${justData.path}" data-parent-path="${greatGrandchildPath}" onchange="${justData.hasSubJustifications ? 'toggleChildrenCheckboxes(this)' : 'toggleSelection(this)'}"></td>
                                                <td class="col-tt">${convertTTForDisplay(justData.tt)}</td>
                                                <td class="col-noidung">${justData.noiDung}</td>
                                                <td class="col-dv-thuchien"></td><td class="text-right col-kh-nam-truoc"></td><td class="text-right col-th-nam-truoc"></td>
                                                <td class="col-donvi editable-cell" data-field="donVi">${justData.donVi || ''}</td>
                                                <td class="col-soluong">${justData.soLuong || ''}</td>
                                                <td class="col-tansuat-th"></td>
                                                <td class="text-right col-chiphi" style="${chiPhiStyle}">${formatNumber(displayCost)}</td>
                                                <td class="text-right col-chiphi-thuchien"></td><td class="text-right col-kehoach-conlai"></td>
                                                <td class="col-nam-phanbo"></td><td class="col-chiphi-phanbo"></td>
                                                <td class="col-capdo"></td>
										<td class="col-cp-cap1"></td> 		
												<td class="col-tg-batdau"></td><td class="col-tg-hoanthanh"></td>
                                                <td class="col-ghichu editable-cell" data-field="ghiChu">${justData.ghiChu || ''}</td>
                                                <td class="col-hoso"></td>
                                                <td class="col-action"><div class="dropdown"><button onclick="toggleDropdown(event)" class="btn-secondary btn-action dropbtn">Thêm/sửa</button><div class="dropdown-content">
                                                <a href="javascript:void(0)" onclick="openAddModal('${justData.path}', 'subJustification')">Thêm GT con</a><a href="javascript:void(0)" onclick="handleEditClick('${justData.path}', 'justification')">Sửa giải trình</a></div></div></td>
                                            </tr>`;
                                            
                                            if (justData.hasSubJustifications && justData.subJustifications) {
                                                 const subJustifications = Object.keys(justData.subJustifications).map(subId => ({ id: subId, path: `${justData.path}/subJustifications/${subId}`, ...justData.subJustifications[subId] })).sort((a, b) => (a.tt || '').localeCompare((b.tt || ''), 'en', { numeric: true }));
                                                 for (const subJust of subJustifications) {
                                                     html += `<tr class="task-justification task-justification-child" data-main-parent="${mainParentId}" data-path="${subJust.path}">
                                                        <td><input type="checkbox" class="justification-checkbox" data-path="${subJust.path}" data-parent-path="${justData.path}" onchange="toggleSelection(this)"></td>
                                                        <td class="col-tt">${convertTTForDisplay(subJust.tt)}</td>
                                                        <td class="col-noidung" style="padding-left: 40px; font-style: italic;">${subJust.noiDung}</td>
                                                        <td class="col-dv-thuchien"></td><td class="text-right col-kh-nam-truoc"></td><td class="text-right col-th-nam-truoc"></td>
                                                        <td class="col-donvi editable-cell" data-field="donVi">${subJust.donVi || ''}</td>
                                                        <td class="col-soluong">${subJust.soLuong || ''}</td>
                                                        <td class="col-tansuat-th"></td>
                                                        <td class="text-right col-chiphi">${formatNumber(subJust.chiPhi || 0)}</td>
                                                        <td class="text-right col-chiphi-thuchien"></td><td class="text-right col-kehoach-conlai"></td>
                                                        <td class="col-nam-phanbo"></td><td class="col-chiphi-phanbo"></td>
                                                        <td class="col-capdo"></td>
													<td class="col-cp-cap1"></td> 	
														<td class="col-tg-batdau"></td><td class="col-tg-hoanthanh"></td>
                                                        <td class="col-ghichu editable-cell" data-field="ghiChu">${subJust.ghiChu || ''}</td>
                                                        <td class="col-hoso"></td>
                                                        <td class="col-action"><button class="btn-secondary btn-action btn-edit-leaf" onclick="handleEditClick('${subJust.path}', 'subJustification')">Sửa</button></td>
                                                    </tr>`;
                                                 }
                                            }
                                        }
                                    }
                                }
                            }
                            
                            // Render Giải trình Cấp 3 (Grandchild - khi là lá hoặc cha)
                            if (grandchildData.justifications) {
                                const justifications = Object.keys(grandchildData.justifications).map(id => ({ 
                                    id, path: `${grandchildPath}/justifications/${id}`, ...grandchildData.justifications[id] 
                                })).sort((a, b) => (a.tt || '').localeCompare((b.tt || ''), 'en', { numeric: true }));
                                
                                for (const justData of justifications) {
                                     const displayCost = getDisplayChiPhiForJustification(justData);
                                     const chiPhiStyle = justData.hasSubJustifications ? 'font-weight: bold; font-style: italic;' : '';
                                     html += `<tr class="task-justification task-justification-parent" data-main-parent="${mainParentId}" data-path="${justData.path}">
                                        <td><input type="checkbox" class="justification-checkbox ${justData.hasSubJustifications ? 'parent-checkbox' : ''}" data-path="${justData.path}" data-parent-path="${grandchildPath}" onchange="${justData.hasSubJustifications ? 'toggleChildrenCheckboxes(this)' : 'toggleSelection(this)'}"></td>
                                        <td class="col-tt">${convertTTForDisplay(justData.tt)}</td>
                                        <td class="col-noidung">${justData.noiDung}</td>
                                        <td class="col-dv-thuchien"></td><td class="text-right col-kh-nam-truoc"></td><td class="text-right col-th-nam-truoc"></td>
                                        <td class="col-donvi editable-cell" data-field="donVi">${justData.donVi || ''}</td>
                                        <td class="col-soluong">${justData.soLuong || ''}</td>
                                        <td class="col-tansuat-th"></td>
                                        <td class="text-right col-chiphi" style="${chiPhiStyle}">${formatNumber(displayCost)}</td>
                                        <td class="text-right col-chiphi-thuchien"></td><td class="text-right col-kehoach-conlai"></td>
                                        <td class="col-nam-phanbo"></td><td class="col-chiphi-phanbo"></td>
                                        <td class="col-capdo"></td><td class="col-tg-batdau"></td><td class="col-tg-hoanthanh"></td>
                                        <td class="col-ghichu editable-cell" data-field="ghiChu">${justData.ghiChu || ''}</td>
                                        <td class="col-hoso"></td>
                                        <td class="col-action"><div class="dropdown"><button onclick="toggleDropdown(event)" class="btn-secondary btn-action dropbtn">Thêm/sửa</button><div class="dropdown-content">
                                        <a href="javascript:void(0)" onclick="openAddModal('${justData.path}', 'subJustification')">Thêm GT con</a><a href="javascript:void(0)" onclick="handleEditClick('${justData.path}', 'justification')">Sửa giải trình</a></div></div></td>
                                    </tr>`;
                                    
                                    if (justData.hasSubJustifications && justData.subJustifications) {
                                         const subJustifications = Object.keys(justData.subJustifications).map(subId => ({ id: subId, path: `${justData.path}/subJustifications/${subId}`, ...justData.subJustifications[subId] })).sort((a, b) => (a.tt || '').localeCompare((b.tt || ''), 'en', { numeric: true }));
                                         for (const subJust of subJustifications) {
                                             html += `<tr class="task-justification task-justification-child" data-main-parent="${mainParentId}" data-path="${subJust.path}">
                                                <td><input type="checkbox" class="justification-checkbox" data-path="${subJust.path}" data-parent-path="${justData.path}" onchange="toggleSelection(this)"></td>
                                                <td class="col-tt">${convertTTForDisplay(subJust.tt)}</td>
                                                <td class="col-noidung" style="padding-left: 40px; font-style: italic;">${subJust.noiDung}</td>
                                                <td class="col-dv-thuchien"></td><td class="text-right col-kh-nam-truoc"></td><td class="text-right col-th-nam-truoc"></td>
                                                <td class="col-donvi editable-cell" data-field="donVi">${subJust.donVi || ''}</td>
                                                <td class="col-soluong">${subJust.soLuong || ''}</td>
                                                <td class="col-tansuat-th"></td>
                                                <td class="text-right col-chiphi">${formatNumber(subJust.chiPhi || 0)}</td>
                                                <td class="text-right col-chiphi-thuchien"></td><td class="text-right col-kehoach-conlai"></td>
                                                <td class="col-nam-phanbo"></td><td class="col-chiphi-phanbo"></td>
                                                <td class="col-capdo"></td><td class="col-tg-batdau"></td><td class="col-tg-hoanthanh"></td>
                                                <td class="col-ghichu editable-cell" data-field="ghiChu">${subJust.ghiChu || ''}</td>
                                                <td class="col-hoso"></td>
                                                <td class="col-action"><button class="btn-secondary btn-action btn-edit-leaf" onclick="handleEditClick('${subJust.path}', 'subJustification')">Sửa</button></td>
                                            </tr>`;
                                         }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        tableBody.innerHTML = html || `<tr><td colspan="17" style="text-align: center;">Không có dữ liệu cho năm ${currentYear}.</td></tr>`;

        let summaryTotalLeafNodes = 0;
        let summaryTotalExecutedLeafNodes = 0;
        let summaryTotalLeafNodesCap1 = 0;
        let summaryTotalExecutedLeafNodesCap1 = 0;

        for (const parentId in summaryData) {
            const parentSummary = summaryData[parentId];
            summaryTotalLeafNodes += parentSummary.totalLeafNodes || 0;
            summaryTotalExecutedLeafNodes += parentSummary.totalExecutedLeafNodes || 0;
            summaryTotalLeafNodesCap1 += parentSummary.totalLeafNodesCap1 || 0;
            summaryTotalExecutedLeafNodesCap1 += parentSummary.totalExecutedLeafNodesCap1 || 0;
        }

        const leafNodePercentage = summaryTotalLeafNodes > 0 ? Math.round((summaryTotalExecutedLeafNodes / summaryTotalLeafNodes) * 100) : 0;
        const costPercentage = totalPlannedCost > 0 ? Math.round((totalExecutedCost / totalPlannedCost) * 100) : 0;
        const cap1Percentage = summaryTotalLeafNodesCap1 > 0 ? Math.round((summaryTotalExecutedLeafNodesCap1 / summaryTotalLeafNodesCap1) * 100) : 0;

        const summaryHtml = `
            <button class="btn-info" style="position: absolute; top: 10px; right: 10px; padding: 5px 10px; font-size: 14px;" onclick="openSummaryDetailModal()">Xem chi tiết các đơn vị</button>
            <div class="summary-column">
                <p><strong>Tổng số đầu việc chi tiết trong kế hoạch:</strong> ${summaryTotalLeafNodes}</p>
                <p><strong>Tổng số đầu việc cấp độ 1 cần thực hiện:</strong> ${summaryTotalLeafNodesCap1}</p>
                <p><strong>Tổng chi phí theo kế hoạch:</strong> ${formatNumber(totalPlannedCost)}</p>
            </div>
            <div class="summary-column">
                <p><strong>Số đầu việc chi tiết đã thực hiện:</strong> ${summaryTotalExecutedLeafNodes} <span class=\"percentage\">(${leafNodePercentage}%)</span></p>
                <p><strong>Số đầu việc cấp độ 1 đã thực hiện:</strong> ${summaryTotalExecutedLeafNodesCap1} <span class=\"percentage\">(${cap1Percentage}%)</span></p>
                <p><strong>Tổng chi phí đã thực hiện:</strong> ${formatNumber(totalExecutedCost)} <span class=\"percentage\">(${costPercentage}%)</span></p>
            </div>`;

        document.getElementById('summarySection').innerHTML = summaryHtml;
        
        const taskList = document.getElementById('taskList');
        if (planningModeByYear[currentYear] === true) {
            taskList.classList.add('planning-mode');
            document.getElementById('exportExcel1Btn').disabled = true;
            document.getElementById('exportExcel2Btn').disabled = false;
        } else {
            taskList.classList.remove('planning-mode');
            document.getElementById('exportExcel1Btn').disabled = false;
            document.getElementById('exportExcel2Btn').disabled = true;
        }

        selectedTasks.clear();
        selectedJustifications.clear();
        updateButtonStates();
        statusDiv.innerText = '';

        // 2. KHÔI PHỤC VỊ TRÍ CUỘN
        if (currentScrollPosition > 0) {
            window.scrollTo(0, currentScrollPosition);
        }

    } catch (error) { 
        console.error("Lỗi tải dữ liệu: ", error); 
        tableBody.innerHTML = `<tr><td colspan="17" style="text-align: center; color: red;">Lỗi tải dữ liệu: ${error.message}</td></tr>`; 
    }
};
	
	
 /**
     * HÀM HỖ TRỢ: ĐIỀU HƯỚNG BẰNG PHÍM MŨI TÊN (ĐÃ SỬA LỖI XUNG ĐỘT BỘ GÕ TIẾNG VIỆT)
     */
    function enableArrowKeyNavigation(modalId) {
        const modal = document.getElementById(modalId);
        if (!modal) return;

        // Lấy input và textarea (đã sửa để hỗ trợ cả textarea ghi chú)
        const inputs = modal.querySelectorAll('table input:not([disabled]):not([type="hidden"]), table textarea:not([disabled])');
        const inputArray = Array.from(inputs);
        
        if (inputArray.length === 0) return;

        const handleKeydown = (e) => {
            // --- FIX QUAN TRỌNG: CHỐNG XUNG ĐỘT BỘ GÕ (IME) ---
            // Nếu đang trong quá trình gõ tiếng Việt (isComposing) hoặc mã phím là 229 (IME processing) -> DỪNG LẠI NGAY
            if (e.isComposing || e.keyCode === 229) return;
            // --------------------------------------------------

            if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Enter'].includes(e.key)) return;

            const currentInput = e.target;
            const currentIndex = inputArray.indexOf(currentInput);
            
            if (currentIndex === -1) return;

            // --- LOGIC THÔNG MINH: KHI NÀO THÌ ĐƯỢC NHẢY Ô? ---
            
            // 1. Với phím TRÁI / PHẢI
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                // Nếu là ô Number (Số lượng, Đơn giá): Không bao giờ nhảy ô bằng phím Trái/Phải (để người dùng sửa số)
                // Trừ khi ô đó đang trống
                if (currentInput.type === 'number' && currentInput.value !== '') return;

                // Nếu là ô Text hoặc Textarea: Chỉ nhảy khi con trỏ ở sát mép
                if (currentInput.selectionStart !== undefined) {
                    const cursorStart = currentInput.selectionStart;
                    const cursorEnd = currentInput.selectionEnd;
                    const valueLen = currentInput.value.length;

                    // Nếu đang bôi đen văn bản -> Không nhảy
                    if (cursorStart !== cursorEnd) return;

                    // Nhấn TRÁI nhưng con trỏ chưa về sát đầu (vị trí 0) -> Không nhảy
                    if (e.key === 'ArrowLeft' && cursorStart > 0) return;

                    // Nhấn PHẢI nhưng con trỏ chưa về sát cuối -> Không nhảy
                    if (e.key === 'ArrowRight' && cursorStart < valueLen) return;
                }
            }

            // 2. Với phím LÊN / XUỐNG / ENTER trong TEXTAREA (Ghi chú)
            if (currentInput.tagName === 'TEXTAREA') {
                // Trong Textarea, Enter là xuống dòng, Mũi tên là di chuyển dòng -> Không được nhảy ô
                if (['Enter', 'ArrowUp', 'ArrowDown'].includes(e.key)) return;
            }
            
            // 3. Với phím LÊN / XUỐNG trong ô NUMBER
            if (currentInput.type === 'number' && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                e.preventDefault(); // Chặn việc tăng giảm số mặc định của trình duyệt
            }

            // --- XỬ LÝ ĐIỀU HƯỚNG (Tìm ô tiếp theo) ---
            const currentCell = currentInput.closest('td');
            const currentRow = currentCell.closest('tr');
            const cellsInRow = Array.from(currentRow.children);
            const currentCellIndex = cellsInRow.indexOf(currentCell);
            
            let nextInput = null;

            if (e.key === 'ArrowRight') {
                if (currentIndex < inputArray.length - 1) {
                    nextInput = inputArray[currentIndex + 1];
                    e.preventDefault(); 
                }
            } 
            else if (e.key === 'ArrowLeft') {
                if (currentIndex > 0) {
                    nextInput = inputArray[currentIndex - 1];
                    e.preventDefault();
                }
            } 
            else if (e.key === 'ArrowDown' || e.key === 'Enter') {
                const nextRow = currentRow.nextElementSibling;
                if (nextRow) {
                    const targetCell = nextRow.children[currentCellIndex];
                    if (targetCell) {
                        // Tìm input/textarea trong ô đích
                        const inputInTarget = targetCell.querySelector('input:not([disabled]):not([type="hidden"]), textarea:not([disabled])');
                        if (inputInTarget) {
                            nextInput = inputInTarget;
                        } else {
                            // Fallback: Tìm ô input đầu tiên ở dòng dưới (nếu ô cùng cột bị disabled)
                            const firstInputInNextRow = nextRow.querySelector('input:not([disabled]):not([type="hidden"]), textarea:not([disabled])');
                            if (firstInputInNextRow) nextInput = firstInputInNextRow;
                        }
                    }
                }
                if (e.key === 'Enter') e.preventDefault(); 
            } 
            else if (e.key === 'ArrowUp') {
                const prevRow = currentRow.previousElementSibling;
                if (prevRow) {
                    const targetCell = prevRow.children[currentCellIndex];
                    if (targetCell) {
                        const inputInTarget = targetCell.querySelector('input:not([disabled]):not([type="hidden"]), textarea:not([disabled])');
                        if (inputInTarget) {
                            nextInput = inputInTarget;
                        } else {
                            // Fallback: Tìm ô input đầu tiên ở dòng trên
                             const firstInputInPrevRow = prevRow.querySelector('input:not([disabled]):not([type="hidden"]), textarea:not([disabled])');
                             if (firstInputInPrevRow) nextInput = firstInputInPrevRow;
                        }
                    }
                }
            }

            // Chuyển Focus và Bôi đen toàn bộ (Select All) để tiện nhập liệu mới
            if (nextInput) {
                nextInput.focus();
                if (nextInput.select) {
                    nextInput.select();
                }
            }
        };

        // Clean up listeners cũ để tránh gán chồng chéo
        inputArray.forEach(input => {
            input.removeEventListener('keydown', handleKeydown);
            input.addEventListener('keydown', handleKeydown);
        });
    }

</script>



</body>
</html>
